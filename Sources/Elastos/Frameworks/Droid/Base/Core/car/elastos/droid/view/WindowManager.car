
module
{
    using interface Elastos.Core.ICharSequence;

    interface Elastos.Droid.Graphics.IRect;
    interface Elastos.Droid.Os.IBinder;
    interface Elastos.Droid.View.IDisplay;
    interface Elastos.Droid.View.IView;

    namespace Elastos {
    namespace Droid {
    namespace View {

    /**
     * @Involve
     * interface IViewGroupLayoutParams
     */
    [parcelable]
    interface IWindowManagerLayoutParams{

        /**
         * Start of window types that represent normal application windows.
         */
        const Int32 FIRST_APPLICATION_WINDOW = 1;

        /**
         * Window type: an application window that serves as the "base" window
         * of the overall application; all other application windows will
         * appear on top of it.
         * In multiuser systems shows only on the owning user's window.
         */
        const Int32 TYPE_BASE_APPLICATION   = 1;

        /**
         * Window type: a normal application window.  The {@link #token} must be
         * an Activity token identifying who the window belongs to.
         * In multiuser systems shows only on the owning user's window.
         */
        const Int32 TYPE_APPLICATION        = 2;

        /**
         * Window type: special application window that is displayed while the
         * application is starting.  Not for use by applications themselves;
         * this is used by the system to display something until the
         * application can show its own windows.
         * In multiuser systems shows on all users' windows.
         */
        const Int32 TYPE_APPLICATION_STARTING = 3;

        /**
         * End of types of application windows.
         */
        const Int32 LAST_APPLICATION_WINDOW = 99;

        /**
         * Start of types of sub-windows.  The {@link #token} of these windows
         * must be set to the window they are attached to.  These types of
         * windows are kept next to their attached window in Z-order, and their
         * coordinate space is relative to their attached window.
         */
        const Int32 FIRST_SUB_WINDOW        = 1000;

        /**
         * Window type: a panel on top of an application window.  These windows
         * appear on top of their attached window.
         */
        const Int32 TYPE_APPLICATION_PANEL  = 1000; //FIRST_SUB_WINDOW;

        /**
         * Window type: window for showing media (such as video).  These windows
         * are displayed behind their attached window.
         */
        const Int32 TYPE_APPLICATION_MEDIA  = 1001;//FIRST_SUB_WINDOW+1;

        /**
         * Window type: a sub-panel on top of an application window.  These
         * windows are displayed on top their attached window and any
         * {@link #TYPE_APPLICATION_PANEL} panels.
         */
        const Int32 TYPE_APPLICATION_SUB_PANEL = 1002;//FIRST_SUB_WINDOW+2;

        /** Window type: like {@link #TYPE_APPLICATION_PANEL}, but layout
         * of the window happens as that of a top-level window, <em>not</em>
         * as a child of its container.
         */
        const Int32 TYPE_APPLICATION_ATTACHED_DIALOG = 1003;//FIRST_SUB_WINDOW+3;

        /**
         * Window type: window for showing overlays on top of media windows.
         * These windows are displayed between TYPE_APPLICATION_MEDIA and the
         * application window.  They should be translucent to be useful.  This
         * is a big ugly hack so:
         * @hide
         */
        const Int32 TYPE_APPLICATION_MEDIA_OVERLAY  = 1004;//FIRST_SUB_WINDOW+4;

        /**
         * End of types of sub-windows.
         */
        const Int32 LAST_SUB_WINDOW         = 1999;

        /**
         * Start of system-specific window types.  These are not normally
         * created by applications.
         */
        const Int32 FIRST_SYSTEM_WINDOW     = 2000;

        /**
         * Window type: the status bar.  There can be only one status bar
         * window; it is placed at the top of the screen, and all other
         * windows are shifted down so they are below it.
         * In multiuser systems shows on all users' windows.
         */
        const Int32 TYPE_STATUS_BAR         = 2000;//FIRST_SYSTEM_WINDOW;

        /**
         * Window type: the search bar.  There can be only one search bar
         * window; it is placed at the top of the screen.
         * In multiuser systems shows on all users' windows.
         */
        const Int32 TYPE_SEARCH_BAR         = 2001;//FIRST_SYSTEM_WINDOW+1;

        /**
         * Window type: phone.  These are non-application windows providing
         * user interaction with the phone (in particular incoming calls).
         * These windows are normally placed above all applications, but behind
         * the status bar.
         * In multiuser systems shows on all users' windows.
         */
        const Int32 TYPE_PHONE              = 2002;//FIRST_SYSTEM_WINDOW+2;

        /**
         * Window type: system window, such as low power alert. These windows
         * are always on top of application windows.
         * In multiuser systems shows only on the owning user's window.
         */
        const Int32 TYPE_SYSTEM_ALERT       = 2003;//FIRST_SYSTEM_WINDOW+3;

        /**
         * Window type: keyguard window.
         * In multiuser systems shows on all users' windows.
         * @removed
         */
        const Int32 TYPE_KEYGUARD           = 2004;//FIRST_SYSTEM_WINDOW+4;

        /**
         * Window type: transient notifications.
         * In multiuser systems shows only on the owning user's window.
         */
        const Int32 TYPE_TOAST              = 2005;//FIRST_SYSTEM_WINDOW+5;

        /**
         * Window type: system overlay windows, which need to be displayed
         * on top of everything else.  These windows must not take input
         * focus, or they will interfere with the keyguard.
         * In multiuser systems shows only on the owning user's window.
         */
        const Int32 TYPE_SYSTEM_OVERLAY     = 2006;//FIRST_SYSTEM_WINDOW+6;

        /**
         * Window type: priority phone UI, which needs to be displayed even if
         * the keyguard is active.  These windows must not take input
         * focus, or they will interfere with the keyguard.
         * In multiuser systems shows on all users' windows.
         */
        const Int32 TYPE_PRIORITY_PHONE     = 2007;//FIRST_SYSTEM_WINDOW+7;

        /**
         * Window type: panel that slides out from the status bar
         * In multiuser systems shows on all users' windows.
         */
        const Int32 TYPE_SYSTEM_DIALOG      = 2008;//FIRST_SYSTEM_WINDOW+8;

        /**
         * Window type: dialogs that the keyguard shows
         * In multiuser systems shows on all users' windows.
         */
        const Int32 TYPE_KEYGUARD_DIALOG    = 2009;//FIRST_SYSTEM_WINDOW+9;

        /**
         * Window type: internal system error windows, appear on top of
         * everything they can.
         * In multiuser systems shows only on the owning user's window.
         */
        const Int32 TYPE_SYSTEM_ERROR       = 2010;//FIRST_SYSTEM_WINDOW+10;

        /**
         * Window type: internal input methods windows, which appear above
         * the normal UI.  Application windows may be resized or panned to keep
         * the input focus visible while this window is displayed.
         * In multiuser systems shows only on the owning user's window.
         */
        const Int32 TYPE_INPUT_METHOD       = 2011;//FIRST_SYSTEM_WINDOW+11;

        /**
         * Window type: internal input methods dialog windows, which appear above
         * the current input method window.
         * In multiuser systems shows only on the owning user's window.
         */
        const Int32 TYPE_INPUT_METHOD_DIALOG= 2012;//FIRST_SYSTEM_WINDOW+12;

        /**
         * Window type: wallpaper window, placed behind any window that wants
         * to sit on top of the wallpaper.
         * In multiuser systems shows only on the owning user's window.
         */
        const Int32 TYPE_WALLPAPER          = 2013;//FIRST_SYSTEM_WINDOW+13;

        /**
         * Window type: panel that slides out from over the status bar
         * In multiuser systems shows on all users' windows.
         */
        const Int32 TYPE_STATUS_BAR_PANEL   = 2014;//FIRST_SYSTEM_WINDOW+14;

        /**
         * Window type: secure system overlay windows, which need to be displayed
         * on top of everything else.  These windows must not take input
         * focus, or they will interfere with the keyguard.
         *
         * This is exactly like {@link #TYPE_SYSTEM_OVERLAY} except that only the
         * system itself is allowed to create these overlays.  Applications cannot
         * obtain permission to create secure system overlays.
         *
         * In multiuser systems shows only on the owning user's window.
         * @hide
         */
        const Int32 TYPE_SECURE_SYSTEM_OVERLAY = 2015;//FIRST_SYSTEM_WINDOW+15;

        /**
         * Window type: the drag-and-drop pseudowindow.  There is only one
         * drag layer (at most), and it is placed on top of all other windows.
         * In multiuser systems shows only on the owning user's window.
         * @hide
         */
        const Int32 TYPE_DRAG               = 2016;//FIRST_SYSTEM_WINDOW+16;

        /**
         * Window type: panel that slides out from under the status bar
         * In multiuser systems shows on all users' windows.
         * @hide
         */
        const Int32 TYPE_STATUS_BAR_SUB_PANEL = 2017;//FIRST_SYSTEM_WINDOW+17;

        /**
         * Window type: (mouse) pointer
         * In multiuser systems shows on all users' windows.
         * @hide
         */
        const Int32 TYPE_POINTER = 2018;//FIRST_SYSTEM_WINDOW+18;

        /**
         * Window type: Navigation bar (when distinct from status bar)
         * In multiuser systems shows on all users' windows.
         * @hide
         */
        const Int32 TYPE_NAVIGATION_BAR = 2019;//FIRST_SYSTEM_WINDOW+19;

        /**
         * Window type: The volume level overlay/dialog shown when the user
         * changes the system volume.
         * In multiuser systems shows on all users' windows.
         * @hide
         */
        const Int32 TYPE_VOLUME_OVERLAY = 2020;//FIRST_SYSTEM_WINDOW+20;

        /**
         * Window type: The boot progress dialog, goes on top of everything
         * in the world.
         * In multiuser systems shows on all users' windows.
         * @hide
         */
        const Int32 TYPE_BOOT_PROGRESS = 2021;//FIRST_SYSTEM_WINDOW+21;

        /**
         * Window type: Fake window to consume touch events when the navigation
         * bar is hidden.
         * In multiuser systems shows on all users' windows.
         * @hide
         */
        const Int32 TYPE_HIDDEN_NAV_CONSUMER = 2022;//FIRST_SYSTEM_WINDOW+22;

        /**
         * Window type: Dreams (screen saver) window, just above keyguard.
         * In multiuser systems shows only on the owning user's window.
         * @hide
         */
        const Int32 TYPE_DREAM = 2023;//FIRST_SYSTEM_WINDOW+23;

        /**
         * Window type: Navigation bar panel (when navigation bar is distinct from status bar)
         * In multiuser systems shows on all users' windows.
         * @hide
         */
        const Int32 TYPE_NAVIGATION_BAR_PANEL = 2024;//FIRST_SYSTEM_WINDOW+24;

        /**
         * Window type: Behind the universe of the real windows.
         * In multiuser systems shows on all users' windows.
         * @hide
         */
        const Int32 TYPE_UNIVERSE_BACKGROUND = 2025;//FIRST_SYSTEM_WINDOW+25;

        /**
         * Window type: Display overlay window.  Used to simulate secondary display devices.
         * In multiuser systems shows on all users' windows.
         * @hide
         */
        const Int32 TYPE_DISPLAY_OVERLAY = 2026;//FIRST_SYSTEM_WINDOW+26;

        /**
         * Window type: Magnification overlay window. Used to highlight the magnified
         * portion of a display when accessibility magnification is enabled.
         * In multiuser systems shows on all users' windows.
         * @hide
         */
        const Int32 TYPE_MAGNIFICATION_OVERLAY = 2027;//FIRST_SYSTEM_WINDOW+27;

        /**
         * Window type: Recents. Same layer as {@link #TYPE_SYSTEM_DIALOG} but only appears on
         * one user's screen.
         * In multiuser systems shows on all users' windows.
         * @hide
         */
        const Int32 TYPE_RECENTS_OVERLAY = 2028;//FIRST_SYSTEM_WINDOW+28;

        /**
         * Window type: keyguard scrim window. Shows if keyguard needs to be restarted.
         * In multiuser systems shows on all users' windows.
         * @hide
         */
        const Int32 TYPE_KEYGUARD_SCRIM           = 2029;//FIRST_SYSTEM_WINDOW+29;

        /**
         * Window type: Window for Presentation on top of private
         * virtual display.
         */
        const Int32 TYPE_PRIVATE_PRESENTATION = 2030;//FIRST_SYSTEM_WINDOW+30;

        /**
         * Window type: Windows in the voice interaction layer.
         * @hide
         */
        const Int32 TYPE_VOICE_INTERACTION = 2031;//FIRST_SYSTEM_WINDOW+31;

        /**
         * End of types of system windows.
         */
        const Int32 LAST_SYSTEM_WINDOW      = 2999;

        /** @deprecated this is ignored, this value is set automatically when needed. */
        //@Deprecated
        const Int32 MEMORY_TYPE_NORMAL = 0;
        /** @deprecated this is ignored, this value is set automatically when needed. */
        //@Deprecated
        const Int32 MEMORY_TYPE_HARDWARE = 1;
        /** @deprecated this is ignored, this value is set automatically when needed. */
        //@Deprecated
        const Int32 MEMORY_TYPE_GPU = 2;
        /** @deprecated this is ignored, this value is set automatically when needed. */
        //@Deprecated
        const Int32 MEMORY_TYPE_PUSH_BUFFERS = 3;


        /** Window flag: as long as this window is visible to the user, allow
         *  the lock screen to activate while the screen is on.
         *  This can be used independently, or in combination with
         *  {@link #FLAG_KEEP_SCREEN_ON} and/or {@link #FLAG_SHOW_WHEN_LOCKED} */
        const Int32 FLAG_ALLOW_LOCK_WHILE_SCREEN_ON     = 0x00000001;

        /** Window flag: everything behind this window will be dimmed.
         *  Use {@link #dimAmount} to control the amount of dim. */
        const Int32 FLAG_DIM_BEHIND        = 0x00000002;

        /** Window flag: blur everything behind this window.
         * @deprecated Blurring is no longer supported. */
        //@Deprecated
        const Int32 FLAG_BLUR_BEHIND        = 0x00000004;

        /** Window flag: this window won't ever get key input focus, so the
         * user can not send key or other button events to it.  Those will
         * instead go to whatever focusable window is behind it.  This flag
         * will also enable {@link #FLAG_NOT_TOUCH_MODAL} whether or not that
         * is explicitly set.
         *
         * <p>Setting this flag also implies that the window will not need to
         * interact with
         * a soft input method, so it will be Z-ordered and positioned
         * independently of any active input method (typically this means it
         * gets Z-ordered on top of the input method, so it can use the full
         * screen for its content and cover the input method if needed.  You
         * can use {@link #FLAG_ALT_FOCUSABLE_IM} to modify this behavior. */
        const Int32 FLAG_NOT_FOCUSABLE      = 0x00000008;

        /** Window flag: this window can never receive touch events. */
        const Int32 FLAG_NOT_TOUCHABLE      = 0x00000010;

        /** Window flag: even when this window is focusable (its
         * {@link #FLAG_NOT_FOCUSABLE} is not set), allow any pointer events
         * outside of the window to be sent to the windows behind it.  Otherwise
         * it will consume all pointer events itself, regardless of whether they
         * are inside of the window. */
        const Int32 FLAG_NOT_TOUCH_MODAL    = 0x00000020;

        /** Window flag: when set, if the device is asleep when the touch
         * screen is pressed, you will receive this first touch event.  Usually
         * the first touch event is consumed by the system since the user can
         * not see what they are pressing on.
         *
         * @deprecated This flag has no effect.
         */
        //@Deprecated
        const Int32 FLAG_TOUCHABLE_WHEN_WAKING = 0x00000040;

        /** Window flag: as long as this window is visible to the user, keep
         *  the device's screen turned on and bright. */
        const Int32 FLAG_KEEP_SCREEN_ON     = 0x00000080;

        /** Window flag: place the window within the entire screen, ignoring
         *  decorations around the border (such as the status bar).  The
         *  window must correctly position its contents to take the screen
         *  decoration into account.  This flag is normally set for you
         *  by Window as described in {@link Window#setFlags}. */
        const Int32 FLAG_LAYOUT_IN_SCREEN   = 0x00000100;

        /** Window flag: allow window to extend outside of the screen. */
        const Int32 FLAG_LAYOUT_NO_LIMITS   = 0x00000200;

        /**
         * Window flag: hide all screen decorations (such as the status bar) while
         * this window is displayed.  This allows the window to use the entire
         * display space for itself -- the status bar will be hidden when
         * an app window with this flag set is on the top layer. A fullscreen window
         * will ignore a value of {@link #SOFT_INPUT_ADJUST_RESIZE} for the window's
         * {@link #softInputMode} field; the window will stay fullscreen
         * and will not resize.
         *
         * <p>This flag can be controlled in your theme through the
         * {@link android.R.attr#windowFullscreen} attribute; this attribute
         * is automatically set for you in the standard fullscreen themes
         * such as {@link android.R.style#Theme_NoTitleBar_Fullscreen},
         * {@link android.R.style#Theme_Black_NoTitleBar_Fullscreen},
         * {@link android.R.style#Theme_Light_NoTitleBar_Fullscreen},
         * {@link android.R.style#Theme_Holo_NoActionBar_Fullscreen},
         * {@link android.R.style#Theme_Holo_Light_NoActionBar_Fullscreen},
         * {@link android.R.style#Theme_DeviceDefault_NoActionBar_Fullscreen}, and
         * {@link android.R.style#Theme_DeviceDefault_Light_NoActionBar_Fullscreen}.</p>
         */
        const Int32 FLAG_FULLSCREEN      = 0x00000400;

        /** Window flag: override {@link #FLAG_FULLSCREEN} and force the
         *  screen decorations (such as the status bar) to be shown. */
        const Int32 FLAG_FORCE_NOT_FULLSCREEN   = 0x00000800;

        /** Window flag: turn on dithering when compositing this window to
         *  the screen.
         * @deprecated This flag is no longer used. */
        //@Deprecated
        const Int32 FLAG_DITHER             = 0x00001000;

        /** Window flag: treat the content of the window as secure, preventing
         * it from appearing in screenshots or from being viewed on non-secure
         * displays.
         *
         * <p>See {@link android.view.Display#FLAG_SECURE} for more details about
         * secure surfaces and secure displays.
         */
        const Int32 FLAG_SECURE             = 0x00002000;

        /** Window flag: a special mode where the layout parameters are used
         * to perform scaling of the surface when it is composited to the
         * screen. */
        const Int32 FLAG_SCALED             = 0x00004000;

        /** Window flag: intended for windows that will often be used when the user is
         * holding the screen against their face, it will aggressively filter the event
         * stream to prevent unintended presses in this situation that may not be
         * desired for a particular window, when such an event stream is detected, the
         * application will receive a CANCEL motion event to indicate this so applications
         * can handle this accordingly by taking no action on the event
         * until the finger is released. */
        const Int32 FLAG_IGNORE_CHEEK_PRESSES    = 0x00008000;

        /** Window flag: a special option only for use in combination with
         * {@link #FLAG_LAYOUT_IN_SCREEN}.  When requesting layout in the
         * screen your window may appear on top of or behind screen decorations
         * such as the status bar.  By also including this flag, the window
         * manager will report the inset rectangle needed to ensure your
         * content is not covered by screen decorations.  This flag is normally
         * set for you by Window as described in {@link Window#setFlags}.*/
        const Int32 FLAG_LAYOUT_INSET_DECOR = 0x00010000;

        /** Window flag: invert the state of {@link #FLAG_NOT_FOCUSABLE} with
         * respect to how this window interacts with the current method.  That
         * is, if FLAG_NOT_FOCUSABLE is set and this flag is set, then the
         * window will behave as if it needs to interact with the input method
         * and thus be placed behind/away from it; if FLAG_NOT_FOCUSABLE is
         * not set and this flag is set, then the window will behave as if it
         * doesn't need to interact with the input method and can be placed
         * to use more space and cover the input method.
         */
        const Int32 FLAG_ALT_FOCUSABLE_IM = 0x00020000;

        /** Window flag: if you have set {@link #FLAG_NOT_TOUCH_MODAL}, you
         * can set this flag to receive a single special MotionEvent with
         * the action
         * {@link MotionEvent#ACTION_OUTSIDE MotionEvent.ACTION_OUTSIDE} for
         * touches that occur outside of your window.  Note that you will not
         * receive the full down/move/up gesture, only the location of the
         * first down as an ACTION_OUTSIDE.
         */
        const Int32 FLAG_WATCH_OUTSIDE_TOUCH = 0x00040000;

        /** Window flag: special flag to let windows be shown when the screen
         * is locked. This will let application windows take precedence over
         * key guard or any other lock screens. Can be used with
         * {@link #FLAG_KEEP_SCREEN_ON} to turn screen on and display windows
         * directly before showing the key guard window.  Can be used with
         * {@link #FLAG_DISMISS_KEYGUARD} to automatically fully dismisss
         * non-secure keyguards.  This flag only applies to the top-most
         * full-screen window.
         */
        const Int32 FLAG_SHOW_WHEN_LOCKED = 0x00080000;

        /** Window flag: ask that the system wallpaper be shown behind
         * your window.  The window surface must be translucent to be able
         * to actually see the wallpaper behind it; this flag just ensures
         * that the wallpaper surface will be there if this window actually
         * has translucent regions.
         *
         * <p>This flag can be controlled in your theme through the
         * {@link android.R.attr#windowShowWallpaper} attribute; this attribute
         * is automatically set for you in the standard wallpaper themes
         * such as {@link android.R.style#Theme_Wallpaper},
         * {@link android.R.style#Theme_Wallpaper_NoTitleBar},
         * {@link android.R.style#Theme_Wallpaper_NoTitleBar_Fullscreen},
         * {@link android.R.style#Theme_Holo_Wallpaper},
         * {@link android.R.style#Theme_Holo_Wallpaper_NoTitleBar},
         * {@link android.R.style#Theme_DeviceDefault_Wallpaper}, and
         * {@link android.R.style#Theme_DeviceDefault_Wallpaper_NoTitleBar}.</p>
         */
        const Int32 FLAG_SHOW_WALLPAPER = 0x00100000;

        /** Window flag: when set as a window is being added or made
         * visible, once the window has been shown then the system will
         * poke the power manager's user activity (as if the user had woken
         * up the device) to turn the screen on. */
        const Int32 FLAG_TURN_SCREEN_ON = 0x00200000;

        /** Window flag: when set the window will cause the keyguard to
         * be dismissed, only if it is not a secure lock keyguard.  Because such
         * a keyguard is not needed for security, it will never re-appear if
         * the user navigates to another window (in contrast to
         * {@link #FLAG_SHOW_WHEN_LOCKED}, which will only temporarily
         * hide both secure and non-secure keyguards but ensure they reappear
         * when the user moves to another UI that doesn't hide them).
         * If the keyguard is currently active and is secure (requires an
         * unlock pattern) than the user will still need to confirm it before
         * seeing this window, unless {@link #FLAG_SHOW_WHEN_LOCKED} has
         * also been set.
         */
        const Int32 FLAG_DISMISS_KEYGUARD = 0x00400000;

        /** Window flag: when set the window will accept for touch events
         * outside of its bounds to be sent to other windows that also
         * support split touch.  When this flag is not set, the first pointer
         * that goes down determines the window to which all subsequent touches
         * go until all pointers go up.  When this flag is set, each pointer
         * (not necessarily the first) that goes down determines the window
         * to which all subsequent touches of that pointer will go until that
         * pointer goes up thereby enabling touches with multiple pointers
         * to be split across multiple windows.
         */
        const Int32 FLAG_SPLIT_TOUCH = 0x00800000;

        /**
         * <p>Indicates whether this window should be hardware accelerated.
         * Requesting hardware acceleration does not guarantee it will happen.</p>
         *
         * <p>This flag can be controlled programmatically <em>only</em> to enable
         * hardware acceleration. To enable hardware acceleration for a given
         * window programmatically, do the following:</p>
         *
         * <pre>
         * Window w = activity.getWindow(); // in Activity's onCreate() for instance
         * w.setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
         *         WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
         * </pre>
         *
         * <p>It is important to remember that this flag <strong>must</strong>
         * be set before setting the content view of your activity or dialog.</p>
         *
         * <p>This flag cannot be used to disable hardware acceleration after it
         * was enabled in your manifest using
         * {@link android.R.attr#hardwareAccelerated}. If you need to selectively
         * and programmatically disable hardware acceleration (for automated testing
         * for instance), make sure it is turned off in your manifest and enable it
         * on your activity or dialog when you need it instead, using the method
         * described above.</p>
         *
         * <p>This flag is automatically set by the system if the
         * {@link android.R.attr#hardwareAccelerated android:hardwareAccelerated}
         * XML attribute is set to true on an activity or on the application.</p>
         */
        const Int32 FLAG_HARDWARE_ACCELERATED = 0x01000000;

        /**
         * Window flag: allow window contents to extend in to the screen's
         * overscan area, if there is one.  The window should still correctly
         * position its contents to take the overscan area into account.
         *
         * <p>This flag can be controlled in your theme through the
         * {@link android.R.attr#windowOverscan} attribute; this attribute
         * is automatically set for you in the standard overscan themes
         * such as
         * {@link android.R.style#Theme_Holo_NoActionBar_Overscan},
         * {@link android.R.style#Theme_Holo_Light_NoActionBar_Overscan},
         * {@link android.R.style#Theme_DeviceDefault_NoActionBar_Overscan}, and
         * {@link android.R.style#Theme_DeviceDefault_Light_NoActionBar_Overscan}.</p>
         *
         * <p>When this flag is enabled for a window, its normal content may be obscured
         * to some degree by the overscan region of the display.  To ensure key parts of
         * that content are visible to the user, you can use
         * {@link View#setFitsSystemWindows(boolean) View.setFitsSystemWindows(boolean)}
         * to set the point in the view hierarchy where the appropriate offsets should
         * be applied.  (This can be done either by directly calling this function, using
         * the {@link android.R.attr#fitsSystemWindows} attribute in your view hierarchy,
         * or implementing you own {@link View#fitSystemWindows(android.graphics.Rect)
         * View.fitSystemWindows(Rect)} method).</p>
         *
         * <p>This mechanism for positioning content elements is identical to its equivalent
         * use with layout and {@link View#setSystemUiVisibility(int)
         * View.setSystemUiVisibility(int)}; here is an example layout that will correctly
         * position its UI elements with this overscan flag is set:</p>
         *
         * {@sample development/samples/ApiDemos/res/layout/overscan_activity.xml complete}
         */
        const Int32 FLAG_LAYOUT_IN_OVERSCAN = 0x02000000;

        /**
         * Window flag: request a translucent status bar with minimal system-provided
         * background protection.
         *
         * <p>This flag can be controlled in your theme through the
         * {@link android.R.attr#windowTranslucentStatus} attribute; this attribute
         * is automatically set for you in the standard translucent decor themes
         * such as
         * {@link android.R.style#Theme_Holo_NoActionBar_TranslucentDecor},
         * {@link android.R.style#Theme_Holo_Light_NoActionBar_TranslucentDecor},
         * {@link android.R.style#Theme_DeviceDefault_NoActionBar_TranslucentDecor}, and
         * {@link android.R.style#Theme_DeviceDefault_Light_NoActionBar_TranslucentDecor}.</p>
         *
         * <p>When this flag is enabled for a window, it automatically sets
         * the system UI visibility flags {@link View#SYSTEM_UI_FLAG_LAYOUT_STABLE} and
         * {@link View#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}.</p>
         */
        const Int32 FLAG_TRANSLUCENT_STATUS = 0x04000000;

        /**
         * Window flag: request a translucent navigation bar with minimal system-provided
         * background protection.
         *
         * <p>This flag can be controlled in your theme through the
         * {@link android.R.attr#windowTranslucentNavigation} attribute; this attribute
         * is automatically set for you in the standard translucent decor themes
         * such as
         * {@link android.R.style#Theme_Holo_NoActionBar_TranslucentDecor},
         * {@link android.R.style#Theme_Holo_Light_NoActionBar_TranslucentDecor},
         * {@link android.R.style#Theme_DeviceDefault_NoActionBar_TranslucentDecor}, and
         * {@link android.R.style#Theme_DeviceDefault_Light_NoActionBar_TranslucentDecor}.</p>
         *
         * <p>When this flag is enabled for a window, it automatically sets
         * the system UI visibility flags {@link View#SYSTEM_UI_FLAG_LAYOUT_STABLE} and
         * {@link View#SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION}.</p>
         */
        const Int32 FLAG_TRANSLUCENT_NAVIGATION = 0x08000000;

        // ----- HIDDEN FLAGS.
        // These start at the high bit and go down.

        /**
         * Flag for a window in local focus mode.
         * Window in local focus mode can control focus independent of window manager using
         * {@link Window#setLocalFocus(boolean, boolean)}.
         * Usually window in this mode will not get touch/key events from window manager, but will
         * get events only via local injection using {@link Window#injectInputEvent(InputEvent)}.
         */
        const Int32 FLAG_LOCAL_FOCUS_MODE = 0x10000000;

        /** Window flag: Enable touches to slide out of a window into neighboring
         * windows in mid-gesture instead of being captured for the duration of
         * the gesture.
         *
         * This flag changes the behavior of touch focus for this window only.
         * Touches can slide out of the window but they cannot necessarily slide
         * back in (unless the other window with touch focus permits it).
         *
         * {@hide}
         */
        const Int32 FLAG_SLIPPERY = 0x20000000;

        /**
         * Flag for a window belonging to an activity that responds to {@link KeyEvent#KEYCODE_MENU}
         * and therefore needs a Menu key. For devices where Menu is a physical button this flag is
         * ignored, but on devices where the Menu key is drawn in software it may be hidden unless
         * this flag is set.
         *
         * (Note that Action Bars, when available, are the preferred way to offer additional
         * functions otherwise accessed via an options menu.)
         *
         * {@hide}
         */
        const Int32 FLAG_NEEDS_MENU_KEY = 0x40000000;

        /**
         * Flag indicating that this Window is responsible for drawing the background for the
         * system bars. If set, the system bars are drawn with a transparent background and the
         * corresponding areas in this window are filled with the colors specified in
         * {@link Window#getStatusBarColor()} and {@link Window#getNavigationBarColor()}.
         */
        const Int32 FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS = 0x80000000;

        /**
         * If the window has requested hardware acceleration, but this is not
         * allowed in the process it is in, then still render it as if it is
         * hardware accelerated.  This is used for the starting preview windows
         * in the system process, which don't need to have the overhead of
         * hardware acceleration (they are just a static rendering), but should
         * be rendered as such to match the actual window of the app even if it
         * is hardware accelerated.
         * Even if the window isn't hardware accelerated, still do its rendering
         * as if it was.
         * Like {@link #FLAG_HARDWARE_ACCELERATED} except for trusted system windows
         * that need hardware acceleration (e.g. LockScreen), where hardware acceleration
         * is generally disabled. This flag must be specified in addition to
         * {@link #FLAG_HARDWARE_ACCELERATED} to enable hardware acceleration for system
         * windows.
         *
         * @hide
         */
        const Int32 PRIVATE_FLAG_FAKE_HARDWARE_ACCELERATED = 0x00000001;

        /**
         * In the system process, we globally do not use hardware acceleration
         * because there are many threads doing UI there and they conflict.
         * If certain parts of the UI that really do want to use hardware
         * acceleration, this flag can be set to force it.  This is basically
         * for the lock screen.  Anyone else using it, you are probably wrong.
         *
         * @hide
         */
        const Int32 PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED = 0x00000002;

        /**
         * By default, wallpapers are sent new offsets when the wallpaper is scrolled. Wallpapers
         * may elect to skip these notifications if they are not doing anything productive with
         * them (they do not affect the wallpaper scrolling operation) by calling
         * {@link
         * android.service.wallpaper.WallpaperService.Engine#setOffsetNotificationsEnabled(boolean)}.
         *
         * @hide
         */
        const Int32 PRIVATE_FLAG_WANTS_OFFSET_NOTIFICATIONS = 0x00000004;

        /**
         * This is set for a window that has explicitly specified its
         * FLAG_NEEDS_MENU_KEY, so we know the value on this window is the
         * appropriate one to use.  If this is not set, we should look at
         * windows behind it to determine the appropriate value.
         *
         * @hide
         */
        const Int32 PRIVATE_FLAG_SET_NEEDS_MENU_KEY = 0x00000008;

        /** In a multiuser system if this flag is set and the owner is a system process then this
         * window will appear on all user screens. This overrides the default behavior of window
         * types that normally only appear on the owning user's screen. Refer to each window type
         * to determine its default behavior.
         *
         * {@hide} */
        const Int32 PRIVATE_FLAG_SHOW_FOR_ALL_USERS = 0x00000010;

        /**
         * Never animate position changes of the window.
         *
         * {@hide} */
        const Int32 PRIVATE_FLAG_NO_MOVE_ANIMATION = 0x00000040;

        /** Window flag: special flag to limit the size of the window to be
         * original size ([320x480] x density). Used to create window for applications
         * running under compatibility mode.
         *
         * {@hide} */
        const Int32 PRIVATE_FLAG_COMPATIBLE_WINDOW = 0x00000080;

        /** Window flag: a special option intended for system dialogs.  When
         * this flag is set, the window will demand focus unconditionally when
         * it is created.
         * {@hide} */
        const Int32 PRIVATE_FLAG_SYSTEM_ERROR = 0x00000100;

        /** Window flag: maintain the previous translucent decor state when this window
         * becomes top-most.
         * {@hide} */
        const Int32 PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR = 0x00000200;

        /**
         * Flag whether the current window is a keyguard window, meaning that it will hide all other
         * windows behind it except for windows with flag {@link #FLAG_SHOW_WHEN_LOCKED} set.
         * Further, this can only be set by {@link LayoutParams#TYPE_STATUS_BAR}.
         * {@hide}
         */
        const Int32 PRIVATE_FLAG_KEYGUARD = 0x00000400;

        /** Window flag: mark layer as fully transparent
         * {@hide} */
        const Int32 PRIVATE_FLAG_FULLY_TRANSPARENT = 0x10000000;

        /**
         * {@hide}
         */
        const Int32 PRIVATE_FLAG_STATUS_HIDE_FORCED = 0x00000800;
        /**
         * {@hide}
         */
        const Int32 PRIVATE_FLAG_NAV_HIDE_FORCED = 0x00001000;
        /**
         * The window had not set FULLSCREEN flag so don't handle it as fullscreen in layoutWindowLw
         *
         * {@hide}
         */
        const Int32 PRIVATE_FLAG_WAS_NOT_FULLSCREEN = 0x00002000;

        /**
         * Window flag: Overrides default power key behavior
         * {@hide}
         */
        const Int32 PRIVATE_FLAG_PREVENT_POWER_KEY = 0x20000000;

        /**
         * Window flag: adding additional blur layer and set this as masking layer
         * {@hide}
         */
        const Int32 PRIVATE_FLAG_BLUR_WITH_MASKING = 0x40000000;

        /**
         * Window flag: adding additional blur layer and set this as masking layer.
         * This is faster and ugglier than non-scaled version.
         * {@hide}
         */
        const Int32 PRIVATE_FLAG_BLUR_WITH_MASKING_SCALED = 0x80000000;

        /**
         * Mask for {@link #softInputMode} of the bits that determine the
         * desired visibility state of the soft input area for this window.
         */
        const Int32 SOFT_INPUT_MASK_STATE = 0x0f;

        /**
         * Visibility state for {@link #softInputMode}: no state has been specified.
         */
        const Int32 SOFT_INPUT_STATE_UNSPECIFIED = 0;

        /**
         * Visibility state for {@link #softInputMode}: please don't change the state of
         * the soft input area.
         */
        const Int32 SOFT_INPUT_STATE_UNCHANGED = 1;

        /**
         * Visibility state for {@link #softInputMode}: please hide any soft input
         * area when normally appropriate (when the user is navigating
         * forward to your window).
         */
        const Int32 SOFT_INPUT_STATE_HIDDEN = 2;

        /**
         * Visibility state for {@link #softInputMode}: please always hide any
         * soft input area when this window receives focus.
         */
        const Int32 SOFT_INPUT_STATE_ALWAYS_HIDDEN = 3;

        /**
         * Visibility state for {@link #softInputMode}: please show the soft
         * input area when normally appropriate (when the user is navigating
         * forward to your window).
         */
        const Int32 SOFT_INPUT_STATE_VISIBLE = 4;

        /**
         * Visibility state for {@link #softInputMode}: please always make the
         * soft input area visible when this window receives input focus.
         */
        const Int32 SOFT_INPUT_STATE_ALWAYS_VISIBLE = 5;

        /**
         * Mask for {@link #softInputMode} of the bits that determine the
         * way that the window should be adjusted to accommodate the soft
         * input window.
         */
        const Int32 SOFT_INPUT_MASK_ADJUST = 0xf0;

        /** Adjustment option for {@link #softInputMode}: nothing specified.
         * The system will try to pick one or
         * the other depending on the contents of the window.
         */
        const Int32 SOFT_INPUT_ADJUST_UNSPECIFIED = 0x00;

        /** Adjustment option for {@link #softInputMode}: set to allow the
         * window to be resized when an input
         * method is shown, so that its contents are not covered by the input
         * method.  This can <em>not</em> be combined with
         * {@link #SOFT_INPUT_ADJUST_PAN}; if
         * neither of these are set, then the system will try to pick one or
         * the other depending on the contents of the window. If the window's
         * layout parameter flags include {@link #FLAG_FULLSCREEN}, this
         * value for {@link #softInputMode} will be ignored; the window will
         * not resize, but will stay fullscreen.
         */
        const Int32 SOFT_INPUT_ADJUST_RESIZE = 0x10;

        /** Adjustment option for {@link #softInputMode}: set to have a window
         * pan when an input method is
         * shown, so it doesn't need to deal with resizing but just panned
         * by the framework to ensure the current input focus is visible.  This
         * can <em>not</em> be combined with {@link #SOFT_INPUT_ADJUST_RESIZE}; if
         * neither of these are set, then the system will try to pick one or
         * the other depending on the contents of the window.
         */
        const Int32 SOFT_INPUT_ADJUST_PAN = 0x20;

        /** Adjustment option for {@link #softInputMode}: set to have a window
         * not adjust for a shown input method.  The window will not be resized,
         * and it will not be panned to make its focus visible.
         */
        const Int32 SOFT_INPUT_ADJUST_NOTHING = 0x30;

        /**
         * Bit for {@link #softInputMode}: set when the user has navigated
         * forward to the window.  This is normally set automatically for
         * you by the system, though you may want to set it in certain cases
         * when you are displaying a window yourself.  This flag will always
         * be cleared automatically after the window is displayed.
         */
        const Int32 SOFT_INPUT_IS_FORWARD_NAVIGATION = 0x100;

        /**
         * Default value for {@link #screenBrightness} and {@link #buttonBrightness}
         * indicating that the brightness value is not overridden for this window
         * and normal brightness policy should be used.
         */
        const Float BRIGHTNESS_OVERRIDE_NONE = -1.0;

        /**
         * Value for {@link #screenBrightness} and {@link #buttonBrightness}
         * indicating that the screen or button backlight brightness should be set
         * to the lowest value when this window is in front.
         */
        const Float BRIGHTNESS_OVERRIDE_OFF = 0.0;

        /**
         * Value for {@link #screenBrightness} and {@link #buttonBrightness}
         * indicating that the screen or button backlight brightness should be set
         * to the hightest value when this window is in front.
         */
        const Float BRIGHTNESS_OVERRIDE_FULL = 1.0;

        /**
         * Value for {@link #rotationAnimation} to define the animation used to
         * specify that this window will rotate in or out following a rotation.
         */
        const Int32 ROTATION_ANIMATION_ROTATE = 0;

        /**
         * Value for {@link #rotationAnimation} to define the animation used to
         * specify that this window will fade in or out following a rotation.
         */
        const Int32 ROTATION_ANIMATION_CROSSFADE = 1;

        /**
         * Value for {@link #rotationAnimation} to define the animation used to
         * specify that this window will immediately disappear or appear following
         * a rotation.
         */
        const Int32 ROTATION_ANIMATION_JUMPCUT = 2;

        /**
         * When this window has focus, disable touch pad pointer gesture processing.
         * The window will receive raw position updates from the touch pad instead
         * of pointer movements and synthetic touch events.
         *
         * @hide
         */
        const Int32 INPUT_FEATURE_DISABLE_POINTER_GESTURES = 0x00000001;

        /**
         * Does not construct an input channel for this window.  The channel will therefore
         * be incapable of receiving input.
         *
         * @hide
         */
        const Int32 INPUT_FEATURE_NO_INPUT_CHANNEL = 0x00000002;

        /**
         * When this window has focus, does not call user activity for all input events so
         * the application will have to do it itself.  Should only be used by
         * the keyguard and phone app.
         * <p>
         * Should only be used by the keyguard and phone app.
         * </p>
         *
         * @hide
         */
        const Int32 INPUT_FEATURE_DISABLE_USER_ACTIVITY = 0x00000004;

        const Int32 LAYOUT_CHANGED = 1<<0;
        const Int32 TYPE_CHANGED = 1<<1;
        const Int32 FLAGS_CHANGED = 1<<2;
        const Int32 FORMAT_CHANGED = 1<<3;
        const Int32 ANIMATION_CHANGED = 1<<4;
        const Int32 DIM_AMOUNT_CHANGED = 1<<5;
        const Int32 TITLE_CHANGED = 1<<6;
        const Int32 ALPHA_CHANGED = 1<<7;
        const Int32 MEMORY_TYPE_CHANGED = 1<<8;
        const Int32 SOFT_INPUT_MODE_CHANGED = 1<<9;
        const Int32 SCREEN_ORIENTATION_CHANGED = 1<<10;
        const Int32 SCREEN_BRIGHTNESS_CHANGED = 1<<11;
        const Int32 ROTATION_ANIMATION_CHANGED = 1<<12;
        /** {@hide} */
        const Int32 BUTTON_BRIGHTNESS_CHANGED = 1<<13;
        /** {@hide} */
        const Int32 SYSTEM_UI_VISIBILITY_CHANGED = 1<<14;
        /** {@hide} */
        const Int32 SYSTEM_UI_LISTENER_CHANGED = 1<<15;
        /** {@hide} */
        const Int32 INPUT_FEATURES_CHANGED = 1<<16;
        /** {@hide} */
        const Int32 PRIVATE_FLAGS_CHANGED = 1<<17;
        /** {@hide} */
        const Int32 USER_ACTIVITY_TIMEOUT_CHANGED = 1<<18;
        /** {@hide} */
        const Int32 TRANSLUCENT_FLAGS_CHANGED = 1<<19;
        /** {@hide} */
        const Int32 SURFACE_INSETS_CHANGED = 1<<20;
        /** {@hide} */
        const Int32 PREFERRED_REFRESH_RATE_CHANGED = 1 << 21;
        /** {@hide} */
        const Int32 BLUR_MASK_ALPHA_THRESHOLD_CHANGED = 1 << 30;
        /** {@hide} */
        const Int32 EVERYTHING_CHANGED = 0xffffffff;


        SetTitle(
            [in] ICharSequence* title);

        GetTitle(
            [out] ICharSequence** title);

        CopyFrom(
            [in] IWindowManagerLayoutParams* source,
            [out] Int32* changes);

        Scale(
            [in] Float scale);

        /**
         * Backup the layout parameters used in compatibility mode.
         * @see LayoutParams#restore()
         */
        Backup();

        /**
         * Restore the layout params' coordinates, size and gravity
         * @see LayoutParams#backup()
         */
        Restore();

        GetX(
            [out] Int32* x);

        SetX(
            [in] Int32 x);

        GetY(
            [out] Int32* y);

        SetY(
            [in] Int32 y);

        GetType(
            [out] Int32* type);

        SetType(
            [in] Int32 type);

        GetMemoryType(
            [out] Int32* type);

        SetMemoryType(
            [in] Int32 type);

        GetFlags(
            [out] Int32* flags);

        SetFlags(
            [in] Int32 flags);

        GetPrivateFlags(
            [out] Int32* privateFlags);

        SetPrivateFlags(
            [in] Int32 privateFlags);

        SetSoftInputMode(
            [in] Int32 mode);

        GetSoftInputMode(
            [out] Int32* mode);

        GetGravity(
            [out] Int32* gravity);

        SetGravity(
            [in] Int32 gravity);

        GetHorizontalMargin(
            [out] Float* horizontalMargin);

        SetHorizontalMargin(
            [in] Float horizontalMargin);

        GetVerticalMargin(
            [out] Float* verticalMargin);

        SetVerticalMargin(
            [in] Float verticalMargin);

        GetSurfaceInsets(
            [out] IRect** surfaceInsets);

        SetSurfaceInsets(
            [in] IRect* surfaceInsets);

        GetFormat(
            [out] Int32* format);

        SetFormat(
            [in] Int32 format);

        GetWindowAnimations(
            [out] Int32* animations);

        SetWindowAnimations(
            [in] Int32 animations);

        GetAlpha(
            [out] Float* alpha);

        SetAlpha(
            [in] Float alpha);

        GetDimAmount(
            [out] Float* dimAmount);

        SetDimAmount(
            [in] Float dimAmount);

        GetScreenBrightness(
            [out] Float* brightness);

        SetScreenBrightness(
            [in] Float brightness);

        GetButtonBrightness(
            [out] Float* brightness);

        SetButtonBrightness(
            [in] Float brightness);

        GetToken(
            [out] IBinder** token);

        SetToken(
            [in] IBinder* token);

        GetPackageName(
            [out] String* packageName);

        SetPackageName(
            [in] String packageName);

        GetScreenOrientation(
            [out] Int32* orientation);

        SetScreenOrientation(
            [in] Int32 orientation);

        GetPreferredRefreshRate(
            [out] Float* rate);

        SetPreferredRefreshRate(
            [in] Float rate);

        GetSystemUiVisibility(
            [out] Int32* systemUiVisibility);

        SetSystemUiVisibility(
            [in] Int32 systemUiVisibility);

        GetSubtreeSystemUiVisibility(
            [out] Int32* subtreeSystemUiVisibility);

        SetSubtreeSystemUiVisibility(
            [in] Int32 subtreeSystemUiVisibility);

        GetHasSystemUiListeners(
            [out] Boolean* hasSystemUiListeners);

        SetHasSystemUiListeners(
            [in] Boolean hasSystemUiListeners);

        GetInputFeatures(
            [out] Int32* inputFeatures);

        SetInputFeatures(
            [in] Int32 inputFeatures);

        GetUserActivityTimeout(
            [out] Int32* userActivityTimeout);

        SetUserActivityTimeout(
            [in] Int32 userActivityTimeout);

        GetBlurMaskAlphaThreshold(
            [out] Float* blurMaskAlphaThreshold);

        SetBlurMaskAlphaThreshold(
            [in] Float blurMaskAlphaThreshold);

        GetRotationAnimation(
            [out] Int32* rotationAnimation);

        SetRotationAnimation(
            [in] Int32 rotationAnimation);
    }

    interface IWindowManagerLayoutParamsHelper {
        MayUseInputMethod(
            [in] Int32 flags,
            [out] Boolean* mayUse);
    }

    /**
     * @Involve
     * interface IViewManager
     */
    [local]
    interface IWindowManager {
        /**
         * Returns the {@link Display} upon which this {@link WindowManager} instance
         * will create new windows.
         * <p>
         * Despite the name of this method, the display that is returned is not
         * necessarily the primary display of the system (see {@link Display#DEFAULT_DISPLAY}).
         * The returned display could instead be a secondary display that this
         * window manager instance is managing.  Think of it as the display that
         * this {@link WindowManager} instance uses by default.
         * </p><p>
         * To create windows on a different display, you need to obtain a
         * {@link WindowManager} for that {@link Display}.  (See the {@link WindowManager}
         * class documentation for more information.)
         * </p>
         *
         * @return The display that this window manager is managing.
         */
        GetDefaultDisplay(
            [out] IDisplay** display);

        /**
         * Special variation of {@link #removeView} that immediately invokes
         * the given view hierarchy's {@link View#onDetachedFromWindow()
         * View.onDetachedFromWindow()} methods before returning.  This is not
         * for normal applications; using it correctly requires great care.
         *
         * @param view The view to be removed.
         */
        RemoveViewImmediate(
            [in] IView* view);
    }

    } // namespace View
    } // namepsace Droid
    } // namespace Elastos
}
