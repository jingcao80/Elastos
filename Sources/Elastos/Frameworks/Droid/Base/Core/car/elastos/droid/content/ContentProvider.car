
module
{
    using interface Elastos.IO.IFileDescriptor;
    using interface Elastos.IO.IPrintWriter;
    using interface Elastos.Utility.IArrayList;

    interface Elastos.Droid.Content.IContentProviderResult;
    interface Elastos.Droid.Content.IContentProviderPipeDataWriter;
    interface Elastos.Droid.Content.IContentValues;
    interface Elastos.Droid.Content.IContext;
    interface Elastos.Droid.Content.IIContentProvider;
    interface Elastos.Droid.Content.Pm.IPathPermission;
    interface Elastos.Droid.Content.Pm.IProviderInfo;
    interface Elastos.Droid.Content.Res.IAssetFileDescriptor;
    interface Elastos.Droid.Content.Res.IConfiguration;
    interface Elastos.Droid.Database.ICursor;
    interface Elastos.Droid.Net.IUri;
    interface Elastos.Droid.Os.IBinder;
    interface Elastos.Droid.Os.IBundle;
    interface Elastos.Droid.Os.ICancellationSignal;
    interface Elastos.Droid.Os.IParcelFileDescriptor;

    namespace Elastos {
    namespace Droid {
    namespace Content {

    /**
     * @Involve
     * interface Elastos.Droid.Content.IComponentCallbacks2
     */
    [deprecated]
    interface IContentProvider {
        /**
         * Retrieves the Context this provider is running in.  Only available once
         * #onCreate has been called -- this will return null in the
         * constructor.
         *
         * @sa #onCreate
         */
        GetContext(
            [out] IContext** context);

        /**
         * Return the package name of the caller that initiated the request being
         * processed on the current thread. The returned package will have been
         * verified to belong to the calling UID. Returns {@code null} if not
         * currently processing a request.
         * <p>
         * This will always return {@code null} when processing
         * {@link #getType(Uri)} or {@link #getStreamTypes(Uri, String)} requests.
         *
         * @see Binder#getCallingUid()
         * @see Context#grantUriPermission(String, Uri, int)
         * @throws SecurityException if the calling package doesn't belong to the
         *             calling UID.
         */
        GetCallingPackage(
            [out] String* permissionName);

        /**
         * Return the name of the permission required for read-only access to
         * this content provider.  This method can be called from multiple
         * threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
         * and Threads</a>.
         */
        GetReadPermission(
            [out] String* permissionName);

        /**
         * Return the name of the permission required for read/write access to
         * this content provider.  This method can be called from multiple
         * threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
         * and Threads</a>.
         */
        GetWritePermission(
            [out] String* permissionName);

        /**
         * Return the path-based permissions required for read and/or write access to
         * this content provider.  This method can be called from multiple
         * threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
         * and Threads</a>.
         */
        GetPathPermissions(
            [out, callee] ArrayOf<IPathPermission*>* pathPermissions);

        /**
         * Implement this to initialize your content provider on startup.
         * This method is called for all registered content providers on the
         * application main thread at application launch time.  It must not perform
         * lengthy operations, or application startup will be delayed.
         *
         * <p>You should defer nontrivial initialization (such as opening,
         * upgrading, and scanning databases) until the content provider is used
         * (via #query, #insert, etc).  Deferred initialization
         * keeps application startup fast, avoids unnecessary work if the provider
         * turns out not to be needed, and stops database errors (such as a full
         * disk) from halting application launch.
         *
         * @sa #query
         * @sa #insert
         *
         * <p>If you use SQLite, android.database.sqlite.SQLiteOpenHelper
         * is a helpful utility class that makes it easy to manage databases,
         * and will automatically defer opening until first use.  If you do use
         * SQLiteOpenHelper, make sure to avoid calling
         * android.database.sqlite.SQLiteOpenHelper#getReadableDatabase or
         * android.database.sqlite.SQLiteOpenHelper#getWritableDatabase
         * from this method.  (Instead, override
         * android.database.sqlite.SQLiteOpenHelper#onOpen to initialize the
         * database when it is first opened.)
         *
         * @sa android.database.sqlite.SQLiteOpenHelper
         * @sa android.database.sqlite.SQLiteOpenHelper#getReadableDatabase
         * @sa android.database.sqlite.SQLiteOpenHelper#getWritableDatabase
         * @sa android.database.sqlite.SQLiteOpenHelper#onOpen
         *
         * @return true if the provider was successfully loaded, false otherwise
         */
        OnCreate(
            [out] Boolean* succeeded);

        /**
         * {@inheritDoc}
         * This method is always called on the application main thread, and must
         * not perform lengthy operations.
         *
         * <p>The default content provider implementation does nothing.
         * Override this method to take appropriate action.
         * (Content providers do not usually care about things like screen
         * orientation, but may want to know about locale changes.)
         */
        OnConfigurationChanged(
            [in] IConfiguration* newConfig);

        /**
         * {@inheritDoc}
         * This method is always called on the application main thread, and must
         * not perform lengthy operations.
         *
         * <p>The default content provider implementation does nothing.
         * Subclasses may override this method to take appropriate action.
         */
        OnLowMemory();

        OnTrimMemory(
            [in] Int32 level);

        /**
         * Implement this to handle query requests from clients.
         * This method can be called from multiple threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
         * and Threads</a>.
         * <p>
         * Example client call:<p>
         * <pre>// Request a specific record.
         * Cursor managedCursor = managedQuery(
                    ContentUris.withAppendedId(Contacts.People.CONTENT_URI, 2),
                    projection,    // Which columns to return.
                    null,          // WHERE clause.
                    null,          // WHERE clause value substitution
                    People.NAME + " ASC");   // Sort order.</pre>
         * Example implementation:<p>
         * <pre>// SQLiteQueryBuilder is a helper class that creates the
            // proper SQL syntax for us.
            SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();

            // Set the table we're querying.
            qBuilder.setTables(DATABASE_TABLE_NAME);

            // If the query ends in a specific record number, we're
            // being asked for a specific record, so set the
            // WHERE clause in our query.
            if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){
                qBuilder.appendWhere("_id=" + uri.getPathLeafId());
            }

            // Make the query.
            Cursor c = qBuilder.query(mDb,
                    projection,
                    selection,
                    selectionArgs,
                    groupBy,
                    having,
                    sortOrder);
            c.setNotificationUri(getContext().getContentResolver(), uri);
            return c;</pre>
         *
         * @param uri The URI to query. This will be the full URI sent by the client;
         *      if the client is requesting a specific record, the URI will end in a record number
         *      that the implementation should parse and add to a WHERE or HAVING clause, specifying
         *      that _id value.
         * @param projection The list of columns to put into the cursor. If
         *      null all columns are included.
         * @param selection A selection criteria to apply when filtering rows.
         *      If null then all rows are included.
         * @param selectionArgs You may include ?s in selection, which will be replaced by
         *      the values from selectionArgs, in order that they appear in the selection.
         *      The values will be bound as Strings.
         * @param sortOrder How the rows in the cursor should be sorted.
         *      If null then the provider is free to define the sort order.
         * @return a Cursor or null.
         */
        Query(
            [in] IUri* uri,
            [in] ArrayOf<String>* projection,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [in] String sortOrder,
            [out] ICursor** cursor);

        /**
         * Implement this to handle query requests from clients with support for cancellation.
         * This method can be called from multiple threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
         * and Threads</a>.
         * <p>
         * Example client call:<p>
         * <pre>// Request a specific record.
         * Cursor managedCursor = managedQuery(
                    ContentUris.withAppendedId(Contacts.People.CONTENT_URI, 2),
                    projection,    // Which columns to return.
                    null,          // WHERE clause.
                    null,          // WHERE clause value substitution
                    People.NAME + " ASC");   // Sort order.</pre>
         * Example implementation:<p>
         * <pre>// SQLiteQueryBuilder is a helper class that creates the
            // proper SQL syntax for us.
            SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();

            // Set the table we're querying.
            qBuilder.setTables(DATABASE_TABLE_NAME);

            // If the query ends in a specific record number, we're
            // being asked for a specific record, so set the
            // WHERE clause in our query.
            if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){
                qBuilder.appendWhere("_id=" + uri.getPathLeafId());
            }

            // Make the query.
            Cursor c = qBuilder.query(mDb,
                    projection,
                    selection,
                    selectionArgs,
                    groupBy,
                    having,
                    sortOrder);
            c.setNotificationUri(getContext().getContentResolver(), uri);
            return c;</pre>
         * <p>
         * If you implement this method then you must also implement the version of
         * #query(Uri, String[], String, String[], String) that does not take a cancellation
         * signal to ensure correct operation on older versions of the Android Framework in
         * which the cancellation signal overload was not available.
         *
         * @sa #query(Uri, String[], String, String[], String)
         *
         * @param uri The URI to query. This will be the full URI sent by the client;
         *      if the client is requesting a specific record, the URI will end in a record number
         *      that the implementation should parse and add to a WHERE or HAVING clause, specifying
         *      that _id value.
         * @param projection The list of columns to put into the cursor. If
         *      null all columns are included.
         * @param selection A selection criteria to apply when filtering rows.
         *      If null then all rows are included.
         * @param selectionArgs You may include ?s in selection, which will be replaced by
         *      the values from selectionArgs, in order that they appear in the selection.
         *      The values will be bound as Strings.
         * @param sortOrder How the rows in the cursor should be sorted.
         *      If null then the provider is free to define the sort order.
         * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
         * If the operation is canceled, then OperationCanceledException will be thrown
         * when the query is executed.
         *
         * @sa OperationCanceledException
         * @return a Cursor or null.
         */
        Query(
            [in] IUri* uri,
            [in] ArrayOf<String>* projection,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [in] String sortOrder,
            [in] ICancellationSignal* cancellationSignal,
            [out] ICursor** cursor);

        /**
         * Implement this to handle requests for the MIME type of the data at the
         * given URI.  The returned MIME type should start with
         * <code>vnd.android.cursor.item</code> for a single record,
         * or <code>vnd.android.cursor.dir/</code> for multiple items.
         * This method can be called from multiple threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
         * and Threads</a>.
         *
         * <p>Note that there are no permissions needed for an application to
         * access this information; if your content provider requires read and/or
         * write permissions, or is not exported, all applications can still call
         * this method regardless of their access permissions.  This allows them
         * to retrieve the MIME type for a URI when dispatching intents.
         *
         * @param uri the URI to query.
         * @return a MIME type string, or null if there is no type.
         */
        GetType(
            [in] IUri* uri,
            [out] String* type);

        /**
         * Implement this to support canonicalization of URIs that refer to your
         * content provider.  A canonical URI is one that can be transported across
         * devices, backup/restore, and other contexts, and still be able to refer
         * to the same data item.  Typically this is implemented by adding query
         * params to the URI allowing the content provider to verify that an incoming
         * canonical URI references the same data as it was originally intended for and,
         * if it doesn't, to find that data (if it exists) in the current environment.
         *
         * <p>For example, if the content provider holds people and a normal URI in it
         * is created with a row index into that people database, the cananical representation
         * may have an additional query param at the end which specifies the name of the
         * person it is intended for.  Later calls into the provider with that URI will look
         * up the row of that URI's base index and, if it doesn't match or its entry's
         * name doesn't match the name in the query param, perform a query on its database
         * to find the correct row to operate on.</p>
         *
         * <p>If you implement support for canonical URIs, <b>all</b> incoming calls with
         * URIs (including this one) must perform this verification and recovery of any
         * canonical URIs they receive.  In addition, you must also implement
         * {@link #uncanonicalize} to strip the canonicalization of any of these URIs.</p>
         *
         * <p>The default implementation of this method returns null, indicating that
         * canonical URIs are not supported.</p>
         *
         * @param url The Uri to canonicalize.
         *
         * @return Return the canonical representation of <var>url</var>, or null if
         * canonicalization of that Uri is not supported.
         */
        Canonicalize(
            [in] IUri* uri,
            [out] IUri** result);

        /**
         * Remove canonicalization from canonical URIs previously returned by
         * {@link #canonicalize}.  For example, if your implementation is to add
         * a query param to canonicalize a URI, this method can simply trip any
         * query params on the URI.  The default implementation always returns the
         * same <var>url</var> that was passed in.
         *
         * @param url The Uri to remove any canonicalization from.
         *
         * @return Return the non-canonical representation of <var>url</var>, return
         * the <var>url</var> as-is if there is nothing to do, or return null if
         * the data identified by the canonical representation can not be found in
         * the current environment.
         */
        Uncanonicalize(
            [in] IUri* uri,
            [out] IUri** result);

        /**
         * Implement this to handle requests to insert a new row.
         * As a courtesy, call ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()
         * after inserting.
         * This method can be called from multiple threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
         * and Threads</a>.
         *
         * @sa ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()
         * @param uri The content:// URI of the insertion request.
         * @param values A set of column_name/value pairs to add to the database.
         * @return The URI for the newly inserted item.
         */
        Insert(
            [in] IUri* uri,
            [in] IContentValues* values,
            [out] IUri** insertedUri);

        /**
         * Override this to handle requests to insert a set of new rows, or the
         * default implementation will iterate over the values and call
         * #insert on each of them.
         * As a courtesy, call ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()
         * after inserting.
         * This method can be called from multiple threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
         * and Threads</a>.
         *
         * @sa #insert
         * @sa ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()
         *
         * @param uri The content:// URI of the insertion request.
         * @param values An array of sets of column_name/value pairs to add to the database.
         * @return The number of values that were inserted.
         */
        BulkInsert(
            [in] IUri* uri,
            [in] ArrayOf<IContentValues*>* values,
            [out] Int32* number);

        /**
         * Implement this to handle requests to delete one or more rows.
         * The implementation should apply the selection clause when performing
         * deletion, allowing the operation to affect multiple rows in a directory.
         * As a courtesy, call ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyDelete()
         * after deleting.
         * This method can be called from multiple threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
         * and Threads</a>.
         *
         * @sa ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyDelete()
         *
         * <p>The implementation is responsible for parsing out a row ID at the end
         * of the URI, if a specific row is being deleted. That is, the client would
         * pass in <code>content://contacts/people/22</code> and the implementation is
         * responsible for parsing the record number (22) when creating a SQL statement.
         *
         * @param uri The full URI to query, including a row ID (if a specific record is requested).
         * @param selection An optional restriction to apply to rows when deleting.
         * @return The number of rows affected.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value |
         * :--|
         * SQLException
         */
        Delete(
            [in] IUri* uri,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [out] Int32* rowsAffected);

        /**
         * Implement this to handle requests to update one or more rows.
         * The implementation should update all rows matching the selection
         * to set the columns according to the provided values map.
         * As a courtesy, call ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()
         * after updating.
         * This method can be called from multiple threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
         * and Threads</a>.
         *
         * @sa ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()
         *
         * @param uri The URI to query. This can potentially have a record ID if this
         * is an update request for a specific record.
         * @param values A Bundle mapping from column names to new column values (NULL is a
         *               valid value).
         * @param selection An optional filter to match rows to update.
         * @return the number of rows affected.
         */
        Update(
            [in] IUri* uri,
            [in] IContentValues* values,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [out] Int32* rowsAffected);

        /**
         * Override this to handle requests to open a file blob.
         * The default implementation always throws FileNotFoundException.
         * This method can be called from multiple threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
         * and Threads</a>.
         *
         * @sa FileNotFoundException
         *
         * <p>This method returns a ParcelFileDescriptor, which is returned directly
         * to the caller.  This way large data (such as images and documents) can be
         * returned without copying the content.
         *
         * <p>The returned ParcelFileDescriptor is owned by the caller, so it is
         * their responsibility to close it when done.  That is, the implementation
         * of this method should create a new ParcelFileDescriptor for each call.
         *
         * @param uri The URI whose file is to be opened.
         * @param mode Access mode for the file.  May be "r" for read-only access,
         * "rw" for read and write access, or "rwt" for read and write access
         * that truncates any existing file.
         *
         * @return Returns a new ParcelFileDescriptor which you can use to access
         * the file.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * FileNotFoundException Throws FileNotFoundException | if there is no file associated with the given URI or the mode is invalid.
         * SecurityException Throws SecurityException | if the caller does not have permission to access the file.
         *
         * @see #openAssetFile(Uri, String)
         * @see #openFileHelper(Uri, String)
         */
        OpenFile(
            [in] IUri* uri,
            [in] String mode,
            [out] IParcelFileDescriptor** fileDescriptor);

        /**
         * Override this to handle requests to open a file blob.
         * The default implementation always throws {@link FileNotFoundException}.
         * This method can be called from multiple threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
         * and Threads</a>.
         *
         * <p>This method returns a ParcelFileDescriptor, which is returned directly
         * to the caller.  This way large data (such as images and documents) can be
         * returned without copying the content.
         *
         * <p>The returned ParcelFileDescriptor is owned by the caller, so it is
         * their responsibility to close it when done.  That is, the implementation
         * of this method should create a new ParcelFileDescriptor for each call.
         * <p>
         * If opened with the exclusive "r" or "w" modes, the returned
         * ParcelFileDescriptor can be a pipe or socket pair to enable streaming
         * of data. Opening with the "rw" or "rwt" modes implies a file on disk that
         * supports seeking.
         * <p>
         * If you need to detect when the returned ParcelFileDescriptor has been
         * closed, or if the remote process has crashed or encountered some other
         * error, you can use {@link ParcelFileDescriptor#open(File, int,
         * android.os.Handler, android.os.ParcelFileDescriptor.OnCloseListener)},
         * {@link ParcelFileDescriptor#createReliablePipe()}, or
         * {@link ParcelFileDescriptor#createReliableSocketPair()}.
         *
         * <p class="note">For use in Intents, you will want to implement {@link #getType}
         * to return the appropriate MIME type for the data returned here with
         * the same URI.  This will allow intent resolution to automatically determine the data MIME
         * type and select the appropriate matching targets as part of its operation.</p>
         *
         * <p class="note">For better interoperability with other applications, it is recommended
         * that for any URIs that can be opened, you also support queries on them
         * containing at least the columns specified by {@link android.provider.OpenableColumns}.
         * You may also want to support other common columns if you have additional meta-data
         * to supply, such as {@link android.provider.MediaStore.MediaColumns#DATE_ADDED}
         * in {@link android.provider.MediaStore.MediaColumns}.</p>
         *
         * @param uri The URI whose file is to be opened.
         * @param mode Access mode for the file. May be "r" for read-only access,
         *            "w" for write-only access, "rw" for read and write access, or
         *            "rwt" for read and write access that truncates any existing
         *            file.
         * @param signal A signal to cancel the operation in progress, or
         *            {@code null} if none. For example, if you are downloading a
         *            file from the network to service a "rw" mode request, you
         *            should periodically call
         *            {@link CancellationSignal#throwIfCanceled()} to check whether
         *            the client has canceled the request and abort the download.
         *
         * @return Returns a new ParcelFileDescriptor which you can use to access
         * the file.
         *
         * @throws FileNotFoundException Throws FileNotFoundException if there is
         * no file associated with the given URI or the mode is invalid.
         * @throws SecurityException Throws SecurityException if the caller does
         * not have permission to access the file.
         *
         * @see #openAssetFile(Uri, String)
         * @see #openFileHelper(Uri, String)
         * @see #getType(android.net.Uri)
         * @see ParcelFileDescriptor#parseMode(String)
         */
        OpenFile(
            [in] IUri* uri,
            [in] String mode,
            [in] ICancellationSignal* signal,
            [out] IParcelFileDescriptor** fileDescriptor);

        /**
         * This is like #openFile, but can be implemented by providers
         * that need to be able to return sub-sections of files, often assets
         * inside of their .apk.
         * This method can be called from multiple threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
         * and Threads</a>.
         *
         * @sa #openFile
         *
         * <p>If you implement this, your clients must be able to deal with such
         * file slices, either directly with
         * ContentResolver#openAssetFileDescriptor, or by using the higher-level
         * ContentResolver#openInputStream ContentResolver.openInputStream
         * or ContentResolver#openOutputStream ContentResolver.openOutputStream
         * methods.
         *
         * @sa ContentResolver#openAssetFileDescriptor
         * @sa ContentResolver#openInputStream ContentResolver.openInputStream
         * @sa ContentResolver#openOutputStream ContentResolver.openOutputStream
         *
         * <p class="note">If you are implementing this to return a full file, you
         * should create the AssetFileDescriptor with
         * AssetFileDescriptor#UNKNOWN_LENGTH to be compatible with
         * applications that can not handle sub-sections of files.</p>
         *
         * @sa AssetFileDescriptor#UNKNOWN_LENGTH
         *
         * @param uri The URI whose file is to be opened.
         * @param mode Access mode for the file.  May be "r" for read-only access,
         * "w" for write-only access (erasing whatever data is currently in
         * the file), "wa" for write-only access to append to any existing data,
         * "rw" for read and write access on any existing data, and "rwt" for read
         * and write access that truncates any existing file.
         *
         * @return Returns a new AssetFileDescriptor which you can use to access
         * the file.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * FileNotFoundException Throws FileNotFoundException | if there is no file associated with the given URI or the mode is invalid.
         * SecurityException Throws SecurityException | if the caller does not have permission to access the file.
         *
         * @see #openFile(Uri, String)
         * @see #openFileHelper(Uri, String)
         */
        OpenAssetFile(
            [in] IUri* uri,
            [in] String mode,
            [out] IAssetFileDescriptor** fileDescriptor);

        /**
         * This is like {@link #openFile}, but can be implemented by providers
         * that need to be able to return sub-sections of files, often assets
         * inside of their .apk.
         * This method can be called from multiple threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
         * and Threads</a>.
         *
         * <p>If you implement this, your clients must be able to deal with such
         * file slices, either directly with
         * {@link ContentResolver#openAssetFileDescriptor}, or by using the higher-level
         * {@link ContentResolver#openInputStream ContentResolver.openInputStream}
         * or {@link ContentResolver#openOutputStream ContentResolver.openOutputStream}
         * methods.
         * <p>
         * The returned AssetFileDescriptor can be a pipe or socket pair to enable
         * streaming of data.
         *
         * <p class="note">If you are implementing this to return a full file, you
         * should create the AssetFileDescriptor with
         * {@link AssetFileDescriptor#UNKNOWN_LENGTH} to be compatible with
         * applications that cannot handle sub-sections of files.</p>
         *
         * <p class="note">For use in Intents, you will want to implement {@link #getType}
         * to return the appropriate MIME type for the data returned here with
         * the same URI.  This will allow intent resolution to automatically determine the data MIME
         * type and select the appropriate matching targets as part of its operation.</p>
         *
         * <p class="note">For better interoperability with other applications, it is recommended
         * that for any URIs that can be opened, you also support queries on them
         * containing at least the columns specified by {@link android.provider.OpenableColumns}.</p>
         *
         * @param uri The URI whose file is to be opened.
         * @param mode Access mode for the file.  May be "r" for read-only access,
         * "w" for write-only access (erasing whatever data is currently in
         * the file), "wa" for write-only access to append to any existing data,
         * "rw" for read and write access on any existing data, and "rwt" for read
         * and write access that truncates any existing file.
         * @param signal A signal to cancel the operation in progress, or
         *            {@code null} if none. For example, if you are downloading a
         *            file from the network to service a "rw" mode request, you
         *            should periodically call
         *            {@link CancellationSignal#throwIfCanceled()} to check whether
         *            the client has canceled the request and abort the download.
         *
         * @return Returns a new AssetFileDescriptor which you can use to access
         * the file.
         *
         * @throws FileNotFoundException Throws FileNotFoundException if there is
         * no file associated with the given URI or the mode is invalid.
         * @throws SecurityException Throws SecurityException if the caller does
         * not have permission to access the file.
         *
         * @see #openFile(Uri, String)
         * @see #openFileHelper(Uri, String)
         * @see #getType(android.net.Uri)
         */
        OpenAssetFile(
            [in] IUri* uri,
            [in] String mode,
            [in] ICancellationSignal* signal,
            [out] IAssetFileDescriptor** fileDescriptor);

        /**
         * Called by a client to determine the types of data streams that this
         * content provider supports for the given URI.  The default implementation
         * returns null, meaning no types.  If your content provider stores data
         * of a particular type, return that MIME type if it matches the given
         * mimeTypeFilter.  If it can perform type conversions, return an array
         * of all supported MIME types that match mimeTypeFilter.
         *
         * @param uri The data in the content provider being queried.
         * @param mimeTypeFilter The type of data the client desires.  May be
         * a pattern, such as *\/* to retrieve all possible data types.
         * @return Returns null if there are no possible data streams for the
         * given mimeTypeFilter.  Otherwise returns an array of all available
         * concrete MIME types.
         *
         * @see #getType(Uri)
         * @see #openTypedAssetFile(Uri, String, Bundle)
         * @see ClipDescription#compareMimeTypes(String, String)
         */
        GetStreamTypes(
            [in] IUri* uri,
            [in] String mimeTypeFilter,
            [out, callee] ArrayOf<String>* streamTypes);

        /**
         * Called by a client to open a read-only stream containing data of a
         * particular MIME type.  This is like #openAssetFile(Uri, String),
         * except the file can only be read-only and the content provider may
         * perform data conversions to generate data of the desired type.
         *
         * @sa #openAssetFile(Uri, String)
         *
         * <p>The default implementation compares the given mimeType against the
         * result of #getType(Uri) and, if the match, simple calls
         * #openAssetFile(Uri, String).
         *
         * @sa #getType(Uri)
         * @sa #openAssetFile(Uri, String)
         *
         * <p>See ClipData for examples of the use and implementation
         * of this method.
         *
         * @sa ClipData
         *
         * @param uri The data in the content provider being queried.
         * @param mimeTypeFilter The type of data the client desires.  May be
         * a pattern, such as *\/*, if the caller does not have specific type
         * requirements; in this case the content provider will pick its best
         * type matching the pattern.
         * @param opts Additional options from the client.  The definitions of
         * these are specific to the content provider being called.
         *
         * @return Returns a new AssetFileDescriptor from which the client can
         * read data of the desired type.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * FileNotFoundException Throws FileNotFoundException | if there is no file associated with the given URI or the mode is invalid.
         * SecurityException Throws SecurityException | if the caller does not have permission to access the data.
         * IllegalArgumentException Throws IllegalArgumentException | if the content provider does not support the requested MIME type.
         *
         * @see #getStreamTypes(Uri, String)
         * @see #openAssetFile(Uri, String)
         * @see ClipDescription#compareMimeTypes(String, String)
         */
        OpenTypedAssetFile(
            [in] IUri* uri,
            [in] String mimeTypeFilter,
            [in] IBundle* opts,
            [out] IAssetFileDescriptor** fileDescriptor);

        /**
         * Called by a client to open a read-only stream containing data of a
         * particular MIME type.  This is like {@link #openAssetFile(Uri, String)},
         * except the file can only be read-only and the content provider may
         * perform data conversions to generate data of the desired type.
         *
         * <p>The default implementation compares the given mimeType against the
         * result of {@link #getType(Uri)} and, if they match, simply calls
         * {@link #openAssetFile(Uri, String)}.
         *
         * <p>See {@link ClipData} for examples of the use and implementation
         * of this method.
         * <p>
         * The returned AssetFileDescriptor can be a pipe or socket pair to enable
         * streaming of data.
         *
         * <p class="note">For better interoperability with other applications, it is recommended
         * that for any URIs that can be opened, you also support queries on them
         * containing at least the columns specified by {@link android.provider.OpenableColumns}.
         * You may also want to support other common columns if you have additional meta-data
         * to supply, such as {@link android.provider.MediaStore.MediaColumns#DATE_ADDED}
         * in {@link android.provider.MediaStore.MediaColumns}.</p>
         *
         * @param uri The data in the content provider being queried.
         * @param mimeTypeFilter The type of data the client desires.  May be
         * a pattern, such as *&#47;*, if the caller does not have specific type
         * requirements; in this case the content provider will pick its best
         * type matching the pattern.
         * @param opts Additional options from the client.  The definitions of
         * these are specific to the content provider being called.
         * @param signal A signal to cancel the operation in progress, or
         *            {@code null} if none. For example, if you are downloading a
         *            file from the network to service a "rw" mode request, you
         *            should periodically call
         *            {@link CancellationSignal#throwIfCanceled()} to check whether
         *            the client has canceled the request and abort the download.
         *
         * @return Returns a new AssetFileDescriptor from which the client can
         * read data of the desired type.
         *
         * @throws FileNotFoundException Throws FileNotFoundException if there is
         * no file associated with the given URI or the mode is invalid.
         * @throws SecurityException Throws SecurityException if the caller does
         * not have permission to access the data.
         * @throws IllegalArgumentException Throws IllegalArgumentException if the
         * content provider does not support the requested MIME type.
         *
         * @see #getStreamTypes(Uri, String)
         * @see #openAssetFile(Uri, String)
         * @see ClipDescription#compareMimeTypes(String, String)
         */
        OpenTypedAssetFile(
            [in] IUri* uri,
            [in] String mimeTypeFilter,
            [in] IBundle* opts,
            [in] ICancellationSignal* signal,
            [out] IAssetFileDescriptor** fileDescriptor);

        /**
         * A helper function for implementing #openTypedAssetFile, for
         * creating a data pipe and background thread allowing you to stream
         * generated data back to the client.  This function returns a new
         * ParcelFileDescriptor that should be returned to the caller (the caller
         * is responsible for closing it).
         *
         * @sa #openTypedAssetFile
         *
         * @param uri The URI whose data is to be written.
         * @param mimeType The desired type of data to be written.
         * @param opts Options supplied by caller.
         * @param args Your own custom arguments.
         * @param func Interface implementing the function that will actually
         * stream the data.
         * @return Returns a new ParcelFileDescriptor holding the read side of
         * the pipe.  This should be returned to the caller for reading; the caller
         * is responsible for closing it when done.
         */
        OpenPipeHelper(
            [in] IUri* uri,
            [in] String mimeType,
            [in] IBundle* opts,
            [in] IInterface* args,
            [in] IContentProviderPipeDataWriter* func,
            [out] IParcelFileDescriptor** fileDescriptor);

        /**
         * Returns the Binder object for this provider.
         *
         * @return the Binder object for this provider
         * @hide
         */
        GetIContentProvider(
            [out] IIContentProvider** contentProvider);

        /**
         * After being instantiated, this is called to tell the content provider
         * about itself.
         *
         * @param context The context this provider is running in
         * @param info Registered information about this content provider
         */
        AttachInfo(
            [in] IContext* ctx,
            [in] IProviderInfo* info);

        /**
         * Override this to handle requests to perform a batch of operations, or the
         * default implementation will iterate over the operations and call
         * ContentProviderOperation#apply on each of them.
         * If all calls to ContentProviderOperation#apply succeed
         * then a ContentProviderResult array with as many
         * elements as there were operations will be returned.  If any of the calls
         * fail, it is up to the implementation how many of the others take effect.
         * This method can be called from multiple threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
         * and Threads</a>.
         *
         * @sa ContentProviderOperation#apply} on each of them.
         * @sa ContentProviderOperation#apply} succeed
         * @sa ContentProviderResult
         *
         * @param operations the operations to apply
         * @return the results of the applications
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * OperationApplicationException thrown | if any operation fails.
         * @see ContentProviderOperation#apply
         */
        ApplyBatch(
            [in] IArrayList* operations,
            [out, callee] ArrayOf<IContentProviderResult*>* providerResults);

        /**
         * Call a provider-defined method.  This can be used to implement
         * interfaces that are cheaper and/or unnatural for a table-like
         * model.
         *
         * @param method method name to call.  Opaque to framework, but should not be null.
         * @param arg provider-defined String argument.  May be null.
         * @param extras provider-defined Bundle argument.  May be null.
         * @return provider-defined return value.  May be null.  Null is also
         *   the default for providers which don't implement any call methods.
         */
        Call(
            [in] String method,
            [in] String arg,
            [in] IBundle* extras,
            [out] IBundle** bundle);

        /**
         * Implement this to shut down the ContentProvider instance. You can then
         * invoke this method in unit tests.
         *
         * <p>
         * Android normally handles ContentProvider startup and shutdown
         * automatically. You do not need to start up or shut down a
         * ContentProvider. When you invoke a test method on a ContentProvider,
         * however, a ContentProvider instance is started and keeps running after
         * the test finishes, even if a succeeding test instantiates another
         * ContentProvider. A conflict develops because the two instances are
         * usually running against the same underlying data source (for example, an
         * sqlite database).
         * </p>
         * <p>
         * Implementing shutDown() avoids this conflict by providing a way to
         * terminate the ContentProvider. This method can also prevent memory leaks
         * from multiple instantiations of the ContentProvider, and it can ensure
         * unit test isolation by allowing you to completely clean up the test
         * fixture before moving on to the next test.
         * </p>
         */
        Shutdown();

        /**
         * Print the Provider's state into the given stream.  This gets invoked if
         * you run "adb shell dumpsys activity provider &lt;provider_component_name&gt;".
         *
         * @param prefix Desired prefix to prepend at each line of output.
         * @param fd The raw file descriptor that the dump is being sent to.
         * @param writer The PrintWriter to which you should dump your state.  This will be
         * closed for you after you return.
         * @param args additional arguments to the dump request.
         * @hide
         */
        Dump(
            [in] IFileDescriptor* fd,
            [in] IPrintWriter* writer,
            [in] ArrayOf<String>* args);

        /** {@hide} */
        EnforceWritePermissionInner(
            [in] IUri* uri);
    }

    /**
     * Interface to write a stream of data to a pipe.  Use with
     * ContentProvider#openPipeHelper.
     *
     * @sa ContentProvider#openPipeHelper
     */
    interface IContentProviderPipeDataWriter {
        /**
         * Called from a background thread to stream data out to a pipe.
         * Note that the pipe is blocking, so this thread can block on
         * writes for an arbitrary amount of time if the client is slow
         * at reading.
         *
         * @param output The pipe where data should be written.  This will be
         * closed for you upon returning from this function.
         * @param uri The URI whose data is to be written.
         * @param mimeType The desired type of data to be written.
         * @param opts Options supplied by caller.
         * @param args Your own custom arguments.
         */
        WriteDataToPipe(
            [in] IParcelFileDescriptor* output,
            [in] IUri* uri,
            [in] String mimeType,
            [in] IBundle* opts,
            [in] IInterface* args);
    }

    interface IContentProviderHelper {
        /**
         * Given an IContentProvider, try to coerce it back to the real
         * ContentProvider object if it is running in the local process.  This can
         * be used if you know you are running in the same process as a provider,
         * and want to get direct access to its implementation details.  Most
         * clients should not nor have a reason to use it.
         *
         * @param abstractInterface The ContentProvider interface that is to be
         *              coerced.
         * @return If the IContentProvider is non-null and local, returns its actual
         * ContentProvider instance.  Otherwise returns null.
         * @hide
         */
        CoerceToLocalContentProvider(
            [in] IIContentProvider* abstractInterface,
            [out] IContentProvider** localContentProvider);

        /**
         * Removes userId part from authority string. Expects format:
         * userId@some.authority
         * If there is no userId in the authority, it symply returns the argument
         * @hide
         */
        GetAuthorityWithoutUserId(
            [in] String auth,
            [out] String* result);

        /** @hide */
        GetUriWithoutUserId(
            [in] IUri* uri,
            [out] IUri** result);

        /** @hide */
        UriHasUserId(
            [in] IUri* uri,
            [out] Boolean* result);

        /** @hide */
        MaybeAddUserId(
            [in] IUri* uri,
            [in] Int32 userId,
            [out] IUri** result);

        GetUserIdFromAuthority(
            [in] String auth,
            [in] Int32 defaultUserId,
            [out] Int32* userId);

        GetUserIdFromUri(
            [in] IUri* uri,
            [in] Int32 defaultUserId,
            [out] Int32* userId);

        GetUserIdFromUri(
            [in] IUri* uri,
            [out] Int32* userId);
    }

    /**
     * @Involve
     * interface Elastos.Droid.Content.IIContentProvider
     * interface Elastos.Droid.Os.IBinder
     */
    interface IContentProviderTransport {
        GetContentProvider(
            [out] IContentProvider** provider);

        GetProviderName(
            [out] String* name);
    }

    interface IContentProviderProxy {
        AsBinder(
            [out] IBinder** binder);
    }

    } // namespace Content
    } // namespace Droid
    } // namespace Elastos
}
