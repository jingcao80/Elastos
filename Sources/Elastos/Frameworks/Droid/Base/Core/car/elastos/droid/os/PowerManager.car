module
{
    interface Elastos.Droid.Content.IIntent;

    namespace Elastos {
    namespace Droid {
    namespace Os {

    interface IPowerManagerWakeLock
    {
        /**
         * Sets whether this WakeLock is reference counted.
         * <p>
         * Wake locks are reference counted by default.  If a wake lock is
         * reference counted, then each call to {@link #acquire()} must be
         * balanced by an equal number of calls to {@link #release()}.  If a wake
         * lock is not reference counted, then one call to {@link #release()} is
         * sufficient to undo the effect of all previous calls to {@link #acquire()}.
         * </p>
         *
         * @param value True to make the wake lock reference counted, false to
         * make the wake lock non-reference counted.
         */
        SetReferenceCounted(
            [in] Boolean value);

        /**
         * Acquires the wake lock.
         * <p>
         * Ensures that the device is on at the level requested when
         * the wake lock was created.
         * </p>
         */
        AcquireLock();

        /**
         * Acquires the wake lock with a timeout.
         * <p>
         * Ensures that the device is on at the level requested when
         * the wake lock was created.  The lock will be released after the given timeout
         * expires.
         * </p>
         *
         * @param timeout The timeout after which to release the wake lock, in milliseconds.
         */
        AcquireLock(
            [in] Int64 timeout);

        /**
         * Releases the wake lock.
         * <p>
         * This method releases your claim to the CPU or screen being on.
         * The screen may turn off shortly after you release the wake lock, or it may
         * not if there are other wake locks still held.
         * </p>
         */
        ReleaseLock();

        /**
         * Releases the wake lock with flags to modify the release behavior.
         * <p>
         * This method releases your claim to the CPU or screen being on.
         * The screen may turn off shortly after you release the wake lock, or it may
         * not if there are other wake locks still held.
         * </p>
         *
         * @param flags Combination of flag values to modify the release behavior.
         * Currently only {@link #RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY} is supported.
         * Passing 0 is equivalent to calling {@link #release()}.
         */
        ReleaseLock(
            [in] Int32 flags);

        /**
         * Returns true if the wake lock has been acquired but not yet released.
         *
         * @return True if the wake lock is held.
         */
        IsHeld(
            [out] Boolean* isHeld);

        /**
         * Sets the work source associated with the wake lock.
         * <p>
         * The work source is used to determine on behalf of which application
         * the wake lock is being held.  This is useful in the case where a
         * service is performing work on behalf of an application so that the
         * cost of that work can be accounted to the application.
         * </p>
         *
         * @param ws The work source, or null if none.
         */
        SetWorkSource(
            [in] IWorkSource* ws);

        /** @hide */
        SetTag(
            [in] String tag);

        /** @hide */
        SetHistoryTag(
            [in] String tag);

        /** @hide */
        SetUnimportantForLogging(
            [in] Boolean tag);
    }

    interface IPowerManager
    {
        /* NOTE: Wake lock levels were previously defined as a bit field, except that only a few
         * combinations were actually supported so the bit field was removed.  This explains
         * why the numbering scheme is so odd.  If adding a new wake lock level, any unused
         * value can be used.
         */

        /**
         * Wake lock level: Ensures that the CPU is running; the screen and keyboard
         * backlight will be allowed to go off.
         * <p>
         * If the user presses the power button, then the screen will be turned off
         * but the CPU will be kept on until all partial wake locks have been released.
         * </p>
         */
        const Int32 PARTIAL_WAKE_LOCK = 0x00000001;

        /**
         * Wake lock level: Ensures that the screen is on (but may be dimmed);
         * the keyboard backlight will be allowed to go off.
         * <p>
         * If the user presses the power button, then the {@link #SCREEN_DIM_WAKE_LOCK} will be
         * implicitly released by the system, causing both the screen and the CPU to be turned off.
         * Contrast with {@link #PARTIAL_WAKE_LOCK}.
         * </p>
         *
         * @deprecated Most applications should use
         * {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead
         * of this type of wake lock, as it will be correctly managed by the platform
         * as the user moves between applications and doesn't require a special permission.
         */
        //@Deprecated
        const Int32 SCREEN_DIM_WAKE_LOCK = 0x00000006;

        /**
         * Wake lock level: Ensures that the screen is on at full brightness;
         * the keyboard backlight will be allowed to go off.
         * <p>
         * If the user presses the power button, then the {@link #SCREEN_BRIGHT_WAKE_LOCK} will be
         * implicitly released by the system, causing both the screen and the CPU to be turned off.
         * Contrast with {@link #PARTIAL_WAKE_LOCK}.
         * </p>
         *
         * @deprecated Most applications should use
         * {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead
         * of this type of wake lock, as it will be correctly managed by the platform
         * as the user moves between applications and doesn't require a special permission.
         */
        //@Deprecated
        const Int32 SCREEN_BRIGHT_WAKE_LOCK = 0x0000000a;

        /**
         * Wake lock level: Ensures that the screen and keyboard backlight are on at
         * full brightness.
         * <p>
         * If the user presses the power button, then the {@link #FULL_WAKE_LOCK} will be
         * implicitly released by the system, causing both the screen and the CPU to be turned off.
         * Contrast with {@link #PARTIAL_WAKE_LOCK}.
         * </p>
         *
         * @deprecated Most applications should use
         * {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead
         * of this type of wake lock, as it will be correctly managed by the platform
         * as the user moves between applications and doesn't require a special permission.
         */
        //@Deprecated
        const Int32 FULL_WAKE_LOCK = 0x0000001a;

        /**
         * Wake lock level: Turns the screen off when the proximity sensor activates.
         * <p>
         * If the proximity sensor detects that an object is nearby, the screen turns off
         * immediately.  Shortly after the object moves away, the screen turns on again.
         * </p><p>
         * A proximity wake lock does not prevent the device from falling asleep
         * unlike {@link #FULL_WAKE_LOCK}, {@link #SCREEN_BRIGHT_WAKE_LOCK} and
         * {@link #SCREEN_DIM_WAKE_LOCK}.  If there is no user activity and no other
         * wake locks are held, then the device will fall asleep (and lock) as usual.
         * However, the device will not fall asleep while the screen has been turned off
         * by the proximity sensor because it effectively counts as ongoing user activity.
         * </p><p>
         * Since not all devices have proximity sensors, use {@link #isWakeLockLevelSupported}
         * to determine whether this wake lock level is supported.
         * </p><p>
         * Cannot be used with {@link #ACQUIRE_CAUSES_WAKEUP}.
         * </p>
         */
        const Int32 PROXIMITY_SCREEN_OFF_WAKE_LOCK = 0x00000020;

        /**
         * Wake lock level: Put the screen in a low power state and allow the CPU to suspend
         * if no other wake locks are held.
         * <p>
         * This is used by the dream manager to implement doze mode.  It currently
         * has no effect unless the power manager is in the dozing state.
         * </p><p>
         * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
         * </p>
         *
         * {@hide}
         */
        const Int32 DOZE_WAKE_LOCK = 0x00000040;

        /**
         * Mask for the wake lock level component of a combined wake lock level and flags integer.
         *
         * @hide
         */
        const Int32 WAKE_LOCK_LEVEL_MASK = 0x0000ffff;

        /**
         * Wake lock flag: Turn the screen on when the wake lock is acquired.
         * <p>
         * Normally wake locks don't actually wake the device, they just cause
         * the screen to remain on once it's already on.  Think of the video player
         * application as the normal behavior.  Notifications that pop up and want
         * the device to be on are the exception; use this flag to be like them.
         * </p><p>
         * Cannot be used with {@link #PARTIAL_WAKE_LOCK}.
         * </p>
         */
        const Int32 ACQUIRE_CAUSES_WAKEUP = 0x10000000;

        /**
         * Wake lock flag: When this wake lock is released, poke the user activity timer
         * so the screen stays on for a little longer.
         * <p>
         * Will not turn the screen on if it is not already on.
         * See {@link #ACQUIRE_CAUSES_WAKEUP} if you want that.
         * </p><p>
         * Cannot be used with {@link #PARTIAL_WAKE_LOCK}.
         * </p>
         */
        const Int32 ON_AFTER_RELEASE = 0x20000000;

        /**
         * Wake lock flag: This wake lock is not important for logging events.  If a later
         * wake lock is acquired that is important, it will be considered the one to log.
         * @hide
         */
        const Int32 UNIMPORTANT_FOR_LOGGING = 0x40000000;

        /**
         * Flag for {@link WakeLock#release WakeLock.release(int)}: Defer releasing a
         * {@link #PROXIMITY_SCREEN_OFF_WAKE_LOCK} wake lock until the proximity sensor
         * indicates that an object is not in close proximity.
         */
        const Int32 RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY = 1;

        /**
         * Brightness value for fully on.
         * @hide
         */
        const Int32 BRIGHTNESS_ON = 255;

        /**
         * Brightness value for fully off.
         * @hide
         */
        const Int32 BRIGHTNESS_OFF = 0;

        /**
         * Brightness value for default policy handling by the system.
         * @hide
         */
        const Int32 BRIGHTNESS_DEFAULT = -1;

        // Note: Be sure to update android.os.BatteryStats and PowerManager.h
        // if adding or modifying user activity event constants.

        /**
         * User activity event type: Unspecified event type.
         * @hide
         */
        //@SystemApi
        const Int32 USER_ACTIVITY_EVENT_OTHER = 0;

        /**
         * User activity event type: Button or key pressed or released.
         * @hide
         */
        //@SystemApi
        const Int32 USER_ACTIVITY_EVENT_BUTTON = 1;

        /**
         * User activity event type: Touch down, move or up.
         * @hide
         */
        //@SystemApi
        const Int32 USER_ACTIVITY_EVENT_TOUCH = 2;

        /**
         * User activity flag: If already dimmed, extend the dim timeout
         * but do not brighten.  This flag is useful for keeping the screen on
         * a little longer without causing a visible change such as when
         * the power key is pressed.
         * @hide
         */
        //@SystemApi
        const Int32 USER_ACTIVITY_FLAG_NO_CHANGE_LIGHTS = 1 << 0;

        /**
         * User activity flag: Note the user activity as usual but do not
         * reset the user activity timeout.  This flag is useful for applying
         * user activity power hints when interacting with the device indirectly
         * on a secondary screen while allowing the primary screen to go to sleep.
         * @hide
         */
        //@SystemApi
        const Int32 USER_ACTIVITY_FLAG_INDIRECT = 1 << 1;

        /**
         * Go to sleep reason code: Going to sleep due by application request.
         * @hide
         */
        const Int32 GO_TO_SLEEP_REASON_APPLICATION = 0;

        /**
         * Go to sleep reason code: Going to sleep due by request of the
         * device administration policy.
         * @hide
         */
        const Int32 GO_TO_SLEEP_REASON_DEVICE_ADMIN = 1;

        /**
         * Go to sleep reason code: Going to sleep due to a screen timeout.
         * @hide
         */
        const Int32 GO_TO_SLEEP_REASON_TIMEOUT = 2;

        /**
         * Go to sleep reason code: Going to sleep due to the lid switch being closed.
         * @hide
         */
        const Int32 GO_TO_SLEEP_REASON_LID_SWITCH = 3;

        /**
         * Go to sleep reason code: Going to sleep due to the power button being pressed.
         * @hide
         */
        const Int32 GO_TO_SLEEP_REASON_POWER_BUTTON = 4;

        /**
         * Go to sleep reason code: Going to sleep due to HDMI.
         * @hide
         */
        const Int32 GO_TO_SLEEP_REASON_HDMI = 5;

        /**
         * Go to sleep flag: Skip dozing state and directly go to full sleep.
         * @hide
         */
        const Int32 GO_TO_SLEEP_FLAG_NO_DOZE = 1 << 0;

        /**
         * The value to pass as the 'reason' argument to reboot() to
         * reboot into recovery mode (for applying system updates, doing
         * factory resets, etc.).
         * <p>
         * Requires the {@link android.Manifest.permission#RECOVERY}
         * permission (in addition to
         * {@link android.Manifest.permission#REBOOT}).
         * </p>
         * @hide
         */
        const String REBOOT_RECOVERY = "recovery";

        /**
         * Intent that is broadcast when the state of {@link #isPowerSaveMode()} changes.
         * This broadcast is only sent to registered receivers.
         */
        //@SdkConstant(SdkConstant.SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_POWER_SAVE_MODE_CHANGED
                = "android.os.action.POWER_SAVE_MODE_CHANGED";

        /**
         * Intent that is broadcast when the state of {@link #isPowerSaveMode()} is about to change.
         * This broadcast is only sent to registered receivers.
         *
         * @hide
         */
        //@SdkConstant(SdkConstant.SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_POWER_SAVE_MODE_CHANGING
                = "android.os.action.POWER_SAVE_MODE_CHANGING";

        /** @hide */
        const String EXTRA_POWER_SAVE_MODE = "mode";
        /**
        * Power save profile
        * @hide
        */
        const String PROFILE_POWER_SAVE = "0";

        /**
        * Balanced power profile
        * @hide
        */
        const String PROFILE_BALANCED = "1";

        /**
        * High-performance profile
        * @hide
        */
        const String PROFILE_HIGH_PERFORMANCE = "2";

        /**
        * Broadcast sent when profile is changed
        * @hide
        */
        const String POWER_PROFILE_CHANGED
                = "com.cyanogenmod.power.PROFILE_CHANGED";

        /**
         * Gets the minimum supported screen brightness setting.
         * The screen may be allowed to become dimmer than this value but
         * this is the minimum value that can be set by the user.
         * @hide
         */
        GetMinimumScreenBrightnessSetting(
            [out] Int32* screenBrightness);

        /**
         * Gets the maximum supported screen brightness setting.
         * The screen may be allowed to become dimmer than this value but
         * this is the maximum value that can be set by the user.
         * @hide
         */
        GetMaximumScreenBrightnessSetting(
            [out] Int32* screenBrightness);

        /**
         * Gets the default screen brightness setting.
         * @hide
         */
        GetDefaultScreenBrightnessSetting(
            [out] Int32* screenBrightness);

        /**
         * Creates a new wake lock with the specified level and flags.
         * <p>
         * The {@code levelAndFlags} parameter specifies a wake lock level and optional flags
         * combined using the logical OR operator.
         * </p><p>
         * The wake lock levels are: {@link #PARTIAL_WAKE_LOCK},
         * {@link #FULL_WAKE_LOCK}, {@link #SCREEN_DIM_WAKE_LOCK}
         * and {@link #SCREEN_BRIGHT_WAKE_LOCK}.  Exactly one wake lock level must be
         * specified as part of the {@code levelAndFlags} parameter.
         * </p><p>
         * The wake lock flags are: {@link #ACQUIRE_CAUSES_WAKEUP}
         * and {@link #ON_AFTER_RELEASE}.  Multiple flags can be combined as part of the
         * {@code levelAndFlags} parameters.
         * </p><p>
         * Call {@link WakeLock#acquire() acquire()} on the object to acquire the
         * wake lock, and {@link WakeLock#release release()} when you are done.
         * </p><p>
         * {@samplecode
         * PowerManager pm = (PowerManager)mContext.getSystemService(
         *                                          Context.POWER_SERVICE);
         * PowerManager.WakeLock wl = pm.newWakeLock(
         *                                      PowerManager.SCREEN_DIM_WAKE_LOCK
         *                                      | PowerManager.ON_AFTER_RELEASE,
         *                                      TAG);
         * wl.acquire();
         * // ... do work...
         * wl.release();
         * }
         * </p><p>
         * Although a wake lock can be created without special permissions,
         * the {@link android.Manifest.permission#WAKE_LOCK} permission is
         * required to actually acquire or release the wake lock that is returned.
         * </p><p class="note">
         * If using this to keep the screen on, you should strongly consider using
         * {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead.
         * This window flag will be correctly managed by the platform
         * as the user moves between applications and doesn't require a special permission.
         * </p>
         *
         * @param levelAndFlags Combination of wake lock level and flag values defining
         * the requested behavior of the WakeLock.
         * @param tag Your class name (or other tag) for debugging purposes.
         *
         * @see WakeLock#acquire()
         * @see WakeLock#release()
         * @see #PARTIAL_WAKE_LOCK
         * @see #FULL_WAKE_LOCK
         * @see #SCREEN_DIM_WAKE_LOCK
         * @see #SCREEN_BRIGHT_WAKE_LOCK
         * @see #ACQUIRE_CAUSES_WAKEUP
         * @see #ON_AFTER_RELEASE
         */
        NewWakeLock(
            [in] Int32 levelAndFlags,
            [in] String tag,
            [out] IPowerManagerWakeLock** wakeLock);

        /**
         * Notifies the power manager that user activity happened.
         * <p>
         * Resets the auto-off timer and brightens the screen if the device
         * is not asleep.  This is what happens normally when a key or the touch
         * screen is pressed or when some other user activity occurs.
         * This method does not wake up the device if it has been put to sleep.
         * </p><p>
         * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
         * </p>
         *
         * @param when The time of the user activity, in the {@link SystemClock#uptimeMillis()}
         * time base.  This timestamp is used to correctly order the user activity request with
         * other power management functions.  It should be set
         * to the timestamp of the input event that caused the user activity.
         * @param noChangeLights If true, does not cause the keyboard backlight to turn on
         * because of this event.  This is set when the power key is pressed.
         * We want the device to stay on while the button is down, but we're about
         * to turn off the screen so we don't want the keyboard backlight to turn on again.
         * Otherwise the lights flash on and then off and it looks weird.
         *
         * @see #wakeUp
         * @see #goToSleep
         */
        UserActivity(
            [in] Int64 when,
            [in] Boolean noChangeLights);

        /**
         * Notifies the power manager that user activity happened.
         * <p>
         * Resets the auto-off timer and brightens the screen if the device
         * is not asleep.  This is what happens normally when a key or the touch
         * screen is pressed or when some other user activity occurs.
         * This method does not wake up the device if it has been put to sleep.
         * </p><p>
         * Requires the {@link android.Manifest.permission#DEVICE_POWER} or
         * {@link android.Manifest.permission#USER_ACTIVITY} permission.
         * </p>
         *
         * @param when The time of the user activity, in the {@link SystemClock#uptimeMillis()}
         * time base.  This timestamp is used to correctly order the user activity request with
         * other power management functions.  It should be set
         * to the timestamp of the input event that caused the user activity.
         * @param event The user activity event.
         * @param flags Optional user activity flags.
         *
         * @see #wakeUp
         * @see #goToSleep
         *
         * @hide Requires signature or system permission.
         */
        //@SystemApi
        UserActivity(
            [in] Int64 when,
            [in] Int32 event,
            [in] Int32 flags);
        /**
         * Forces the device to go to sleep.
         * <p>
         * Overrides all the wake locks that are held.
         * This is what happens when the power key is pressed to turn off the screen.
         * </p><p>
         * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
         * </p>
         *
         * @param time The time when the request to go to sleep was issued, in the
         * {@link SystemClock#uptimeMillis()} time base.  This timestamp is used to correctly
         * order the go to sleep request with other power management functions.  It should be set
         * to the timestamp of the input event that caused the request to go to sleep.
         *
         * @see #userActivity
         * @see #wakeUp
         */
        GoToSleep(
            [in] Int64 eventTime);

        /**
         * Forces the device to go to sleep.
         * <p>
         * Overrides all the wake locks that are held.
         * This is what happens when the power key is pressed to turn off the screen.
         * </p><p>
         * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
         * </p>
         *
         * @param time The time when the request to go to sleep was issued, in the
         * {@link SystemClock#uptimeMillis()} time base.  This timestamp is used to correctly
         * order the go to sleep request with other power management functions.  It should be set
         * to the timestamp of the input event that caused the request to go to sleep.
         * @param reason The reason the device is going to sleep.
         * @param flags Optional flags to apply when going to sleep.
         *
         * @see #userActivity
         * @see #wakeUp
         *
         * @hide Requires signature permission.
         */
        GoToSleep(
            [in] Int64 eventTime,
            [in] Int32 reason,
            [in] Int32 flags);

        /**
         * Forces the device to wake up from sleep.
         * <p>
         * If the device is currently asleep, wakes it up, otherwise does nothing.
         * This is what happens when the power key is pressed to turn on the screen.
         * </p><p>
         * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
         * </p>
         *
         * @param time The time when the request to wake up was issued, in the
         * {@link SystemClock#uptimeMillis()} time base.  This timestamp is used to correctly
         * order the wake up request with other power management functions.  It should be set
         * to the timestamp of the input event that caused the request to wake up.
         *
         * @see #userActivity
         * @see #goToSleep
         */
        WakeUp(
            [in] Int64 eventTime);

        /**
         * Forces the device to wake up from sleep only if
         * nothing is blocking the proximity sensor
         * @see #wakeUp
         * @hide
         */
        WakeUpWithProximityCheck(
            [in] Int64 time);

        Nap(
            [in] Int64 time);

        SetBacklightBrightness(
            [in] Int32 brightness);

        IsWakeLockLevelSupported(
            [in] Int32 level,
            [out] Boolean* support);

        /**
          * Returns whether the screen is currently on.
          * <p>
          * Only indicates whether the screen is on.  The screen could be either bright or dim.
          * </p><p>
          * {@samplecode
          * PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
          * boolean isScreenOn = pm.isScreenOn();
          * }
          * </p>
          *
          * @return whether the screen is on (bright or dim).
          */
        IsScreenOn(
            [out] Boolean* isScreenOn);

        /**
         * Returns true if the device is in an interactive state.
         * <p>
         * When this method returns true, the device is awake and ready to interact
         * with the user (although this is not a guarantee that the user is actively
         * interacting with the device just this moment).  The main screen is usually
         * turned on while in this state.  Certain features, such as the proximity
         * sensor, may temporarily turn off the screen while still leaving the device in an
         * interactive state.  Note in particular that the device is still considered
         * to be interactive while dreaming (since dreams can be interactive) but not
         * when it is dozing or asleep.
         * </p><p>
         * When this method returns false, the device is dozing or asleep and must
         * be awoken before it will become ready to interact with the user again.  The
         * main screen is usually turned off while in this state.  Certain features,
         * such as "ambient mode" may cause the main screen to remain on (albeit in a
         * low power state) to display system-provided content while the device dozes.
         * </p><p>
         * The system will send a {@link android.content.Intent#ACTION_SCREEN_ON screen on}
         * or {@link android.content.Intent#ACTION_SCREEN_OFF screen off} broadcast
         * whenever the interactive state of the device changes.  For historical reasons,
         * the names of these broadcasts refer to the power state of the screen
         * but they are actually sent in response to changes in the overall interactive
         * state of the device, as described by this method.
         * </p><p>
         * Services may use the non-interactive state as a hint to conserve power
         * since the user is not present.
         * </p>
         *
         * @return True if the device is in an interactive state.
         *
         * @see android.content.Intent#ACTION_SCREEN_ON
         * @see android.content.Intent#ACTION_SCREEN_OFF
         */
        IsInteractive(
            [out] Boolean* result);

        /**
         * Reboot the device.  Will not return if the reboot is successful.
         * <p>
         * Requires the {@link android.Manifest.permission#REBOOT} permission.
         * </p>
         *
         * @param reason code to pass to the kernel (e.g., "recovery") to
         *               request special boot modes, or null.
         */
        Reboot(
            [in] String reason);

        /**
         * Returns true if the device is currently in power save mode.  When in this mode,
         * applications should reduce their functionality in order to conserve battery as
         * much as possible.  You can monitor for changes to this state with
         * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
         *
         * @return Returns true if currently in low power mode, else false.
         */
        IsPowerSaveMode(
            [out] Boolean* result);


        /**
         * Set the current power save mode.
         *
         * @return True if the set was allowed.
         *
         * @see #isPowerSaveMode()
         *
         * @hide
         */
        SetPowerSaveMode(
            [in] Boolean mode,
            [out] Boolean* result);

        /**
         * Boost the CPU. Boosts the cpu for the given duration in microseconds.
         * Requires the {@link android.Manifest.permission#CPU_BOOST} permission.
         *
         * @param duration in microseconds to boost the CPU
         *
         * @hide
         */
        CpuBoost(
            [in] Int32 duration);

        /**
         * True if the system supports power profiles
         *
         * @hide
         */
        HasPowerProfiles(
            [out] Boolean* result);

        /**
         * Gets the default power profile for the device.
         *
         * Returns null if not enabled.
         *
         * @hide
         */
        GetDefaultPowerProfile(
            [out] String* profile);

        /**
         * Set the system power profile
         *
         * @throws IllegalArgumentException if invalid
         * @hide
         */
        SetPowerProfile(
            [in] String profile,
            [out] Boolean* result);

        /**
         * Gets the current power profile
         *
         * Returns null if power profiles are not enabled
         * @hide
         */
        GetPowerProfile(
            [out] String* result);

        /**
         * Update profile for resumed app, called from ActivityStack
         * @hide
         */
        ActivityResumed(
            [in] IIntent* intent);

        /**
         * @hide
         */
        SetKeyboardVisibility(
            [in] Boolean visible);

        /**
         * sets the keyboard LED state
         *
         * @param on boolean state
         * @param key 1 for caps, 2 for fn
         *
         * {@hide}
         */
        SetKeyboardLight(
            [in] Boolean on,
            [in] Int32 key);

        /**
         * Gets the default button brightness value.
         * @hide
         */
        GetDefaultButtonBrightness(
            [out] Int32* result);

        /**
         * Gets the default keyboard brightness value.
         * @hide
         */
        GetDefaultKeyboardBrightness(
            [out] Int32* result);
    }

    interface IPowerManagerHelper {

        /**
         * Returns true if the twilight service should be used to adjust screen brightness
         * policy.  This setting is experimental and disabled by default.
         * @hide
         */
        UseTwilightAdjustmentFeature(
            [out] Boolean* result);

        ValidateWakeLockParameters(
            [in] Int32 levelAndFlags,
            [in] String tag);
    }

    } // namespace Os
    } // namespace Droid
    } // namespace Elastos
}
