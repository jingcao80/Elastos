//=========================================================================
// Copyright (C) 2012 The Elastos Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//=========================================================================

module
{
    using interface Elastos.Core.ICharSequence;
    using interface Elastos.Utility.ILocale;

    interface Elastos.Droid.Graphics.IPath;
    interface Elastos.Droid.Graphics.IShader;
    interface Elastos.Droid.Graphics.IXfermode;
    interface Elastos.Droid.Graphics.IPathEffect;
    interface Elastos.Droid.Graphics.IMaskFilter;
    interface Elastos.Droid.Graphics.ITypeface;
    interface Elastos.Droid.Graphics.IRasterizer;
    interface Elastos.Droid.Graphics.IRect;
    interface Elastos.Droid.Graphics.IColorFilter;

    namespace Elastos {
    namespace Droid {
    namespace Graphics {

    /**
     * The Style specifies if the primitive being drawn is filled,
     * stroked, or both (in the same color). The default is FILL.
     */

    enum PaintStyle {
        /**
         * Geometry and text drawn with this style will be filled, ignoring all
         * stroke-related settings in the paint.
         */
        PaintStyle_FILL            = 0x00,
        /**
         * Geometry and text drawn with this style will be stroked, respecting
         * the stroke-related fields on the paint.
         */
        PaintStyle_STROKE          = 0x01,
        /**
         * Geometry and text drawn with this style will be both filled and
         * stroked at the same time, respecting the stroke-related fields on
         * the paint. This mode can give unexpected results if the geometry
         * is oriented counter-clockwise. This restriction does not apply to
         * either FILL or STROKE.
         */
        PaintStyle_FILL_AND_STROKE = 0x02,
    }

    /**
     * The Cap specifies the treatment for the beginning and ending of
     * stroked lines and paths. The default is BUTT.
     */
    enum PaintCap {
        /**
         * The stroke ends with the path, and does not project beyond it.
         */
        PaintCap_BUTT    = 0x00,
        /**
         * The stroke projects out as a semicircle, with the center at the
         * end of the path.
         */
        PaintCap_ROUND   = 0x01,
        /**
         * The stroke projects out as a square, with the center at the end
         * of the path.
         */
        PaintCap_SQUARE  = 0x02,
    }

    /**
     * The Join specifies the treatment where lines and curve segments
     * join on a stroked path. The default is MITER.
     */
    enum PaintJoin {
        /**
         * The outer edges of a join meet at a sharp angle
         */
        PaintJoin_MITER   = 0x00,
        /**
         * The outer edges of a join meet in a circular arc.
         */
        PaintJoin_ROUND   = 0x01,
        /**
         * The outer edges of a join meet with a straight line
         */
        PaintJoin_BEVEL   = 0x02,
    }

    /**
     * Align specifies how drawText aligns its text relative to the
     * [x,y] coordinates. The default is LEFT.
     */
    enum PaintAlign {
        /**
         * The text is drawn to the right of the x,y origin
         */
        PaintAlign_LEFT    = 0x00,
        /**
         * The text is drawn centered horizontally on the x,y origin
         */
        PaintAlign_CENTER  = 0x01,
        /**
         * The text is drawn to the left of the x,y origin
         */
        PaintAlign_RIGHT   = 0x02,
    }

    /**
     * Class that describes the various metrics for a font at a given text size.
     * Remember, Y values increase going down, so those values will be positive,
     * and values that measure distances going up will be negative.
     * This class is returned by getFontMetrics().
     */
    interface IPaintFontMetrics {
        GetTop(
            [out] Float* top);

        SetTop(
            [in] Float top);

        GetAscent(
            [out] Float* ascent);

        SetAscent(
            [in] Float ascent);

        GetDescent(
            [out] Float* descent);

        SetDescent(
            [in] Float descent);

        GetBottom(
            [out] Float* bottom);

        SetBottom(
            [in] Float bottom);

        GetLeading(
            [out] Float* leading);

        SetLeading(
            [in] Float leading);
    }

    interface IPaintFontMetricsInt {
        GetTop(
            [out] Int32* top);

        SetTop(
            [in] Int32 top);

        GetAscent(
            [out] Int32* ascent);

        SetAscent(
            [in] Int32 ascent);

        GetDescent(
            [out] Int32* descent);

        SetDescent(
            [in] Int32 descent);

        GetBottom(
            [out] Int32* bottom);

        SetBottom(
            [in] Int32 bottom);

        GetLeading(
            [out] Int32* leading);

        SetLeading(
            [in] Int32 leading);
    }

    /**
     * The Paint class holds the style and color information about how to draw
     * geometries, text and bitmaps.
     */
    [deprecated]
    interface IPaint {

        /**
         * Paint flag that enables antialiasing when drawing.
         *
         * <p>Enabling this flag will cause all draw operations that support
         * antialiasing to use it.</p>
         *
         * @see #Paint(int)
         * @see #setFlags(int)
         */
        const Int32 ANTI_ALIAS_FLAG     = 0x01;

        /**
         * Paint flag that enables bilinear sampling on scaled bitmaps.
         *
         * <p>If cleared, scaled bitmaps will be drawn with nearest neighbor
         * sampling, likely resulting in artifacts. This should generally be on
         * when drawing bitmaps, unless performance-bound (rendering to software
         * canvas) or preferring pixelation artifacts to blurriness when scaling
         * significantly.</p>
         *
         * <p>If bitmaps are scaled for device density at creation time (as
         * resource bitmaps often are) the filtering will already have been
         * done.</p>
         *
         * @see #Paint(int)
         * @see #setFlags(int)
         */
        const Int32 FILTER_BITMAP_FLAG  = 0x02;

        /**
         * Paint flag that enables dithering when blitting.
         *
         * <p>Enabling this flag applies a dither to any blit operation where the
         * target's colour space is more constrained than the source.
         *
         * @see #Paint(int)
         * @see #setFlags(int)
         */
        const Int32 DITHER_FLAG         = 0x04;

        /**
         * Paint flag that applies an underline decoration to drawn text.
         *
         * @see #Paint(int)
         * @see #setFlags(int)
         */
        const Int32 UNDERLINE_TEXT_FLAG = 0x08;

        /**
         * Paint flag that applies a strike-through decoration to drawn text.
         *
         * @see #Paint(int)
         * @see #setFlags(int)
         */
        const Int32 STRIKE_THRU_TEXT_FLAG = 0x10;

        /**
         * Paint flag that applies a synthetic bolding effect to drawn text.
         *
         * <p>Enabling this flag will cause text draw operations to apply a
         * simulated bold effect when drawing a {@link Typeface} that is not
         * already bold.</p>
         *
         * @see #Paint(int)
         * @see #setFlags(int)
         */
        const Int32 FAKE_BOLD_TEXT_FLAG = 0x20;

        /**
         * Paint flag that enables smooth linear scaling of text.
         *
         * <p>Enabling this flag does not actually scale text, but rather adjusts
         * text draw operations to deal gracefully with smooth adjustment of scale.
         * When this flag is enabled, font hinting is disabled to prevent shape
         * deformation between scale factors, and glyph caching is disabled due to
         * the large number of glyph images that will be generated.</p>
         *
         * <p>{@link #SUBPIXEL_TEXT_FLAG} should be used in conjunction with this
         * flag to prevent glyph positions from snapping to whole pixel values as
         * scale factor is adjusted.</p>
         *
         * @see #Paint(int)
         * @see #setFlags(int)
         */
        const Int32 LINEAR_TEXT_FLAG    = 0x40;

        /**
         * Paint flag that enables subpixel positioning of text.
         *
         * <p>Enabling this flag causes glyph advances to be computed with subpixel
         * accuracy.</p>
         *
         * <p>This can be used with {@link #LINEAR_TEXT_FLAG} to prevent text from
         * jittering during smooth scale transitions.</p>
         *
         * @see #Paint(int)
         * @see #setFlags(int)
         */
        const Int32 SUBPIXEL_TEXT_FLAG  = 0x80;

        /** Legacy Paint flag, no longer used. */
        const Int32 DEV_KERN_TEXT_FLAG  = 0x100;

        /** @hide bit mask for the flag enabling subpixel glyph rendering for text */
        const Int32 LCD_RENDER_TEXT_FLAG = 0x200;

        /**
         * Paint flag that enables the use of bitmap fonts when drawing text.
         *
         * <p>Disabling this flag will prevent text draw operations from using
         * embedded bitmap strikes in fonts, causing fonts with both scalable
         * outlines and bitmap strikes to draw only the scalable outlines, and
         * fonts with only bitmap strikes to not draw at all.</p>
         *
         * @see #Paint(int)
         * @see #setFlags(int)
         */
        const Int32 EMBEDDED_BITMAP_TEXT_FLAG = 0x400;

        /** @hide bit mask for the flag forcing freetype's autohinter on for text */
        const Int32 AUTO_HINTING_TEXT_FLAG = 0x800;

        /** @hide bit mask for the flag enabling vertical rendering for text */
        const Int32 VERTICAL_TEXT_FLAG = 0x1000;

        /**
         * Option for setHinting: disable hinting.
         *
         * @sa #setHinting
         */
        const Int32 HINTING_OFF = 0x0;

        /**
         * Option for setHinting: enable hinting.
         *
         * @sa #setHinting
         */
        const Int32 HINTING_ON = 0x1;
        /**
         * Bidi flag to set LTR paragraph direction.
         *
         * @hide
         */
        const Int32 BIDI_LTR = 0x0;
        /**
         * Bidi flag to set RTL paragraph direction.
         *
         * @hide
         */
        const Int32 BIDI_RTL = 0x1;
        /**
         * Bidi flag to detect paragraph direction via heuristics, defaulting to
         * LTR.
         *
         * @hide
         */
        const Int32 BIDI_DEFAULT_LTR = 0x2;
        /**
         * Bidi flag to detect paragraph direction via heuristics, defaulting to
         * RTL.
         *
         * @hide
         */
        const Int32 BIDI_DEFAULT_RTL = 0x3;
        /**
         * Bidi flag to override direction to all LTR (ignore bidi).
         *
         * @hide
         */
        const Int32 BIDI_FORCE_LTR = 0x4;
        /**
         * Bidi flag to override direction to all RTL (ignore bidi).
         *
         * @hide
         */
        const Int32 BIDI_FORCE_RTL = 0x5;

        /**
         * Flag for getTextRunAdvances indicating left-to-right run direction.
         * @hide
         */
        const Int32 DIRECTION_LTR = 0;

        /**
         * Flag for getTextRunAdvances indicating right-to-left run direction.
         * @hide
         */
        const Int32 DIRECTION_RTL = 1;

        /**
         * Option for getTextRunCursor to compute the valid cursor after
         * offset or the limit of the context, whichever is less.
         * @hide
         */
        const Int32 CURSOR_AFTER = 0;

        /**
         * Option for getTextRunCursor to compute the valid cursor at or after
         * the offset or the limit of the context, whichever is less.
         * @hide
         */
        const Int32 CURSOR_AT_OR_AFTER = 1;

         /**
         * Option for getTextRunCursor to compute the valid cursor before
         * offset or the start of the context, whichever is greater.
         * @hide
         */
        const Int32 CURSOR_BEFORE = 2;

        /**
         * Option for getTextRunCursor to compute the valid cursor at or before
         * offset or the start of the context, whichever is greater.
         * @hide
         */
        const Int32 CURSOR_AT_OR_BEFORE = 3;

        /**
         * Option for getTextRunCursor to return offset if the cursor at offset
         * is valid, or -1 if it isn't.
         * @hide
         */
        const Int32 CURSOR_AT = 4;

        /**
         * Return the distance above (negative) the baseline (ascent) based on the
         * current typeface and text size.
         *
         * @return the distance above (negative) the baseline (ascent) based on the
         *         current typeface and text size.
         */
        Ascent(
            [out] Float* distance);

        /**
         * Measure the text, stopping early if the measured width exceeds maxWidth.
         * Return the number of chars that were measured, and if measuredWidth is
         * not null, return in it the actual width measured.
         *
         * @param text  The text to measure
         * @param index The offset into text to begin measuring at
         * @param count The number of maximum number of entries to measure. If count
         *              is negative, then the characters before index are measured
         *              in reverse order. This allows for measuring the end of
         *              string.
         * @param maxWidth The maximum width to accumulate.
         * @param measuredWidth Optional. If not null, returns the actual width
         *                     measured.
         * @return The number of chars that were measured. Will always be <=
         *         abs(count).
         */
        BreakText(
            [in] ArrayOf<Char32>* text,
            [in] Int32 index,
            [in] Int32 count,
            [in] Float maxWidth,
            [in] ArrayOf<Float>* measuredWidth,
            [out] Int32* number);

        /**
         * Measure the text, stopping early if the measured width exceeds maxWidth.
         * Return the number of chars that were measured, and if measuredWidth is
         * not null, return in it the actual width measured.
         *
         * @param text  The text to measure
         * @param start The offset into text to begin measuring at
         * @param end   The end of the text slice to measure.
         * @param measureForwards If true, measure forwards, starting at start.
         *                        Otherwise, measure backwards, starting with end.
         * @param maxWidth The maximum width to accumulate.
         * @param measuredWidth Optional. If not null, returns the actual width
         *                     measured.
         * @return The number of chars that were measured. Will always be <=
         *         abs(end - start).
         */
        BreakText(
            [in] ICharSequence* text,
            [in] Int32 start,
            [in] Int32 end,
            [in] Boolean measureForwards,
            [in] Float maxWidth,
            [in] ArrayOf<Float>* measuredWidth,
            [out] Int32* number);

        /**
         * Measure the text, stopping early if the measured width exceeds maxWidth.
         * Return the number of chars that were measured, and if measuredWidth is
         * not null, return in it the actual width measured.
         *
         * @param text  The text to measure
         * @param measureForwards If true, measure forwards, starting with the
         *                        first character in the string. Otherwise,
         *                        measure backwards, starting with the
         *                        last character in the string.
         * @param maxWidth The maximum width to accumulate.
         * @param measuredWidth Optional. If not null, returns the actual width
         *                     measured.
         * @return The number of chars that were measured. Will always be <=
         *         abs(count).
         */
        BreakText(
            [in] String text,
            [in] Boolean measureForwards,
            [in] Float maxWidth,
            [in] ArrayOf<Float>* measuredWidth,
            [out] Int32* number);

        /**
         * Temporary API to clear the shadow layer.
         */
        ClearShadowLayer();

        /**
         * Checks if the paint has a shadow layer attached
         *
         * @return true if the paint has a shadow layer attached and false otherwise
         * @hide
         */
        HasShadowLayer(
            [out] Boolean* hasShadowLayer);

        /**
         * Return the distance below (positive) the baseline (descent) based on the
         * current typeface and text size.
         *
         * @return the distance below (positive) the baseline (descent) based on
         *         the current typeface and text size.
         */
        Descent(
            [out] Float* distance);

        /**
         * Helper to getColor() that just returns the color's alpha value. This is
         * the same as calling getColor() >>> 24. It always returns a value between
         * 0 (completely transparent) and 255 (completely opaque).
         *
         * @return the alpha component of the paint's color.
         */
        GetAlpha(
            [out] Int32* alpha);

        /**
         * Return the bidi flags on the paint.
         *
         * @return the bidi flags on the paint
         * @hide
         */
         GetBidiFlags(
             [out] Int32* flags);

        /**
         * Return the paint's color. Note that the color is a 32bit value
         * containing alpha as well as r,g,b. This 32bit value is not premultiplied,
         * meaning that its alpha can be any value, regardless of the values of
         * r,g,b. See the Color class for more details.
         *
         * @return the paint's color (and alpha).
         */
        GetColor(
            [out] Int32* color);

        /**
         * Get the paint's colorfilter (maybe be null).
         *
         * @return the paint's colorfilter (maybe be null)
         */
        GetColorFilter(
            [out] IColorFilter** filter);

        /**
         * Applies any/all effects (patheffect, stroking) to src, returning the
         * result in dst. The result is that drawing src with this paint will be
         * the same as drawing dst with a default paint (at least from the
         * geometric perspective).
         *
         * @param src input path
         * @param dst output path (may be the same as src)
         * @return    true if the path should be filled, or false if it should be
         *                 drawn with a hairline (width == 0)
         */
        GetFillPath(
            [in] IPath* src,
            [in] IPath* dst,
            [out] Boolean* isShouldFilled);

        /**
         * Return the paint's flags. Use the Flag enum to test flag values.
         *
         * @return the paint's flags (see enums ending in _Flag for bit masks)
         */
        GetFlags(
            [out] Int32* flags);

        /**
         * Return the font's recommended interline spacing, given the Paint's
         * settings for typeface, textSize, etc. If metrics is not null, return the
         * fontmetric values in it.
         *
         * @param metrics If this object is not null, its fields are filled with
         *                the appropriate values given the paint's text attributes.
         * @return the font's recommended interline spacing.
         */
        GetFontMetrics(
            [in] IPaintFontMetrics* metrics,
            [out] Float* spacing);

        /**
         * Allocates a new FontMetrics object, and then calls getFontMetrics(fm)
         * with it, returning the object.
         */
        GetFontMetrics(
            [out] IPaintFontMetrics** metrics);

        /**
         * Return the font's interline spacing, given the Paint's settings for
         * typeface, textSize, etc. If metrics is not null, return the fontmetric
         * values in it. Note: all values have been converted to integers from
         * floats, in such a way has to make the answers useful for both spacing
         * and clipping. If you want more control over the rounding, call
         * getFontMetrics().
         *
         * @return the font's interline spacing.
         */
        GetFontMetricsInt(
            [in] IPaintFontMetricsInt* fmi,
            [out] Int32* spacing);

        GetFontMetricsInt(
            [out] IPaintFontMetricsInt** fmi);

        /**
         * Return the recommend line spacing based on the current typeface and
         * text size.
         *
         * @return  recommend line spacing based on the current typeface and
         *          text size.
         */
        GetFontSpacing(
            [out] Float* spacing);

        /**
         * Return the paint's hinting mode.  Returns either
         * #HINTING_OFF or #HINTING_ON.
         *
         * @sa #HINTING_OFF
         * @sa #HINTING_ON
         */
        GetHinting(
            [out] Int32* result);

        /**
         * Get the paint's maskfilter object.
         *
         * @return the paint's maskfilter (or null)
         */
        GetMaskFilter(
            [out] IMaskFilter** maskfilter);

        /**
         * Get the paint's patheffect object.
         *
         * @return the paint's patheffect (or null)
         */
        GetPathEffect(
            [out] IPathEffect** effect);

        /**
         * Get the paint's rasterizer (or null).
         * <p />
         * The raster controls/modifies how paths/text are turned into alpha masks.
         *
         * @return         the paint's rasterizer (or null)
         */
        GetRasterizer(
            [out] IRasterizer** rasterizer);

        /**
         * Get the paint's shader object.
         *
         * @return the paint's shader (or null)
         */
        GetShader(
            [out] IShader** shader);

        /**
         * Return the paint's Cap, controlling how the start and end of stroked
         * lines and paths are treated.
         *
         * @return the line cap style for the paint, used whenever the paint's
         *         style is Stroke or StrokeAndFill.
         */
        GetStrokeCap(
            [out] PaintCap* cap);

        /**
         * Return the paint's stroke join type.
         *
         * @return the paint's Join.
         */
        GetStrokeJoin(
            [out] PaintJoin* join);

        /**
         * Return the paint's stroke miter value. Used to control the behavior
         * of miter joins when the joins angle is sharp.
         *
         * @return the paint's miter limit, used whenever the paint's style is
         *         Stroke or StrokeAndFill.
         */
        GetStrokeMiter(
            [out] Float* strokeMiter);

        /**
         * Return the width for stroking.
         * <p />
         * A value of 0 strokes in hairline mode.
         * Hairlines always draws a single pixel independent of the canva's matrix.
         *
         * @return the paint's stroke width, used whenever the paint's style is
         *         Stroke or StrokeAndFill.
         */
        GetStrokeWidth(
            [out] Float* width);

        /**
         * Return the paint's style, used for controlling how primitives'
         * geometries are interpreted (except for drawBitmap, which always assumes
         * FILL_STYLE).
         *
         * @return the paint's style setting (Fill, Stroke, StrokeAndFill)
         */
        GetStyle(
            [out] PaintStyle* style);

        /**
         * Return the paint's Align value for drawing text. This controls how the
         * text is positioned relative to its origin. LEFT align means that all of
         * the text will be drawn to the right of its origin (i.e. the origin
         * specifieds the LEFT edge of the text) and so on.
         *
         * @return the paint's Align value for drawing text.
         */
        GetTextAlign(
            [out] PaintAlign* align);

        /**
         * Return in bounds (allocated by the caller) the smallest rectangle that
         * encloses all of the characters, with an implied origin at (0,0).
         *
         * @param text  String to measure and return its bounds
         * @param start Index of the first char in the string to measure
         * @param end   1 past the last char in the string measure
         * @param bounds Returns the unioned bounds of all the text. Must be
         *               allocated by the caller.
         */
        GetTextBounds(
            [in] String text,
            [in] Int32 start,
            [in] Int32 end,
            [in] IRect* bounds);

        /**
         * Return in bounds (allocated by the caller) the smallest rectangle that
         * encloses all of the characters, with an implied origin at (0,0).
         *
         * @param text  Array of chars to measure and return their unioned bounds
         * @param index Index of the first char in the array to measure
         * @param count The number of chars, beginning at index, to measure
         * @param bounds Returns the unioned bounds of all the text. Must be
         *               allocated by the caller.
         */
        GetTextBounds(
            [in] ArrayOf<Char32>* text,
            [in] Int32 index,
            [in] Int32 count,
            [in] IRect* bounds);

        /**
         * Convenience overload that takes a char array instead of a
         * String.
         *
         * @see #getTextRunAdvances(String, int, int, int, int, int, float[], int)
         * @hide
         */
        GetTextRunAdvances(
            [in] ArrayOf<Char32>* chars,
            [in] Int32 index,
            [in] Int32 count,
            [in] Int32 contextIndex,
            [in] Int32 contextCount,
            [in] Boolean isRtl,
            [in] ArrayOf<Float>* advances,
            [in] Int32 advancesIndex,
            [out] Float* retvalue);

        /**
         * Convenience overload that takes a CharSequence instead of a
         * String.
         *
         * @see #getTextRunAdvances(String, int, int, int, int, int, float[], int)
         * @hide
         */
        GetTextRunAdvances(
            [in] ICharSequence* text,
            [in] Int32 start,
            [in] Int32 end,
            [in] Int32 contextStart,
            [in] Int32 contextEnd,
            [in] Boolean isRtl,
            [in] ArrayOf<Float>* advances,
            [in] Int32 advancesIndex,
            [out] Float* retvalue);

        /**
         * Returns the total advance width for the characters in the run
         * between start and end, and if advances is not null, the advance
         * assigned to each of these characters (java chars).
         *
         * <p>The trailing surrogate in a valid surrogate pair is assigned
         * an advance of 0.  Thus the number of returned advances is
         * always equal to count, not to the number of unicode codepoints
         * represented by the run.
         *
         * <p>In the case of conjuncts or combining marks, the total
         * advance is assigned to the first logical character, and the
         * following characters are assigned an advance of 0.
         *
         * <p>This generates the sum of the advances of glyphs for
         * characters in a reordered cluster as the width of the first
         * logical character in the cluster, and 0 for the widths of all
         * other characters in the cluster.  In effect, such clusters are
         * treated like conjuncts.
         *
         * <p>The shaping bounds limit the amount of context available
         * outside start and end that can be used for shaping analysis.
         * These bounds typically reflect changes in bidi level or font
         * metrics across which shaping does not occur.
         *
         * @param text the text to measure. Cannot be null.
         * @param start the index of the first character to measure
         * @param end the index past the last character to measure
         * @param contextStart the index of the first character to use for shaping context,
         * must be <= start
         * @param contextEnd the index past the last character to use for shaping context,
         * must be >= end
         * @param flags the flags to control the advances, either DIRECTION_LTR
         * or DIRECTION_RTL
         *
         * @sa #DIRECTION_LTR
         * @sa #DIRECTION_RTL
         *
         * @param advances array to receive the advances, must have room for all advances,
         * can be null if only total advance is needed
         * @param advancesIndex the position in advances at which to put the
         * advance corresponding to the character at start
         * @return the total advance
         *
         * @hide
         */
        GetTextRunAdvances(
            [in] String text,
            [in] Int32 start,
            [in] Int32 end,
            [in] Int32 contextStart,
            [in] Int32 contextEnd,
            [in] Boolean isRtl,
            [in] ArrayOf<Float>* advances,
            [in] Int32 advancesIndex,
            [out] Float* retvalue);

        /**
         * Returns the next cursor position in the run.  This avoids placing the
         * cursor between surrogates, between characters that form conjuncts,
         * between base characters and combining marks, or within a reordering
         * cluster.
         *
         * <p>ContextStart and offset are relative to the start of text.
         * The context is the shaping context for cursor movement, generally
         * the bounds of the metric span enclosing the cursor in the direction of
         * movement.
         *
         * <p>If cursorOpt is CURSOR_AT and the offset is not a valid
         * cursor position, this returns -1.  Otherwise this will never return a
         * value before contextStart or after contextStart + contextLength.
         *
         * @sa #CURSOR_AT
         *
         * @param text the text
         * @param contextStart the start of the context
         * @param contextLength the length of the context
         * @param flags either DIRECTION_RTL or DIRECTION_LTR
         *
         * @sa #DIRECTION_RTL
         * @sa #DIRECTION_LTR
         * @param offset the cursor position to move from
         * @param cursorOpt how to move the cursor, one of CURSOR_AFTER,
         * CURSOR_AT_OR_AFTER, CURSOR_BEFORE,
         * CURSOR_AT_OR_BEFORE, orCURSOR_AT
         *
         * @sa #CURSOR_AFTER
         * @sa #CURSOR_AT_OR_AFTER
         * @sa #CURSOR_BEFORE},
         * @sa #CURSOR_AT_OR_BEFORE
         * @sa #CURSOR_AT
         *
         * @return the offset of the next position, or -1
         * @hide
         */
        GetTextRunCursor(
            [in] ArrayOf<Char32>* text,
            [in] Int32 contextStart,
            [in] Int32 contextLength,
            [in] Int32 flags,
            [in] Int32 offset,
            [in] Int32 cursorOpt,
            [out] Int32* position);

        /**
         * Returns the next cursor position in the run.  This avoids placing the
         * cursor between surrogates, between characters that form conjuncts,
         * between base characters and combining marks, or within a reordering
         * cluster.
         *
         * <p>ContextStart, contextEnd, and offset are relative to the start of
         * text.  The context is the shaping context for cursor movement, generally
         * the bounds of the metric span enclosing the cursor in the direction of
         * movement.
         *
         * <p>If cursorOpt is CURSOR_AT and the offset is not a valid
         * cursor position, this returns -1.  Otherwise this will never return a
         * value before contextStart or after contextStart + contextLength.
         *
         * @sa #CURSOR_AT
         *
         * @param text the text
         * @param contextStart the start of the context
         * @param contextLength the length of the context
         * @param flags either DIRECTION_RTL or DIRECTION_LTR
         *
         * @sa #DIRECTION_RTL
         * @sa #DIRECTION_LTR
         * @param offset the cursor position to move from
         * @param cursorOpt how to move the cursor, one of CURSOR_AFTER,
         * CURSOR_AT_OR_AFTER, CURSOR_BEFORE,
         * CURSOR_AT_OR_BEFORE, orCURSOR_AT
         *
         * @sa #CURSOR_AFTER
         * @sa #CURSOR_AT_OR_AFTER
         * @sa #CURSOR_BEFORE},
         * @sa #CURSOR_AT_OR_BEFORE
         * @sa #CURSOR_A
         * @return the offset of the next position, or -1
         * @hide
         */
        GetTextRunCursor(
             [in] ICharSequence* text,
             [in] Int32 contextStart,
             [in] Int32 contextEnd,
             [in] Int32 flags,
             [in] Int32 offset,
             [in] Int32 cursorOpt,
             [out] Int32* position);

        /**
         * Returns the next cursor position in the run.  This avoids placing the
         * cursor between surrogates, between characters that form conjuncts,
         * between base characters and combining marks, or within a reordering
         * cluster.
         *
         * <p>ContextStart, contextEnd, and offset are relative to the start of
         * text.  The context is the shaping context for cursor movement, generally
         * the bounds of the metric span enclosing the cursor in the direction of
         * movement.
         *
         * <p>If cursorOpt is CURSOR_AT and the offset is not a valid
         * cursor position, this returns -1.  Otherwise this will never return a
         * value before contextStart or after contextStart + contextLength.
         *
         * @sa #CURSOR_AT
         *
         * @param text the text
         * @param contextStart the start of the context
         * @param contextLength the length of the context
         * @param flags either DIRECTION_RTL or DIRECTION_LTR
         *
         * @sa #DIRECTION_RTL
         * @sa #DIRECTION_LTR
         * @param offset the cursor position to move from
         * @param cursorOpt how to move the cursor, one of CURSOR_AFTER,
         * CURSOR_AT_OR_AFTER, CURSOR_BEFORE,
         * CURSOR_AT_OR_BEFORE, orCURSOR_AT
         *
         * @sa #CURSOR_AFTER
         * @sa #CURSOR_AT_OR_AFTER
         * @sa #CURSOR_BEFORE},
         * @sa #CURSOR_AT_OR_BEFORE
         * @sa #CURSOR_A
         * @return the offset of the next position, or -1
         * @hide
         */
        GetTextRunCursor(
            [in] String text,
            [in] Int32 contextStart,
            [in] Int32 contextEnd,
            [in] Int32 flags,
            [in] Int32 offset,
            [in] Int32 cursorOpt,
            [out] Int32* position);

        /**
         * Get the text Locale.
         *
         * @return the paint's Locale used for drawing text, never null.
         */
        GetTextLocale(
            [out] ILocale** result);

        /**
         * Return the path (outline) for the specified text.
         * Note: just like Canvas.drawText, this will respect the Align setting in
         * the paint.
         *
         * @param text     The text to retrieve the path from
         * @param index    The index of the first character in text
         * @param count    The number of characterss starting with index
         * @param x        The x coordinate of the text's origin
         * @param y        The y coordinate of the text's origin
         * @param path     The path to receive the data describing the text. Must
         *                 be allocated by the caller.
         */
        GetTextPath(
            [in] ArrayOf<Char32>* text,
            [in] Int32 index,
            [in] Int32 count,
            [in] Float x,
            [in] Float y,
            [in] IPath* path);

        /**
         * Return the path (outline) for the specified text.
         * Note: just like Canvas.drawText, this will respect the Align setting
         * in the paint.
         *
         * @param text  The text to retrieve the path from
         * @param start The first character in the text
         * @param end   1 past the last charcter in the text
         * @param x     The x coordinate of the text's origin
         * @param y     The y coordinate of the text's origin
         * @param path  The path to receive the data describing the text. Must
         *              be allocated by the caller.
         */
        GetTextPath(
            [in] String text,
            [in] Int32 start,
            [in] Int32 end,
            [in] Float x,
            [in] Float y,
            [in] IPath* path);

        /**
         * Return the paint's horizontal scale factor for text. The default value
         * is 1.0.
         *
         * @return the paint's scale factor in X for drawing/measuring text
         */
        GetTextScaleX(
            [out] Float* scaleX);

        /**
         * Return the paint's text size.
         *
         * @return the paint's text size.
         */
        GetTextSize(
            [out] Float* size);

        /**
         * Return the paint's horizontal skew factor for text. The default value
         * is 0.
         *
         * @return         the paint's skew factor in X for drawing text.
         */
        GetTextSkewX(
            [out] Float* skewX);

        /**
         * Return the advance widths for the characters in the string.
         *
         * @param text     The text to measure
         * @param index    The index of the first char to to measure
         * @param count    The number of chars starting with index to measure
         * @param widths   array to receive the advance widths of the characters.
         *                 Must be at least as large as count.
         * @return         the actual number of widths returned.
         */
        GetTextWidths(
            [in] ArrayOf<Char32>* text,
            [in] Int32 index,
            [in] Int32 count,
            [in] ArrayOf<Float>* widths,
            [out] Int32* number);

        /**
         * Return the advance widths for the characters in the string.
         *
         * @param text     The text to measure
         * @param start    The index of the first char to to measure
         * @param end      The end of the text slice to measure
         * @param widths   array to receive the advance widths of the characters.
         *                 Must be at least as large as (end - start).
         * @return         the actual number of widths returned.
         */
        GetTextWidths(
            [in] ICharSequence* text,
            [in] Int32 start,
            [in] Int32 end,
            [in] ArrayOf<Float>* widths,
            [out] Int32* count);

        /**
         * Return the advance widths for the characters in the string.
         *
         * @param text   The text to measure
         * @param start  The index of the first char to to measure
         * @param end    The end of the text slice to measure
         * @param widths array to receive the advance widths of the characters.
         *               Must be at least a large as the text.
         * @return       the number of unichars in the specified text.
         */
        GetTextWidths(
            [in] String text,
            [in] Int32 start,
            [in] Int32 end,
            [in] ArrayOf<Float>* widths,
            [out] Int32* count);

        /**
         * Return the advance widths for the characters in the string.
         *
         * @param text   The text to measure
         * @param widths array to receive the advance widths of the characters.
         *               Must be at least a large as the text.
         * @return       the number of unichars in the specified text.
         */
        GetTextWidths(
            [in] String text,
            [in] ArrayOf<Float>* widths,
            [out] Int32* width);

        /**
         * Get the paint's typeface object.
         * <p />
         * The typeface object identifies which font to use when drawing or
         * measuring text.
         *
         * @return the paint's typeface (or null)
         */
        GetTypeface(
            [out] ITypeface** typeface);

        /**
         * Get the paint's xfermode object.
         *
         * @return the paint's xfermode (or null)
         */
        GetXfermode(
            [out] IXfermode** xfermode);

        /**
         * Helper for getFlags(), returning true if ANTI_ALIAS_FLAG bit is set
         * AntiAliasing smooths out the edges of what is being drawn, but is has
         * no impact on the interior of the shape. See setDither() and
         * setFilterBitmap() to affect how colors are treated.
         *
         * @return true if the antialias bit is set in the paint's flags.
         */
        IsAntiAlias(
            [out] Boolean* isAntiAlias);

        /**
         * Helper for getFlags(), returning true if DITHER_FLAG bit is set
         * Dithering affects how colors that are higher precision than the device
         * are down-sampled. No dithering is generally faster, but higher precision
         * colors are just truncated down (e.g. 8888 -> 565). Dithering tries to
         * distribute the error inherent in this process, to reduce the visual
         * artifacts.
         *
         * @return true if the dithering bit is set in the paint's flags.
         */
        IsDither(
            [out] Boolean* isDither);

        /**
         * Helper for getFlags(), returning true if FAKE_BOLD_TEXT_FLAG bit is set
         *
         * @return true if the fakeBoldText bit is set in the paint's flags.
         */
        IsFakeBoldText(
            [out] Boolean* isFakeBoldText);

        /**
         * Whether or not the bitmap filter is activated.
         * Filtering affects the sampling of bitmaps when they are transformed.
         * Filtering does not affect how the colors in the bitmap are converted into
         * device pixels. That is dependent on dithering and xfermodes.
         *
         * @see #setFilterBitmap(boolean) setFilterBitmap()
         */
        IsFilterBitmap(
            [out] Boolean* isFilterBitmap);

        /**
         * Helper for getFlags(), returning true if LINEAR_TEXT_FLAG bit is set
         *
         * @return true if the lineartext bit is set in the paint's flags
         */
        IsLinearText(
            [out] Boolean* isLinearText);

        /**
         * Helper for getFlags(), returning true if STRIKE_THRU_TEXT_FLAG bit is set
         *
         * @return true if the strikeThruText bit is set in the paint's flags.
         */
        IsStrikeThruText(
            [out] Boolean* IsStrikeThruText);

        /**
         * Helper for getFlags(), returning true if SUBPIXEL_TEXT_FLAG bit is set
         *
         * @return true if the subpixel bit is set in the paint's flags
         */
        IsSubpixelText(
            [out] Boolean* isSubpixelText);

        /**
         * Helper for getFlags(), returning true if UNDERLINE_TEXT_FLAG bit is set
         *
         * @return true if the underlineText bit is set in the paint's flags.
         */
        IsUnderlineText(
            [out] Boolean* isUnderlineText);

        /**
         * Return the width of the text.
         *
         * @param text  The text to measure
         * @param index The index of the first character to start measuring
         * @param count THe number of characters to measure, beginning with start
         * @return      The width of the text
         */
        MeasureText(
            [in] ArrayOf<Char32>* text,
            [in] Int32 index,
            [in] Int32 count,
            [out] Float* width);

        /**
         * Return the width of the text.
         *
         * @param text  The text to measure
         * @param start The index of the first character to start measuring
         * @param end   1 beyond the index of the last character to measure
         * @return      The width of the text
         */
        MeasureText(
            [in] String text,
            [in] Int32 start,
            [in] Int32 end,
            [out] Float* width);

        /**
         * Return the width of the text.
         *
         * @param text  The text to measure
         * @return      The width of the text
         */
        MeasureText(
            [in] String text,
            [out] Float* width);

        /**
         * Return the width of the text.
         *
         * @param text  The text to measure
         * @param start The index of the first character to start measuring
         * @param end   1 beyond the index of the last character to measure
         * @return      The width of the text
         */
        MeasureText(
            [in] ICharSequence* text,
            [in] Int32 start,
            [in] Int32 end,
            [out] Float* width);

        /** Restores the paint to its default settings. */
        Reset();

        /**
         * Copy the fields from src into this paint. This is equivalent to calling
         * get() on all of the src fields, and calling the corresponding set()
         * methods on this.
         */
        Set(
            [in] IPaint* src);

        /**
         * Helper to setColor(), that takes a,r,g,b and constructs the color int
         *
         * @param a The new alpha component (0..255) of the paint's color.
         * @param r The new red component (0..255) of the paint's color.
         * @param g The new green component (0..255) of the paint's color.
         * @param b The new blue component (0..255) of the paint's color.
         */
        SetARGB(
            [in] Int32 a,
            [in] Int32 r,
            [in] Int32 g,
            [in] Int32 b);

        /**
         * Helper to setColor(), that only assigns the color's alpha value,
         * leaving its r,g,b values unchanged. Results are undefined if the alpha
         * value is outside of the range [0..255]
         *
         * @param a set the alpha component [0..255] of the paint's color.
         */
        SetAlpha(
            [in] Int32 a);

        /**
         * Helper for setFlags(), setting or clearing the ANTI_ALIAS_FLAG bit
         * AntiAliasing smooths out the edges of what is being drawn, but is has
         * no impact on the interior of the shape. See setDither() and
         * setFilterBitmap() to affect how colors are treated.
         *
         * @param aa true to set the antialias bit in the flags, false to clear it
         */
        SetAntiAlias(
            [in] Boolean aa);

        /**
         * Set the bidi flags on the paint.
         * @hide
         */
        SetBidiFlags(
            [in] Int32 flags);

        /**
         * Set the paint's color. Note that the color is an int containing alpha
         * as well as r,g,b. This 32bit value is not premultiplied, meaning that
         * its alpha can be any value, regardless of the values of r,g,b.
         * See the Color class for more details.
         *
         * @param color The new color (including alpha) to set in the paint.
         */
        SetColor(
            [in] Int32 color);

        /**
         * Set or clear the paint's colorfilter, returning the parameter.
         *
         * @param filter May be null. The new filter to be installed in the paint
         * @return       filter
         */
        SetColorFilter(
            [in] IColorFilter* filter);

        /** @hide */
        SetCompatibilityScaling(
            [in] Float factor);

        /**
         * Helper for setFlags(), setting or clearing the DITHER_FLAG bit
         * Dithering affects how colors that are higher precision than the device
         * are down-sampled. No dithering is generally faster, but higher precision
         * colors are just truncated down (e.g. 8888 -> 565). Dithering tries to
         * distribute the error inherent in this process, to reduce the visual
         * artifacts.
         *
         * @param dither true to set the dithering bit in flags, false to clear it
         */
        SetDither(
            [in] Boolean dither);

        /**
         * Helper for setFlags(), setting or clearing the STRIKE_THRU_TEXT_FLAG bit
         *
         * @param fakeBoldText true to set the fakeBoldText bit in the paint's
         *                     flags, false to clear it.
         */
        SetFakeBoldText(
            [in] Boolean fakeBoldText);

        /**
         * Helper for setFlags(), setting or clearing the FILTER_BITMAP_FLAG bit.
         * Filtering affects the sampling of bitmaps when they are transformed.
         * Filtering does not affect how the colors in the bitmap are converted into
         * device pixels. That is dependent on dithering and xfermodes.
         *
         * @param filter true to set the FILTER_BITMAP_FLAG bit in the paint's
         *               flags, false to clear it.
         */
        SetFilterBitmap(
            [in] Boolean filter);

        /**
         * Set the paint's flags. Use the Flag enum to specific flag values.
         *
         * @param flags The new flag bits for the paint
         */
        SetFlags(
            [in] Int32 flags);

        /**
         * Set the paint's hinting mode.  May be either
         * HINTING_OFF or HINTING_ON.
         *
         * @sa #HINTING_OFF
         * @sa #HINTING_ON
         */
        SetHinting(
            [in] Int32 mode);

        /**
         * Helper for setFlags(), setting or clearing the LINEAR_TEXT_FLAG bit
         *
         * @param linearText true to set the linearText bit in the paint's flags,
         *                   false to clear it.
         */
        SetLinearText(
            [in] Boolean linearText);

        /**
         * Set or clear the maskfilter object.
         * <p />
         * Pass null to clear any previous maskfilter.
         * As a convenience, the parameter passed is also returned.
         *
         * @param maskfilter May be null. The maskfilter to be installed in the
         *                   paint
         * @return           maskfilter
         */
        SetMaskFilter(
            [in] IMaskFilter* maskfilter);

        /**
         * Set or clear the patheffect object.
         * <p />
         * Pass null to clear any previous patheffect.
         * As a convenience, the parameter passed is also returned.
         *
         * @param effect May be null. The patheffect to be installed in the paint
         * @return       effect
         */
        SetPathEffect(
            [in] IPathEffect* effect);

        /**
         * Set or clear the rasterizer object.
         * <p />
         * Pass null to clear any previous rasterizer.
         * As a convenience, the parameter passed is also returned.
         *
         * @param rasterizer May be null. The new rasterizer to be installed in
         *                   the paint.
         * @return           rasterizer
         */
        SetRasterizer(
            [in] IRasterizer* rasterizer);

        /**
         * Set or clear the shader object.
         * <p />
         * Pass null to clear any previous shader.
         * As a convenience, the parameter passed is also returned.
         *
         * @param shader May be null. the new shader to be installed in the paint
         * @return       shader
         */
        SetShader(
            [in] IShader* shader);

        /**
         * Temporary API to expose layer drawing. This draws a shadow layer below
         * the main layer, with the specified offset and color, and blur radius.
         * If radius is 0, then the shadow layer is removed.
         */
        SetShadowLayer(
            [in] Float radius,
            [in] Float rdx,
            [in] Float rdy,
            [in] Int32 color);

        /**
         * Helper for setFlags(), setting or clearing the STRIKE_THRU_TEXT_FLAG bit
         *
         * @param strikeThruText true to set the strikeThruText bit in the paint's
         *                       flags, false to clear it.
         */
        SetStrikeThruText(
            [in] Boolean strikeThruText);

        /**
         * Set the paint's Cap.
         *
         * @param cap set the paint's line cap style, used whenever the paint's
         *            style is Stroke or StrokeAndFill.
         */
        SetStrokeCap(
            [in] PaintCap cap);

        /**
         * Set the paint's Join.
         *
         * @param join set the paint's Join, used whenever the paint's style is
         *             Stroke or StrokeAndFill.
         */
        SetStrokeJoin(
            [in] PaintJoin join);

        /**
         * Set the paint's stroke miter value. This is used to control the behavior
         * of miter joins when the joins angle is sharp. This value must be >= 0.
         *
         * @param miter set the miter limit on the paint, used whenever the paint's
         *              style is Stroke or StrokeAndFill.
         */
        SetStrokeMiter(
            [in] Float miter);

        /**
         * Set the width for stroking.
         * Pass 0 to stroke in hairline mode.
         * Hairlines always draws a single pixel independent of the canva's matrix.
         *
         * @param width set the paint's stroke width, used whenever the paint's
         *              style is Stroke or StrokeAndFill.
         */
        SetStrokeWidth(
            [in] Float width);

        /**
         * Set the paint's style, used for controlling how primitives'
         * geometries are interpreted (except for drawBitmap, which always assumes
         * Fill).
         *
         * @param style The new style to set in the paint
         */
        SetStyle(
            [in] PaintStyle style);

        /**
         * Helper for setFlags(), setting or clearing the SUBPIXEL_TEXT_FLAG bit
         *
         * @param subpixelText true to set the subpixelText bit in the paint's
         *                     flags, false to clear it.
         */
        SetSubpixelText(
            [in] Boolean subpixelText);

        /**
         * Set the paint's text alignment. This controls how the
         * text is positioned relative to its origin. LEFT align means that all of
         * the text will be drawn to the right of its origin (i.e. the origin
         * specifieds the LEFT edge of the text) and so on.
         *
         * @param align set the paint's Align value for drawing text.
         */
        SetTextAlign(
            [in] PaintAlign align);

        /**
         * Set the text locale.
         *
         * The text locale affects how the text is drawn for some languages.
         *
         * For example, if the locale is Locale#CHINESE or Locale#CHINA,
         * then the text renderer will prefer to draw text using a Chinese font. Likewise,
         *
         * @sa Locale#CHINESE
         * @sa Locale#CHINA
         * if the locale is Locale#JAPANESE or Locale#JAPAN, then the text
         * renderer will prefer to draw text using a Japanese font.
         *
         * @sa Locale#JAPANESE
         * @sa Locale#JAPAN
         *
         * This distinction is important because Chinese and Japanese text both use many
         * of the same Unicode code points but their appearance is subtly different for
         * each language.
         *
         * By default, the text locale is initialized to the system locale (as returned
         * by Locale#getDefault). This assumes that the text to be rendered will
         * most likely be in the user's preferred language.
         *
         * @sa Locale#getDefault
         *
         * If the actual language of the text is known, then it can be provided to the
         * text renderer using this method. The text renderer may attempt to guess the
         * language script based on the contents of the text to be drawn independent of
         * the text locale here. Specifying the text locale just helps it do a better
         * job in certain ambiguous cases
         *
         * @param locale the paint's locale value for drawing text, must not be null.
         */
        SetTextLocale(
            [in] ILocale* locale);

        /**
         * Get the elegant metrics flag.
         *
         * @return true if elegant metrics are enabled for text drawing.
         */
        IsElegantTextHeight(
            [out] Boolean* isElegantTextHeight);

        /**
         * Set the paint's elegant height metrics flag. This setting selects font
         * variants that have not been compacted to fit Latin-based vertical
         * metrics, and also increases top and bottom bounds to provide more space.
         *
         * @param elegant set the paint's elegant metrics flag for drawing text.
         */
        SetElegantTextHeight(
            [in] Boolean elegant);

        /**
         * Set the paint's horizontal scale factor for text. The default value
         * is 1.0. Values > 1.0 will stretch the text wider. Values < 1.0 will
         * stretch the text narrower.
         *
         * @param scaleX set the paint's scale in X for drawing/measuring text.
         */
        SetTextScaleX(
            [in] Float scaleX);

        /**
         * Set the paint's text size. This value must be > 0
         *
         * @param textSize set the paint's text size.
         */
        SetTextSize(
            [in] Float textSize);

        /**
         * Set the paint's horizontal skew factor for text. The default value
         * is 0. For approximating oblique text, use values around -0.25.
         *
         * @param skewX set the paint's skew factor in X for drawing text.
         */
        SetTextSkewX(
            [in] Float skewX);

        /**
         * Return the paint's letter-spacing for text. The default value
         * is 0.
         *
         * @return         the paint's letter-spacing for drawing text.
         */
        GetLetterSpacing(
            [out] Float* spacing);

        /**
         * Set the paint's letter-spacing for text. The default value
         * is 0.  The value is in 'EM' units.  Typical values for slight
         * expansion will be around 0.05.  Negative values tighten text.
         *
         * @param letterSpacing set the paint's letter-spacing for drawing text.
         */
        SetLetterSpacing(
            [in] Float letterSpacing);

        /**
         * Get font feature settings.  Default is null.
         *
         * @return the paint's currently set font feature settings.
         */
        GetFontFeatureSettings(
            [out] String* settings);

        /**
         * Set font feature settings.
         *
         * The format is the same as the CSS font-feature-settings attribute:
         * http://dev.w3.org/csswg/css-fonts/#propdef-font-feature-settings
         *
         * @param settings the font feature settings string to use, may be null.
         */
        SetFontFeatureSettings(
            [in] String settings);

        /**
         * Set or clear the typeface object.
         * <p />
         * Pass null to clear any previous typeface.
         * As a convenience, the parameter passed is also returned.
         *
         * @param typeface May be null. The typeface to be installed in the paint
         * @return         typeface
         */
        SetTypeface(
            [in] ITypeface* typeface);

        /**
         * Helper for setFlags(), setting or clearing the UNDERLINE_TEXT_FLAG bit
         *
         * @param underlineText true to set the underlineText bit in the paint's
         *                      flags, false to clear it.
         */
        SetUnderlineText(
            [in] Boolean underlineText);

        /**
         * Set or clear the xfermode object.
         * <p />
         * Pass null to clear any previous xfermode.
         * As a convenience, the parameter passed is also returned.
         *
         * @param xfermode May be null. The xfermode to be installed in the paint
         * @return         xfermode
         */
        SetXfermode(
            [in] IXfermode* xfermode);
    }

    } // namespace Graphics
    } // namespace Droid
    } // namespace Elastos
}
