//=========================================================================
// Copyright (C) 2012 The Elastos Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//=========================================================================

module
{
    interface Elastos.Droid.App.IPendingIntent;
    interface Elastos.Droid.Content.IContext;
    interface Elastos.Droid.Net.IConnectivityManagerNetworkCallback;
    interface Elastos.Droid.Net.IConnectivityManagerOnNetworkActiveListener;
    interface Elastos.Droid.Net.ILinkProperties;
    interface Elastos.Droid.Net.ILinkQualityInfo;
    interface Elastos.Droid.Net.INetworkCapabilities;
    interface Elastos.Droid.Net.INetworkInfo;
    interface Elastos.Droid.Net.INetworkMisc;
    interface Elastos.Droid.Net.INetworkQuotaInfo;
    interface Elastos.Droid.Net.INetworkRequest;
    interface Elastos.Droid.Net.IProxyInfo;
    interface Elastos.Droid.Os.IMessenger;

    using interface Elastos.Net.IInetAddress;
    using interface Elastos.Utility.IList;

    namespace Elastos {
    namespace Droid {
    namespace Net {

    /**
     * Class that answers queries about the state of network connectivity. It also
     * notifies applications when network connectivity changes. Get an instance
     * of this class by calling
     * {@link android.content.Context#getSystemService(String) Context.getSystemService(Context.CONNECTIVITY_SERVICE)}.
     * <p>
     * The primary responsibilities of this class are to:
     * <ol>
     * <li>Monitor network connections (Wi-Fi, GPRS, UMTS, etc.)</li>
     * <li>Send broadcast intents when network connectivity changes</li>
     * <li>Attempt to "fail over" to another network when connectivity to a network
     * is lost</li>
     * <li>Provide an API that allows applications to query the coarse-grained or fine-grained
     * state of the available networks</li>
     * <li>Provide an API that allows applications to request and select networks for their data
     * traffic</li>
     * </ol>
     */
    /**
     * @Involved
     * no super interface
     */
    interface IConnectivityManager {
        /**
         * A change in network connectivity has occurred. A default connection has either
         * been established or lost. The NetworkInfo for the affected network is
         * sent as an extra; it should be consulted to see what kind of
         * connectivity event occurred.
         * <p/>
         * If this is a connection that was the result of failing over from a
         * disconnected network, then the FAILOVER_CONNECTION boolean extra is
         * set to true.
         * <p/>
         * For a loss of connectivity, if the connectivity manager is attempting
         * to connect (or has already connected) to another network, the
         * NetworkInfo for the new network is also passed as an extra. This lets
         * any receivers of the broadcast know that they should not necessarily
         * tell the user that no data traffic will be possible. Instead, the
         * receiver should expect another broadcast soon, indicating either that
         * the failover attempt succeeded (and so there is still overall data
         * connectivity), or that the failover attempt failed, meaning that all
         * connectivity has been lost.
         * <p/>
         * For a disconnect event, the boolean extra EXTRA_NO_CONNECTIVITY
         * is set to {@code true} if there are no connected networks at all.
         */
        // @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String CONNECTIVITY_ACTION = "android.net.conn.CONNECTIVITY_CHANGE";

        /**
         * Identical to {@link #CONNECTIVITY_ACTION} broadcast, but sent without any
         * applicable {@link Settings.Global#CONNECTIVITY_CHANGE_DELAY}.
         *
         * @hide
         */
        // @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String CONNECTIVITY_ACTION_IMMEDIATE = "android.net.conn.CONNECTIVITY_CHANGE_IMMEDIATE";

        /**
         * The lookup key for a {@link NetworkInfo} object. Retrieve with
         * {@link android.content.Intent#getParcelableExtra(String)}.
         *
         * @deprecated Since {@link NetworkInfo} can vary based on UID, applications
         *             should always obtain network information through
         *             {@link #getActiveNetworkInfo()} or
         *             {@link #getAllNetworkInfo()}.
         * @see #EXTRA_NETWORK_TYPE
         */
        // @Deprecated
        const String EXTRA_NETWORK_INFO = "networkInfo";

        /**
         * Network type which triggered a {@link #CONNECTIVITY_ACTION} broadcast.
         * Can be used with {@link #getNetworkInfo(int)} to get {@link NetworkInfo}
         * state based on the calling application.
         *
         * @see android.content.Intent#getIntExtra(String, int)
         */
        const String EXTRA_NETWORK_TYPE = "networkType";

        /**
         * The lookup key for a boolean that indicates whether a connect event
         * is for a network to which the connectivity manager was failing over
         * following a disconnect on another network.
         * Retrieve it with {@link android.content.Intent#getBooleanExtra(String,boolean)}.
         */
        const String EXTRA_IS_FAILOVER = "isFailover";

        /**
         * The lookup key for a {@link NetworkInfo} object. This is supplied when
         * there is another network that it may be possible to connect to. Retrieve with
         * {@link android.content.Intent#getParcelableExtra(String)}.
         */
        const String EXTRA_OTHER_NETWORK_INFO = "otherNetwork";

        /**
         * The lookup key for a boolean that indicates whether there is a
         * complete lack of connectivity, i.e., no network is available.
         * Retrieve it with {@link android.content.Intent#getBooleanExtra(String,boolean)}.
         */
        const String EXTRA_NO_CONNECTIVITY = "noConnectivity";

        /**
         * The lookup key for a string that indicates why an attempt to connect
         * to a network failed. The string has no particular structure. It is
         * intended to be used in notifications presented to users. Retrieve
         * it with {@link android.content.Intent#getStringExtra(String)}.
         */
        const String EXTRA_REASON = "reason";

        /**
         * The lookup key for a string that provides optionally supplied
         * extra information about the network state. The information
         * may be passed up from the lower networking layers, and its
         * meaning may be specific to a particular network type. Retrieve
         * it with {@link android.content.Intent#getStringExtra(String)}.
         */
        const String EXTRA_EXTRA_INFO = "extraInfo";

        /**
         * The lookup key for an int that provides information about
         * our connection to the internet at large.  0 indicates no connection,
         * 100 indicates a great connection.  Retrieve it with
         * {@link android.content.Intent#getIntExtra(String, int)}.
         * {@hide}
         */
        const String EXTRA_INET_CONDITION = "inetCondition";

        /**
         * Broadcast action to indicate the change of data activity status
         * (idle or active) on a network in a recent period.
         * The network becomes active when data transmission is started, or
         * idle if there is no data transmission for a period of time.
         * {@hide}
         */
        // @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_DATA_ACTIVITY_CHANGE = "android.net.conn.DATA_ACTIVITY_CHANGE";

        /**
         * The lookup key for an enum that indicates the network device type on which this data activity
         * change happens.
         * {@hide}
         */
        const String EXTRA_DEVICE_TYPE = "deviceType";

        /**
         * The lookup key for a boolean that indicates the device is active or not. {@code true} means
         * it is actively sending or receiving data and {@code false} means it is idle.
         * {@hide}
         */
        const String EXTRA_IS_ACTIVE = "isActive";

        /**
         * The lookup key for a long that contains the timestamp (nanos) of the radio state change.
         * {@hide}
         */
        const String EXTRA_REALTIME_NS = "tsNanos";

        /**
         * Broadcast Action: The setting for background data usage has changed
         * values. Use {@link #getBackgroundDataSetting()} to get the current value.
         * <p>
         * If an application uses the network in the background, it should listen
         * for this broadcast and stop using the background data if the value is
         * {@code false}.
         * <p>
         *
         * @deprecated As of {@link VERSION_CODES#ICE_CREAM_SANDWICH}, availability
         *             of background data depends on several combined factors, and
         *             this broadcast is no longer sent. Instead, when background
         *             data is unavailable, {@link #getActiveNetworkInfo()} will now
         *             appear disconnected. During first boot after a platform
         *             upgrade, this broadcast will be sent once if
         *             {@link #getBackgroundDataSetting()} was {@code false} before
         *             the upgrade.
         */
        // @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        // @Deprecated
        const String ACTION_BACKGROUND_DATA_SETTING_CHANGED = "android.net.conn.BACKGROUND_DATA_SETTING_CHANGED";

        /**
         * Broadcast Action: The network connection may not be good
         * uses {@code ConnectivityManager.EXTRA_INET_CONDITION} and
         * {@code ConnectivityManager.EXTRA_NETWORK_INFO} to specify
         * the network and it's condition.
         * @hide
         */
        // @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String INET_CONDITION_ACTION = "android.net.conn.INET_CONDITION_ACTION";

        /**
         * Broadcast Action: A tetherable connection has come or gone.
         * Uses {@code ConnectivityManager.EXTRA_AVAILABLE_TETHER},
         * {@code ConnectivityManager.EXTRA_ACTIVE_TETHER} and
         * {@code ConnectivityManager.EXTRA_ERRORED_TETHER} to indicate
         * the current state of tethering.  Each include a list of
         * interface names in that state (may be empty).
         * @hide
         */
        // @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_TETHER_STATE_CHANGED = "android.net.conn.TETHER_STATE_CHANGED";

        /**
         * Broadcast intent action indicating that a Station is connected
         * or disconnected.
         *
         * @hide
         */
        const String TETHER_CONNECT_STATE_CHANGED = "android.net.conn.TETHER_CONNECT_STATE_CHANGED";

        /**
         * @hide
         * gives a String[] listing all the interfaces configured for
         * tethering and currently available for tethering.
         */
        const String EXTRA_AVAILABLE_TETHER = "availableArray";

        /**
         * @hide
         * gives a String[] listing all the interfaces currently tethered
         * (ie, has dhcp support and packets potentially forwarded/NATed)
         */
        const String EXTRA_ACTIVE_TETHER = "activeArray";

        /**
         * @hide
         * gives a String[] listing all the interfaces we tried to tether and
         * failed.  Use {@link #getLastTetherError} to find the error code
         * for any interfaces listed here.
         */
        const String EXTRA_ERRORED_TETHER = "erroredArray";

        /**
         * Broadcast Action: The captive portal tracker has finished its test.
         * Sent only while running Setup Wizard, in lieu of showing a user
         * notification.
         * @hide
         */
        // @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_CAPTIVE_PORTAL_TEST_COMPLETED = "android.net.conn.CAPTIVE_PORTAL_TEST_COMPLETED";

        /**
         * The lookup key for a boolean that indicates whether a captive portal was detected.
         * Retrieve it with {@link android.content.Intent#getBooleanExtra(String,boolean)}.
         * @hide
         */
        const String EXTRA_IS_CAPTIVE_PORTAL = "captivePortal";

        /**
         * The absence of a connection type.
         * @hide
         */
        const Int32 TYPE_NONE = -1;

        /**
         * The Mobile data connection.  When active, all data traffic
         * will use this network type's interface by default
         * (it has a default route)
         */
        const Int32 TYPE_MOBILE = 0;

        /**
         * The WIFI data connection.  When active, all data traffic
         * will use this network type's interface by default
         * (it has a default route).
         */
        const Int32 TYPE_WIFI = 1;

        /**
         * An MMS-specific Mobile data connection.  This network type may use the
         * same network interface as {@link #TYPE_MOBILE} or it may use a different
         * one.  This is used by applications needing to talk to the carrier's
         * Multimedia Messaging Service servers.
         */
        const Int32 TYPE_MOBILE_MMS = 2;

        /**
         * A SUPL-specific Mobile data connection.  This network type may use the
         * same network interface as {@link #TYPE_MOBILE} or it may use a different
         * one.  This is used by applications needing to talk to the carrier's
         * Secure User Plane Location servers for help locating the device.
         */
        const Int32 TYPE_MOBILE_SUPL = 3;

        /**
         * A DUN-specific Mobile data connection.  This network type may use the
         * same network interface as {@link #TYPE_MOBILE} or it may use a different
         * one.  This is sometimes by the system when setting up an upstream connection
         * for tethering so that the carrier is aware of DUN traffic.
         */
        const Int32 TYPE_MOBILE_DUN = 4;

        /**
         * A High Priority Mobile data connection.  This network type uses the
         * same network interface as {@link #TYPE_MOBILE} but the routing setup
         * is different.  Only requesting processes will have access to the
         * Mobile DNS servers and only IP's explicitly requested via {@link #requestRouteToHost}
         * will route over this interface if no default route exists.
         */
        const Int32 TYPE_MOBILE_HIPRI = 5;

        /**
         * The WiMAX data connection.  When active, all data traffic
         * will use this network type's interface by default
         * (it has a default route).
         */
        const Int32 TYPE_WIMAX = 6;

        /**
         * The Bluetooth data connection.  When active, all data traffic
         * will use this network type's interface by default
         * (it has a default route).
         */
        const Int32 TYPE_BLUETOOTH = 7;

        /**
         * Dummy data connection.  This should not be used on shipping devices.
         */
        const Int32 TYPE_DUMMY = 8;

        /**
         * The Ethernet data connection.  When active, all data traffic
         * will use this network type's interface by default
         * (it has a default route).
         */
        const Int32 TYPE_ETHERNET = 9;

        /**
         * Over the air Administration.
         * {@hide}
         */
        const Int32 TYPE_MOBILE_FOTA = 10;

        /**
         * IP Multimedia Subsystem.
         * {@hide}
         */
        const Int32 TYPE_MOBILE_IMS = 11;

        /**
         * Carrier Branded Services.
         * {@hide}
         */
        const Int32 TYPE_MOBILE_CBS = 12;

        /**
         * A Wi-Fi p2p connection. Only requesting processes will have access to
         * the peers connected.
         * {@hide}
         */
        const Int32 TYPE_WIFI_P2P = 13;

        /**
         * The network to use for initially attaching to the network
         * {@hide}
         */
        const Int32 TYPE_MOBILE_IA = 14;

        /**
         * Emergency PDN connection for emergency calls
         * {@hide}
         */
        const Int32 TYPE_MOBILE_EMERGENCY = 15;

        /**
         * The network that uses proxy to achieve connectivity.
         * {@hide}
         */
        const Int32 TYPE_PROXY = 16;

        /**
         * A virtual network using one or more native bearers.
         * It may or may not be providing security services.
         */
        const Int32 TYPE_VPN = 17;

        /** {@hide} */
        const Int32 MAX_RADIO_TYPE = TYPE_VPN;

        /** {@hide} */
        const Int32 MAX_NETWORK_TYPE = TYPE_VPN;

        /**
         * If you want to set the default network preference,you can directly
         * change the networkAttributes array in framework's config.xml.
         *
         * @deprecated Since we support so many more networks now, the single
         *             network default network preference can't really express
         *             the hierarchy.  Instead, the default is defined by the
         *             networkAttributes in config.xml.  You can determine
         *             the current value by calling {@link #getNetworkPreference()}
         *             from an App.
         */
        // @Deprecated
        const Int32 DEFAULT_NETWORK_PREFERENCE = TYPE_WIFI;

        /**
         * Default value for {@link Settings.Global#CONNECTIVITY_CHANGE_DELAY} in
         * milliseconds.  This was introduced because IPv6 routes seem to take a
         * moment to settle - trying network activity before the routes are adjusted
         * can lead to packets using the wrong interface or having the wrong IP address.
         * This delay is a bit crude, but in the future hopefully we will have kernel
         * notifications letting us know when it's safe to use the new network.
         *
         * @hide
         */
        const Int32 CONNECTIVITY_CHANGE_DELAY_DEFAULT = 3000;

        /**
         * @hide
         */
        const Int32 REQUEST_ID_UNSET = 0;

        /**
         * A NetID indicating no Network is selected.
         * Keep in sync with bionic/libc/dns/include/resolv_netid.h
         * @hide
         */
        const Int32 NETID_UNSET = 0;

        /** {@hide} */
        const Int32 TETHER_ERROR_NO_ERROR = 0;

        /** {@hide} */
        const Int32 TETHER_ERROR_UNKNOWN_IFACE = 1;

        /** {@hide} */
        const Int32 TETHER_ERROR_SERVICE_UNAVAIL = 2;

        /** {@hide} */
        const Int32 TETHER_ERROR_UNSUPPORTED = 3;

        /** {@hide} */
        const Int32 TETHER_ERROR_UNAVAIL_IFACE = 4;

        /** {@hide} */
        const Int32 TETHER_ERROR_MASTER_ERROR = 5;

        /** {@hide} */
        const Int32 TETHER_ERROR_TETHER_IFACE_ERROR = 6;

        /** {@hide} */
        const Int32 TETHER_ERROR_UNTETHER_IFACE_ERROR = 7;

        /** {@hide} */
        const Int32 TETHER_ERROR_ENABLE_NAT_ERROR = 8;

        /** {@hide} */
        const Int32 TETHER_ERROR_DISABLE_NAT_ERROR = 9;

        /** {@hide} */
        const Int32 TETHER_ERROR_IFACE_CFG_ERROR = 10;

        /** @hide obj = pair(NetworkRequest, Network) */
        const Int32 CALLBACK_PRECHECK = 0x00080001;

        /** @hide obj = pair(NetworkRequest, Network) */
        const Int32 CALLBACK_AVAILABLE = 0x00080002;

        /** @hide obj = pair(NetworkRequest, Network), arg1 = ttl */
        const Int32 CALLBACK_LOSING = 0x00080003;

        /** @hide obj = pair(NetworkRequest, Network) */
        const Int32 CALLBACK_LOST = 0x00080004;

        /** @hide obj = NetworkRequest */
        const Int32 CALLBACK_UNAVAIL = 0x00080005;

        /** @hide obj = pair(NetworkRequest, Network) */
        const Int32 CALLBACK_CAP_CHANGED = 0x00080006;

        /** @hide obj = pair(NetworkRequest, Network) */
        const Int32 CALLBACK_IP_CHANGED = 0x00080007;

        /** @hide obj = NetworkRequest */
        const Int32 CALLBACK_RELEASED = 0x00080008;

        /** @hide */
        const Int32 CALLBACK_EXIT = 0x00080009;

        /**
         * The maximum number of milliseconds the framework will look for a suitable network
         * during a timeout-equiped call to {@link requestNetwork}.
         * {@hide}
         */
        const Int32 MAX_NETWORK_REQUEST_TIMEOUT_MS = 100 * 60 * 1000;

        /**
         * The lookup key for a {@link Network} object included with the intent after
         * succesfully finding a network for the applications request.  Retrieve it with
         * {@link android.content.Intent#getParcelableExtra(String)}.
         * @hide
         */
        const String EXTRA_NETWORK_REQUEST_NETWORK = "networkRequestNetwork";

        /**
         * The lookup key for a {@link NetworkRequest} object included with the intent after
         * succesfully finding a network for the applications request.  Retrieve it with
         * {@link android.content.Intent#getParcelableExtra(String)}.
         * @hide
         */
        const String EXTRA_NETWORK_REQUEST_NETWORK_REQUEST = "networkRequestNetworkRequest";

        /**
         * Specifies the preferred network type.  When the device has more
         * than one type available the preferred network type will be used.
         *
         * @param preference the network type to prefer over all others.  It is
         *         unspecified what happens to the old preferred network in the
         *         overall ordering.
         * @deprecated Functionality has been removed as it no longer makes sense,
         *             with many more than two networks - we'd need an array to express
         *             preference.  Instead we use dynamic network properties of
         *             the networks to describe their precedence.
         */
        SetNetworkPreference(
            [in] Int32 preference);

        /**
         * Retrieves the current preferred network type.
         *
         * @return an integer representing the preferred network type
         *
         * <p>This method requires the caller to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         * @deprecated Functionality has been removed as it no longer makes sense,
         *             with many more than two networks - we'd need an array to express
         *             preference.  Instead we use dynamic network properties of
         *             the networks to describe their precedence.
         */
        GetNetworkPreference(
            [out] Int32* result);

        /**
         * Returns details about the currently active default data network. When
         * connected, this network is the default route for outgoing connections.
         * You should always check {@link NetworkInfo#isConnected()} before initiating
         * network traffic. This may return {@code null} when there is no default
         * network.
         *
         * @return a {@link NetworkInfo} object for the current default network
         *        or {@code null} if no network default network is currently active
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         */
        GetActiveNetworkInfo(
            [out] INetworkInfo** result);

        /**
         * Returns details about the currently active default data network
         * for a given uid.  This is for internal use only to avoid spying
         * other apps.
         *
         * @return a {@link NetworkInfo} object for the current default network
         *        for the given uid or {@code null} if no default network is
         *        available for the specified uid.
         *
         * <p>This method requires the caller to hold the permission
         * {@link android.Manifest.permission#CONNECTIVITY_INTERNAL}
         * {@hide}
         */
        GetActiveNetworkInfoForUid(
            [in] Int32 uid,
            [out] INetworkInfo** result);

        /**
         * Returns connection status information about a particular
         * network type.
         *
         * @param networkType integer specifying which networkType in
         *        which you're interested.
         * @return a {@link NetworkInfo} object for the requested
         *        network type or {@code null} if the type is not
         *        supported by the device.
         *
         * <p>This method requires the caller to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         */
        GetNetworkInfo(
            [in] Int32 networkType,
            [out] INetworkInfo** result);

        /**
         * Returns connection status information about a particular
         * Network.
         *
         * @param network {@link Network} specifying which network
         *        in which you're interested.
         * @return a {@link NetworkInfo} object for the requested
         *        network or {@code null} if the {@code Network}
         *        is not valid.
         *
         * <p>This method requires the caller to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         */
        GetNetworkInfo(
            [in] INetwork* network,
            [out] INetworkInfo** result);

        /**
         * Returns connection status information about all network
         * types supported by the device.
         *
         * @return an array of {@link NetworkInfo} objects.  Check each
         * {@link NetworkInfo#getType} for which type each applies.
         *
         * <p>This method requires the caller to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         */
        GetAllNetworkInfo(
            [out, callee] ArrayOf<INetworkInfo*>* result);

        /**
         * Returns the {@link Network} object currently serving a given type, or
         * null if the given type is not connected.
         *
         * <p>This method requires the caller to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         *
         * @hide
         */
        GetNetworkForType(
            [in] Int32 networkType,
            [out] INetwork** result);

        /**
         * Returns an array of all {@link Network} currently tracked by the
         * framework.
         *
         * @return an array of {@link Network} objects.
         *
         * <p>This method requires the caller to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         */
        GetAllNetworks(
            [out, callee] ArrayOf<INetwork*>* result);

        /**
         * Returns details about the Provisioning or currently active default data network. When
         * connected, this network is the default route for outgoing connections.
         * You should always check {@link NetworkInfo#isConnected()} before initiating
         * network traffic. This may return {@code null} when there is no default
         * network.
         *
         * @return a {@link NetworkInfo} object for the current default network
         *        or {@code null} if no network default network is currently active
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         *
         * {@hide}
         */
        GetProvisioningOrActiveNetworkInfo(
            [out] INetworkInfo** result);

        /**
         * Returns the IP information for the current default network.
         *
         * @return a {@link LinkProperties} object describing the IP info
         *        for the current default network, or {@code null} if there
         *        is no current default network.
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         * {@hide}
         */
        GetActiveLinkProperties(
            [out] ILinkProperties** result);

        /**
         * Returns the IP information for a given network type.
         *
         * @param networkType the network type of interest.
         * @return a {@link LinkProperties} object describing the IP info
         *        for the given networkType, or {@code null} if there is
         *        no current default network.
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         * {@hide}
         */
        GetLinkProperties(
            [in] Int32 networkType,
            [out] ILinkProperties** result);

        /**
         * Get the {@link LinkProperties} for the given {@link Network}.  This
         * will return {@code null} if the network is unknown.
         *
         * @param network The {@link Network} object identifying the network in question.
         * @return The {@link LinkProperties} for the network, or {@code null}.
        **/
        GetLinkProperties(
            [in] INetwork* network,
            [out] ILinkProperties** result);

        /**
         * Get the {@link NetworkCapabilities} for the given {@link Network}.  This
         * will return {@code null} if the network is unknown.
         *
         * @param network The {@link Network} object identifying the network in question.
         * @return The {@link NetworkCapabilities} for the network, or {@code null}.
         */
        GetNetworkCapabilities(
            [in] INetwork* network,
            [out] INetworkCapabilities** result);

        /**
         * Tells the underlying networking system that the caller wants to
         * begin using the named feature. The interpretation of {@code feature}
         * is completely up to each networking implementation.
         * <p>This method requires the caller to hold the permission
         * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
         * @param networkType specifies which network the request pertains to
         * @param feature the name of the feature to be used
         * @return an integer value representing the outcome of the request.
         * The interpretation of this value is specific to each networking
         * implementation+feature combination, except that the value {@code -1}
         * always indicates failure.
         *
         * @deprecated Deprecated in favor of the cleaner {@link #requestNetwork} api.
         */
        StartUsingNetworkFeature(
            [in] Int32 networkType,
            [in] String feature,
            [out] Int32* result);

        /**
         * Tells the underlying networking system that the caller wants to
         * begin using the named feature. The interpretation of {@code feature}
         * is completely up to each networking implementation.
         * <p>This method requires the caller to hold the permission
         * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
         * @param networkType specifies which network the request pertains to
         * @param feature the name of the feature to be used
         * @param subId the subscription the network is requested
         * @return an integer value representing the outcome of the request.
         * The interpretation of this value is specific to each networking
         * implementation+feature combination, except that the value {@code -1}
         * always indicates failure.
         *
         * @hide
         */
        StartUsingNetworkFeatureForSubscription(
            [in] Int32 networkType,
            [in] String feature,
            [in] String subId,
            [out] Int32* result);

        /**
         * Tells the underlying networking system that the caller is finished
         * using the named feature. The interpretation of {@code feature}
         * is completely up to each networking implementation.
         * <p>This method requires the caller to hold the permission
         * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
         * @param networkType specifies which network the request pertains to
         * @param feature the name of the feature that is no longer needed
         * @return an integer value representing the outcome of the request.
         * The interpretation of this value is specific to each networking
         * implementation+feature combination, except that the value {@code -1}
         * always indicates failure.
         *
         * @deprecated Deprecated in favor of the cleaner {@link #requestNetwork} api.
         */
        StopUsingNetworkFeature(
            [in] Int32 networkType,
            [in] String feature,
            [out] Int32* result);

        /**
         * Tells the underlying networking system that the caller is finished
         * using the named feature. The interpretation of {@code feature}
         * is completely up to each networking implementation.
         * <p>This method requires the caller to hold the permission
         * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
         * @param networkType specifies which network the request pertains to
         * @param feature the name of the feature that is no longer needed
         * @param subId the subscription the network is requested
         * @return an integer value representing the outcome of the request.
         * The interpretation of this value is specific to each networking
         * implementation+feature combination, except that the value {@code -1}
         * always indicates failure.
         *
         * @hide
         */
        StopUsingNetworkFeatureForSubscription(
            [in] Int32 networkType,
            [in] String feature,
            [in] String subId,
            [out] Int32* result);

        /**
         * Ensure that a network route exists to deliver traffic to the specified
         * host via the specified network interface. An attempt to add a route that
         * already exists is ignored, but treated as successful.
         * <p>This method requires the caller to hold the permission
         * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
         * @param networkType the type of the network over which traffic to the specified
         * host is to be routed
         * @param hostAddress the IP address of the host to which the route is desired
         * @return {@code true} on success, {@code false} on failure
         *
         * @deprecated Deprecated in favor of the {@link #requestNetwork},
         *             {@link #setProcessDefaultNetwork} and {@link Network#getSocketFactory} api.
         */
        RequestRouteToHost(
            [in] Int32 networkType,
            [in] Int32 hostAddress,
            [out] Boolean* result);

        /**
         * Ensure that a network route exists to deliver traffic to the specified
         * host via the specified network interface. An attempt to add a route that
         * already exists is ignored, but treated as successful.
         * <p>This method requires the caller to hold the permission
         * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
         * @param networkType the type of the network over which traffic to the specified
         * host is to be routed
         * @param hostAddress the IP address of the host to which the route is desired
         * @return {@code true} on success, {@code false} on failure
         * @hide
         * @deprecated Deprecated in favor of the {@link #requestNetwork} and
         *             {@link #setProcessDefaultNetwork} api.
         */
        RequestRouteToHostAddress(
            [in] Int32 networkType,
            [in] IInetAddress* hostAddress,
            [out] Boolean* result);

        /**
         * Returns the value of the setting for background data usage. If false,
         * applications should not use the network if the application is not in the
         * foreground. Developers should respect this setting, and check the value
         * of this before performing any background data operations.
         * <p>
         * All applications that have background services that use the network
         * should listen to {@link #ACTION_BACKGROUND_DATA_SETTING_CHANGED}.
         * <p>
         * @deprecated As of {@link VERSION_CODES#ICE_CREAM_SANDWICH}, availability of
         * background data depends on several combined factors, and this method will
         * always return {@code true}. Instead, when background data is unavailable,
         * {@link #getActiveNetworkInfo()} will now appear disconnected.
         *
         * @return Whether background data usage is allowed.
         */
        // @Deprecated
        GetBackgroundDataSetting(
            [out] Boolean* result);

        /**
         * Sets the value of the setting for background data usage.
         *
         * @param allowBackgroundData Whether an application should use data while
         *            it is in the background.
         *
         * @attr ref android.Manifest.permission#CHANGE_BACKGROUND_DATA_SETTING
         * @see #getBackgroundDataSetting()
         * @hide
         */
        // @Deprecated
        SetBackgroundDataSetting(
            [in] Boolean allowBackgroundData);

        /**
         * Return quota status for the current active network, or {@code null} if no
         * network is active. Quota status can change rapidly, so these values
         * shouldn't be cached.
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         *
         * @hide
         */
        GetActiveNetworkQuotaInfo(
            [out] INetworkQuotaInfo** result);

        /**
         * @hide
         * @deprecated Talk to TelephonyManager directly
         */
        GetMobileDataEnabled(
            [out] Boolean* result);

        /**
         * Start listening to reports when the system's default data network is active, meaning it is
         * a good time to perform network traffic.  Use {@link #isDefaultNetworkActive()}
         * to determine the current state of the system's default network after registering the
         * listener.
         * <p>
         * If the process default network has been set with
         * {@link ConnectivityManager#setProcessDefaultNetwork} this function will not
         * reflect the process's default, but the system default.
         *
         * @param l The listener to be told when the network is active.
         */
        AddDefaultNetworkActiveListener(
            [in] IConnectivityManagerOnNetworkActiveListener* l);

        /**
         * Remove network active listener previously registered with
         * {@link #addDefaultNetworkActiveListener}.
         *
         * @param l Previously registered listener.
         */
        RemoveDefaultNetworkActiveListener(
            [in] IConnectivityManagerOnNetworkActiveListener* l);

        /**
         * Return whether the data network is currently active.  An active network means that
         * it is currently in a high power state for performing data transmission.  On some
         * types of networks, it may be expensive to move and stay in such a state, so it is
         * more power efficient to batch network traffic together when the radio is already in
         * this state.  This method tells you whether right now is currently a good time to
         * initiate network traffic, as the network is already active.
         */
        IsDefaultNetworkActive(
            [out] Boolean* result);

        /**
         * Get the set of tetherable, available interfaces.  This list is limited by
         * device configuration and current interface existence.
         *
         * @return an array of 0 or more Strings of tetherable interface names.
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         * {@hide}
         */
        GetTetherableIfaces(
            [out, callee] ArrayOf<String>* result);

        /**
         * Get the set of tethered interfaces.
         *
         * @return an array of 0 or more String of currently tethered interface names.
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         * {@hide}
         */
        GetTetheredIfaces(
            [out, callee] ArrayOf<String>* result);

        /**
         * Get the set of interface names which attempted to tether but
         * failed.  Re-attempting to tether may cause them to reset to the Tethered
         * state.  Alternatively, causing the interface to be destroyed and recreated
         * may cause them to reset to the available state.
         * {@link ConnectivityManager#getLastTetherError} can be used to get more
         * information on the cause of the errors.
         *
         * @return an array of 0 or more String indicating the interface names
         *        which failed to tether.
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         * {@hide}
         */
        GetTetheringErroredIfaces(
            [out, callee] ArrayOf<String>* result);

        /**
         * Get the set of tethered dhcp ranges.
         *
         * @return an array of 0 or more {@code String} of tethered dhcp ranges.
         * {@hide}
         */
        GetTetheredDhcpRanges(
            [out, callee] ArrayOf<String>* result);

        /**
         * Attempt to tether the named interface.  This will setup a dhcp server
         * on the interface, forward and NAT IP packets and forward DNS requests
         * to the best active upstream network interface.  Note that if no upstream
         * IP network interface is available, dhcp will still run and traffic will be
         * allowed between the tethered devices and this device, though upstream net
         * access will of course fail until an upstream network interface becomes
         * active.
         *
         * @param iface the interface name to tether.
         * @return error a {@code TETHER_ERROR} value indicating success or failure type
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
         * {@hide}
         */
        Tether(
            [in] String iface,
            [out] Int32* result);

        /**
         * Stop tethering the named interface.
         *
         * @param iface the interface name to untether.
         * @return error a {@code TETHER_ERROR} value indicating success or failure type
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
         * {@hide}
         */
        Untether(
            [in] String iface,
            [out] Int32* result);

        /**
         * Check if the device allows for tethering.  It may be disabled via
         * {@code ro.tether.denied} system property, Settings.TETHER_SUPPORTED or
         * due to device configuration.
         *
         * @return a boolean - {@code true} indicating Tethering is supported.
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         * {@hide}
         */
        IsTetheringSupported(
            [out] Boolean* result);

        /**
         * Get the list of regular expressions that define any tetherable
         * USB network interfaces.  If USB tethering is not supported by the
         * device, this list should be empty.
         *
         * @return an array of 0 or more regular expression Strings defining
         *        what interfaces are considered tetherable usb interfaces.
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         * {@hide}
         */
        GetTetherableUsbRegexs(
            [out, callee] ArrayOf<String>* result);

        /**
         * Get the list of regular expressions that define any tetherable
         * Wifi network interfaces.  If Wifi tethering is not supported by the
         * device, this list should be empty.
         *
         * @return an array of 0 or more regular expression Strings defining
         *        what interfaces are considered tetherable wifi interfaces.
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         * {@hide}
         */
        GetTetherableWifiRegexs(
            [out, callee] ArrayOf<String>* result);

        /**
         * Get the list of regular expressions that define any tetherable
         * Bluetooth network interfaces.  If Bluetooth tethering is not supported by the
         * device, this list should be empty.
         *
         * @return an array of 0 or more regular expression Strings defining
         *        what interfaces are considered tetherable bluetooth interfaces.
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         * {@hide}
         */
        GetTetherableBluetoothRegexs(
            [out, callee] ArrayOf<String>* result);

        /**
         * Attempt to both alter the mode of USB and Tethering of USB.  A
         * utility method to deal with some of the complexity of USB - will
         * attempt to switch to Rndis and subsequently tether the resulting
         * interface on {@code true} or turn off tethering and switch off
         * Rndis on {@code false}.
         *
         * @param enable a boolean - {@code true} to enable tethering
         * @return error a {@code TETHER_ERROR} value indicating success or failure type
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
         * {@hide}
         */
        SetUsbTethering(
            [in] Boolean enabled,
            [out] Int32* result);

        /**
         * Get the list of Stations connected to Hotspot.
         *
         * @return a list of {@link WifiDevice} objects.
         * {@hide}
         */
        GetTetherConnectedSta(
            [out] IList** wifiDevices);

        /**
         * Get a more detailed error code after a Tethering or Untethering
         * request asynchronously failed.
         *
         * @param iface The name of the interface of interest
         * @return error The error code of the last error tethering or untethering the named
         *               interface
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         * {@hide}
         */
        GetLastTetherError(
            [in] String iface,
            [out] Int32* result);

        /**
         * Report network connectivity status.  This is currently used only
         * to alter status bar UI.
         *
         * @param networkType The type of network you want to report on
         * @param percentage The quality of the connection 0 is bad, 100 is good
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#STATUS_BAR}.
         * {@hide}
         */
        ReportInetCondition(
            [in] Int32 networkType,
            [in] Int32 percentage);

        /**
         * Report a problem network to the framework.  This provides a hint to the system
         * that there might be connectivity problems on this network and may cause
         * the framework to re-evaluate network connectivity and/or switch to another
         * network.
         *
         * @param network The {@link Network} the application was attempting to use
         *                or {@code null} to indicate the current default network.
         */
        ReportBadNetwork(
            [in] INetwork* network);

        /**
         * Set a network-independent global http proxy.  This is not normally what you want
         * for typical HTTP proxies - they are general network dependent.  However if you're
         * doing something unusual like general internal filtering this may be useful.  On
         * a private network where the proxy is not accessible, you may break HTTP using this.
         *
         * @param p The a {@link ProxyInfo} object defining the new global
         *        HTTP proxy.  A {@code null} value will clear the global HTTP proxy.
         *
         * <p>This method requires the call to hold the permission
         * android.Manifest.permission#CONNECTIVITY_INTERNAL.
         * @hide
         */
        SetGlobalProxy(
            [in] IProxyInfo* p);

        /**
         * Retrieve any network-independent global HTTP proxy.
         *
         * @return {@link ProxyInfo} for the current global HTTP proxy or {@code null}
         *        if no global HTTP proxy is set.
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         * @hide
         */
        GetGlobalProxy(
            [out] IProxyInfo** result);

        /**
         * Get the HTTP proxy settings for the current default network.  Note that
         * if a global proxy is set, it will override any per-network setting.
         *
         * @return the {@link ProxyInfo} for the current HTTP proxy, or {@code null} if no
         *        HTTP proxy is active.
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         * {@hide}
         * @deprecated Deprecated in favor of {@link #getLinkProperties}
         */
        GetProxy(
            [out] IProxyInfo** result);

        /**
         * Sets a secondary requirement bit for the given networkType.
         * This requirement bit is generally under the control of the carrier
         * or its agents and is not directly controlled by the user.
         *
         * @param networkType The network who's dependence has changed
         * @param met Boolean - true if network use is OK, false if not
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#CONNECTIVITY_INTERNAL}.
         * {@hide}
         */
        SetDataDependency(
            [in] Int32 networkType,
            [in] Boolean met);

        /**
         * Returns true if the hardware supports the given network type
         * else it returns false.  This doesn't indicate we have coverage
         * or are authorized onto a network, just whether or not the
         * hardware supports it.  For example a GSM phone without a SIM
         * should still return {@code true} for mobile data, but a wifi only
         * tablet would return {@code false}.
         *
         * @param networkType The network type we'd like to check
         * @return {@code true} if supported, else {@code false}
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         * @hide
         */
        IsNetworkSupported(
            [in] Int32 networkType,
            [out] Boolean* result);

        /**
         * Returns if the currently active data network is metered. A network is
         * classified as metered when the user is sensitive to heavy data usage on
         * that connection due to monetary costs, data limitations or
         * battery/performance issues. You should check this before doing large
         * data transfers, and warn the user or delay the operation until another
         * network is available.
         *
         * @return {@code true} if large transfers should be avoided, otherwise
         *        {@code false}.
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
         */
        IsActiveNetworkMetered(
            [out] Boolean* result);

        /**
         * If the LockdownVpn mechanism is enabled, updates the vpn
         * with a reload of its profile.
         *
         * @return a boolean with {@code} indicating success
         *
         * <p>This method can only be called by the system UID
         * {@hide}
         */
        UpdateLockdownVpn(
            [out] Boolean* result);

        /**
         * Signal that the captive portal check on the indicated network
         * is complete and whether its a captive portal or not.
         *
         * @param info the {@link NetworkInfo} object for the networkType
         *        in question.
         * @param isCaptivePortal true/false.
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#CONNECTIVITY_INTERNAL}.
         * {@hide}
         */
        CaptivePortalCheckCompleted(
            [in] INetworkInfo* info,
            [in] Boolean isCaptivePortal);

        /**
         * Supply the backend messenger for a network tracker
         *
         * @param networkType NetworkType to set
         * @param messenger {@link Messenger}
         * {@hide}
         */
        SupplyMessenger(
            [in] Int32 networkType,
            [in] IMessenger* messenger);

        /**
         * Check mobile provisioning.
         *
         * @param suggestedTimeOutMs, timeout in milliseconds
         *
         * @return time out that will be used, maybe less that suggestedTimeOutMs
         * -1 if an error.
         *
         * {@hide}
         */
        CheckMobileProvisioning(
            [in] Int32 suggestedTimeOutMs,
            [out] Int32* result);

        /**
         * Get the mobile provisioning url.
         * {@hide}
         */
        GetMobileProvisioningUrl(
            [out] String* result);

        /**
         * Get the mobile redirected provisioning url.
         * {@hide}
         */
        GetMobileRedirectedProvisioningUrl(
            [out] String* result);

        /**
         * get the information about a specific network link
         * @hide
         */
        GetLinkQualityInfo(
            [in] Int32 networkType,
            [out] ILinkQualityInfo** result);

        /**
         * get the information of currently active network link
         * @hide
         */
        GetActiveLinkQualityInfo(
            [out] ILinkQualityInfo** result);

        /**
         * get the information of all network links
         * @hide
         */
        GetAllLinkQualityInfo(
            [out, callee] ArrayOf<ILinkQualityInfo*>* result);

        /**
         * Set sign in error notification to visible or in visible
         *
         * @param visible
         * @param networkType
         *
         * {@hide}
         */
        SetProvisioningNotificationVisible(
            [in] Boolean visible,
            [in] Int32 networkType,
            [in] String action);

        /**
         * Set the value for enabling/disabling airplane mode
         *
         * @param enable whether to enable airplane mode or not
         *
         * <p>This method requires the call to hold the permission
         * {@link android.Manifest.permission#CONNECTIVITY_INTERNAL}.
         * @hide
         */
        SetAirplaneMode(
            [in] Boolean bEnable);

        /** {@hide} */
        RegisterNetworkFactory(
            [in] IMessenger* messenger,
            [in] String name);

        /** {@hide} */
        UnregisterNetworkFactory(
            [in] IMessenger* messenger);

        /** {@hide} */
        RegisterNetworkAgent(
            [in] IMessenger* messenger,
            [in] INetworkInfo* ni,
            [in] ILinkProperties* lp,
            [in] INetworkCapabilities* nc,
            [in] Int32 score,
            [in] INetworkMisc* misc);

        /**
         * Request a network to satisfy a set of {@link NetworkCapabilities}.
         *
         * This {@link NetworkRequest} will live until released via
         * {@link #unregisterNetworkCallback} or the calling application exits.
         * Status of the request can be followed by listening to the various
         * callbacks described in {@link NetworkCallback}.  The {@link Network}
         * can be used to direct traffic to the network.
         *
         * @param request {@link NetworkRequest} describing this request.
         * @param networkCallback The {@link NetworkCallback} to be utilized for this
         *                        request.  Note the callback must not be shared - they
         *                        uniquely specify this request.
         */
        RequestNetwork(
            [in] INetworkRequest* request,
            [in] IConnectivityManagerNetworkCallback* networkCallback);

        /**
         * Request a network to satisfy a set of {@link NetworkCapabilities}, limited
         * by a timeout.
         *
         * This function behaves identically to the non-timedout version, but if a suitable
         * network is not found within the given time (in milliseconds) the
         * {@link NetworkCallback#unavailable} callback is called.  The request must
         * still be released normally by calling {@link releaseNetworkRequest}.
         * @param request {@link NetworkRequest} describing this request.
         * @param networkCallback The callbacks to be utilized for this request.  Note
         *                        the callbacks must not be shared - they uniquely specify
         *                        this request.
         * @param timeoutMs The time in milliseconds to attempt looking for a suitable network
         *                  before {@link NetworkCallback#unavailable} is called.
         * @hide
         */
        RequestNetwork(
            [in] INetworkRequest* request,
            [in] IConnectivityManagerNetworkCallback* networkCallback,
            [in] Int32 timeoutMs);

        /**
         * Request a network to satisfy a set of {@link NetworkCapabilities}.
         *
         * This function behavies identically to the version that takes a NetworkCallback, but instead
         * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
         * the request may outlive the calling application and get called back when a suitable
         * network is found.
         * <p>
         * The operation is an Intent broadcast that goes to a broadcast receiver that
         * you registered with {@link Context#registerReceiver} or through the
         * &lt;receiver&gt; tag in an AndroidManifest.xml file
         * <p>
         * The operation Intent is delivered with two extras, a {@link Network} typed
         * extra called {@link #EXTRA_NETWORK_REQUEST_NETWORK} and a {@link NetworkRequest}
         * typed extra called {@link #EXTRA_NETWORK_REQUEST_NETWORK_REQUEST} containing
         * the original requests parameters.  It is important to create a new,
         * {@link NetworkCallback} based request before completing the processing of the
         * Intent to reserve the network or it will be released shortly after the Intent
         * is processed.
         * <p>
         * If there is already an request for this Intent registered (with the equality of
         * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
         * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
         * <p>
         * The request may be released normally by calling {@link #unregisterNetworkCallback}.
         *
         * @param request {@link NetworkRequest} describing this request.
         * @param operation Action to perform when the network is available (corresponds
         *                  to the {@link NetworkCallback#onAvailable} call.  Typically
         *                  comes from {@link PendingIntent#getBroadcast}.
         * @hide
         */
        RequestNetwork(
            [in] INetworkRequest* request,
            [in] IPendingIntent* operation);

        /**
         * Registers to receive notifications about all networks which satisfy the given
         * {@link NetworkRequest}.  The callbacks will continue to be called until
         * either the application exits or {@link #unregisterNetworkCallback} is called
         *
         * @param request {@link NetworkRequest} describing this request.
         * @param networkCallback The {@link NetworkCallback} that the system will call as suitable
         *                        networks change state.
         */
        RegisterNetworkCallback(
            [in] INetworkRequest* request,
            [in] IConnectivityManagerNetworkCallback* networkCallback);

        /**
         * Unregisters callbacks about and possibly releases networks originating from
         * {@link #requestNetwork} and {@link #registerNetworkCallback} calls.  If the
         * given {@code NetworkCallback} had previosuly been used with {@code #requestNetwork},
         * any networks that had been connected to only to satisfy that request will be
         * disconnected.
         *
         * @param networkCallback The {@link NetworkCallback} used when making the request.
         */
        UnregisterNetworkCallback(
            [in] IConnectivityManagerNetworkCallback* networkCallback);
    }

    [local]
    interface IConnectivityManagerHelper {
        /**
         * Tests if a given integer represents a valid network type.
         * @param networkType the type to be tested
         * @return a boolean.  {@code true} if the type is valid, else {@code false}
         */
        IsNetworkTypeValid(
            [in] Int32 networkType,
            [out] Boolean* result);

        /**
         * Returns a non-localized string representing a given network type.
         * ONLY used for debugging output.
         * @param type the type needing naming
         * @return a String for the given type, or a string version of the type ("87")
         * if no name is known.
         * {@hide}
         */
        GetNetworkTypeName(
            [in] Int32 type,
            [out] String* result);

        /**
         * Checks if a given type uses the cellular data connection.
         * This should be replaced in the future by a network property.
         * @param networkType the type to check
         * @return a boolean - {@code true} if uses cellular network, else {@code false}
         * {@hide}
         */
        IsNetworkTypeMobile(
            [in] Int32 networkType,
            [out] Boolean* result);

        /**
         * Checks if the given network type is backed by a Wi-Fi radio.
         *
         * @hide
         */
        IsNetworkTypeWifi(
            [in] Int32 networkType,
            [out] Boolean* result);

        /**
         * Removes the NET_CAPABILITY_NOT_RESTRICTED capability from the given
         * NetworkCapabilities object if all the capabilities it provides are
         * typically provided by restricted networks.
         *
         * TODO: consider:
         * - Moving to NetworkCapabilities
         * - Renaming it to guessRestrictedCapability and make it set the
         *   restricted capability bit in addition to clearing it.
         * @hide
         */
        MaybeMarkCapabilitiesRestricted(
            [in] INetworkCapabilities* nc);

        /** {@hide} */
        From(
            [in] IContext* ctx,
            [out] IConnectivityManager** result);

        /** {@hide */
        EnforceTetherChangePermission(
            [in] IContext* context);

        /**
         * Binds the current process to {@code network}.  All Sockets created in the future
         * (and not explicitly bound via a bound SocketFactory from
         * {@link Network#getSocketFactory() Network.getSocketFactory()}) will be bound to
         * {@code network}.  All host name resolutions will be limited to {@code network} as well.
         * Note that if {@code network} ever disconnects, all Sockets created in this way will cease to
         * work and all host name resolutions will fail.  This is by design so an application doesn't
         * accidentally use Sockets it thinks are still bound to a particular {@link Network}.
         * To clear binding pass {@code null} for {@code network}.  Using individually bound
         * Sockets created by Network.getSocketFactory().createSocket() and
         * performing network-specific host name resolutions via
         * {@link Network#getAllByName Network.getAllByName} is preferred to calling
         * {@code setProcessDefaultNetwork}.
         *
         * @param network The {@link Network} to bind the current process to, or {@code null} to clear
         *                the current binding.
         * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid.
         */
        SetProcessDefaultNetwork(
            [in] INetwork* network,
            [out] Boolean* result);

        /**
         * Returns the {@link Network} currently bound to this process via
         * {@link #setProcessDefaultNetwork}, or {@code null} if no {@link Network} is explicitly bound.
         *
         * @return {@code Network} to which this process is bound, or {@code null}.
         */
        GetProcessDefaultNetwork(
            [out] INetwork** result);

        /**
         * Binds host resolutions performed by this process to {@code network}.
         * {@link #setProcessDefaultNetwork} takes precedence over this setting.
         *
         * @param network The {@link Network} to bind host resolutions from the current process to, or
         *                {@code null} to clear the current binding.
         * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid.
         * @hide
         * @deprecated This is strictly for legacy usage to support {@link #startUsingNetworkFeature}.
         */
        SetProcessDefaultNetworkForHostResolution(
            [in] INetwork* network,
            [out] Boolean* result);
    }

    interface IConnectivityManagerOnNetworkActiveListener {
        /**
         * Called on the main thread of the process to report that the current data network
         * has become active, and it is now a good time to perform any pending network
         * operations.  Note that this listener only tells you when the network becomes
         * active; if at any other time you want to know whether it is active (and thus okay
         * to initiate network traffic), you can retrieve its instantaneous state with
         * {@link ConnectivityManager#isDefaultNetworkActive}.
         */
        OnNetworkActive();
    }

    /**
     * Base class for NetworkRequest callbacks.  Used for notifications about network
     * changes.  Should be extended by applications wanting notifications.
     */
    interface IConnectivityManagerNetworkCallback {
        /** @hide */
        const Int32 PRECHECK = 1;

        /** @hide */
        const Int32 AVAILABLE = 2;

        /** @hide */
        const Int32 LOSING = 3;

        /** @hide */
        const Int32 LOST = 4;

        /** @hide */
        const Int32 UNAVAIL = 5;

        /** @hide */
        const Int32 CAP_CHANGED = 6;

        /** @hide */
        const Int32 PROP_CHANGED = 7;

        /** @hide */
        const Int32 CANCELED = 8;

        /**
         * @hide
         * Called whenever the framework connects to a network that it may use to
         * satisfy this request
         */
        OnPreCheck(
            [in] INetwork* network);

        /**
         * Called when the framework connects and has declared new network ready for use.
         * This callback may be called more than once if the {@link Network} that is
         * satisfying the request changes.
         *
         * @param network The {@link Network} of the satisfying network.
         */
        OnAvailable(
            [in] INetwork* network);

        /**
         * Called when the network is about to be disconnected.  Often paired with an
         * {@link NetworkCallback#onAvailable} call with the new replacement network
         * for graceful handover.  This may not be called if we have a hard loss
         * (loss without warning).  This may be followed by either a
         * {@link NetworkCallback#onLost} call or a
         * {@link NetworkCallback#onAvailable} call for this network depending
         * on whether we lose or regain it.
         *
         * @param network The {@link Network} that is about to be disconnected.
         * @param maxMsToLive The time in ms the framework will attempt to keep the
         *                     network connected.  Note that the network may suffer a
         *                     hard loss at any time.
         */
        OnLosing(
            [in] INetwork* network,
            [in] Int32 maxMsToLive);

        /**
         * Called when the framework has a hard loss of the network or when the
         * graceful failure ends.
         *
         * @param network The {@link Network} lost.
         */
        OnLost(
            [in] INetwork* network);

        /**
         * Called if no network is found in the given timeout time.  If no timeout is given,
         * this will not be called.
         * @hide
         */
        OnUnavailable();

        /**
         * Called when the network the framework connected to for this request
         * changes capabilities but still satisfies the stated need.
         *
         * @param network The {@link Network} whose capabilities have changed.
         * @param networkCapabilities The new {@link NetworkCapabilities} for this network.
         */
        OnCapabilitiesChanged(
            [in] INetwork* network,
            [in] INetworkCapabilities* networkCapabilities);

        /**
         * Called when the network the framework connected to for this request
         * changes {@link LinkProperties}.
         *
         * @param network The {@link Network} whose link properties have changed.
         * @param linkProperties The new {@link LinkProperties} for this network.
         */
        OnLinkPropertiesChanged(
            [in] INetwork* network,
            [in] ILinkProperties* linkProperties);
    }

    } // namespace Net
    } // namepsace Droid
    } // namespace Elastos
}
