//=========================================================================
// Copyright (C) 2012 The Elastos Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//=========================================================================

module
{
    using interface Elastos.Core.ICharSequence;
    using interface Elastos.Core.IRunnable;
    using interface Elastos.Utility.IList;
    using interface Elastos.Utility.IArrayList;
    using interface Elastos.Utility.IMap;

    enum Elastos.Droid.Graphics.BitmapConfig;
    enum Elastos.Droid.Graphics.PorterDuffMode;

    interface Elastos.Droid.Content.IClipData;
    interface Elastos.Droid.Content.IContext;
    interface Elastos.Droid.Content.Res.IResources;
    interface Elastos.Droid.Content.Res.IConfiguration;
    interface Elastos.Droid.Content.Res.IColorStateList;
    interface Elastos.Droid.Graphics.IBitmap;
    interface Elastos.Droid.Graphics.ICanvas;
    interface Elastos.Droid.Graphics.IPaint;
    interface Elastos.Droid.Graphics.IPoint;
    interface Elastos.Droid.Graphics.IRect;
    interface Elastos.Droid.Graphics.IRegion;
    interface Elastos.Droid.Graphics.IInsets;
    interface Elastos.Droid.Graphics.IMatrix;
    interface Elastos.Droid.Graphics.Drawable.IDrawable;
    interface Elastos.Droid.Os.IBinder;
    interface Elastos.Droid.Os.IBundle;
    interface Elastos.Droid.Os.IHandler;
    interface Elastos.Droid.Utility.ISparseArray;
    interface Elastos.Droid.View.IWindowInsets;
    interface Elastos.Droid.View.IKeyEvent;
    interface Elastos.Droid.View.ITouchDelegate;
    interface Elastos.Droid.View.IDispatcherState;
    interface Elastos.Droid.View.IViewParent;
    interface Elastos.Droid.View.IViewGroupLayoutParams;
    interface Elastos.Droid.View.IView;
    interface Elastos.Droid.View.IViewTreeObserver;
    interface Elastos.Droid.View.IViewPropertyAnimator;
    interface Elastos.Droid.View.IViewOverlay;
    interface Elastos.Droid.View.IWindowId;
    interface Elastos.Droid.View.IViewOutlineProvider;
    interface Elastos.Droid.View.Animation.IAnimation;
    interface Elastos.Droid.View.Accessibility.IAccessibilityEvent;
    interface Elastos.Droid.View.Accessibility.IAccessibilityNodeInfo;
    interface Elastos.Droid.View.Accessibility.IAccessibilityNodeProvider;
    interface Elastos.Droid.View.InputMethod.IEditorInfo;
    interface Elastos.Droid.View.InputMethod.IInputConnection;
    interface Elastos.Droid.Animation.IStateListAnimator;
    interface Elastos.Droid.Internal.Utility.IPredicate;

    namespace Elastos {
    namespace Droid {
    namespace View {

        /**
         * Interface definition for a callback to be invoked when the layout bounds of a view
         * changes due to layout processing.
         */
        interface IViewOnLayoutChangeListener {
            /**
             * Called when the focus state of a view has changed.
             *
             * @param v The view whose state has changed.
             * @param left The new value of the view's left property.
             * @param top The new value of the view's top property.
             * @param right The new value of the view's right property.
             * @param bottom The new value of the view's bottom property.
             * @param oldLeft The previous value of the view's left property.
             * @param oldTop The previous value of the view's top property.
             * @param oldRight The previous value of the view's right property.
             * @param oldBottom The previous value of the view's bottom property.
             */
            OnLayoutChange(
                [in] IView* v,
                [in] Int32 left,
                [in] Int32 top,
                [in] Int32 right,
                [in] Int32 bottom,
                [in] Int32 oldLeft,
                [in] Int32 oldTop,
                [in] Int32 oldRight,
                [in] Int32 oldBottom);
        }

        /**
         * Creates an image that the system displays during the drag and drop
         * operation. This is called a &quot;drag shadow&quot;. The default implementation
         * for a DragShadowBuilder based on a View returns an image that has exactly the same
         * appearance as the given View. The default also positions the center of the drag shadow
         * directly under the touch point. If no View is provided (the constructor with no parameters
         * is used), and {@link #onProvideShadowMetrics(Point,Point) onProvideShadowMetrics()} and
         * {@link #onDrawShadow(Canvas) onDrawShadow()} are not overriden, then the
         * default is an invisible drag shadow.
         * <p>
         * You are not required to use the View you provide to the constructor as the basis of the
         * drag shadow. The {@link #onDrawShadow(Canvas) onDrawShadow()} method allows you to draw
         * anything you want as the drag shadow.
         * </p>
         * <p>
         *  You pass a DragShadowBuilder object to the system when you start the drag. The system
         *  calls {@link #onProvideShadowMetrics(Point,Point) onProvideShadowMetrics()} to get the
         *  size and position of the drag shadow. It uses this data to construct a
         *  {@link android.graphics.Canvas} object, then it calls {@link #onDrawShadow(Canvas) onDrawShadow()}
         *  so that your application can draw the shadow image in the Canvas.
         * </p>
         *
         * <div class="special reference">
         * <h3>Developer Guides</h3>
         * <p>For a guide to implementing drag and drop features, read the
         * <a href="{@docRoot}guide/topics/ui/drag-drop.html">Drag and Drop</a> developer guide.</p>
         * </div>
         */
        interface IDragShadowBuilder
        {
            /**
             * Returns the View object that had been passed to the
             * {@link #View.DragShadowBuilder(View)}
             * constructor.  If that View parameter was {@code null} or if the
             * {@link #View.DragShadowBuilder()}
             * constructor was used to instantiate the builder object, this method will return
             * null.
             *
             * @return The View object associate with this builder object.
             */
            //@SuppressWarnings({"JavadocReference"})
            GetView(
                [out] IView** view);

            /**
             * Provides the metrics for the shadow image. These include the dimensions of
             * the shadow image, and the point within that shadow that should
             * be centered under the touch location while dragging.
             * <p>
             * The default implementation sets the dimensions of the shadow to be the
             * same as the dimensions of the View itself and centers the shadow under
             * the touch point.
             * </p>
             *
             * @param shadowSize A {@link android.graphics.Point} containing the width and height
             * of the shadow image. Your application must set {@link android.graphics.Point#x} to the
             * desired width and must set {@link android.graphics.Point#y} to the desired height of the
             * image.
             *
             * @param shadowTouchPoint A {@link android.graphics.Point} for the position within the
             * shadow image that should be underneath the touch point during the drag and drop
             * operation. Your application must set {@link android.graphics.Point#x} to the
             * X coordinate and {@link android.graphics.Point#y} to the Y coordinate of this position.
             */
            OnProvideShadowMetrics(
                [in] IPoint* shadowSize,
                [in] IPoint* shadowTouchPoint);

            /**
             * Draws the shadow image. The system creates the {@link android.graphics.Canvas} object
             * based on the dimensions it received from the
             * {@link #onProvideShadowMetrics(Point, Point)} callback.
             *
             * @param canvas A {@link android.graphics.Canvas} object in which to draw the shadow image.
             */
            OnDrawShadow(
                [in] ICanvas* canvas);
        }

        /**
         * Interface definition for a callback to be invoked when a view has been clicked and held.
         */
        interface IViewOnLongClickListener {
            /**
             * Called when a view has been clicked and held.
             *
             * @param v The view that was clicked and held.
             *
             * @return true if the callback consumed the long click, false otherwise.
             */
            OnLongClick(
                [in] IView* v,
                [out] Boolean* result);
        }


        /**
         * Interface definition for a callback to be invoked when a hardware key event is
         * dispatched to this view. The callback will be invoked before the key event is
         * given to the view. This is only useful for hardware keyboards; a software input
         * method has no obligation to trigger this listener.
         */
        interface IViewOnKeyListener {
            /**
             * Called when a hardware key is dispatched to a view. This allows listeners to
             * get a chance to respond before the target view.
             * <p>Key presses in software keyboards will generally NOT trigger this method,
             * although some may elect to do so in some situations. Do not assume a
             * software input method has to be key-based; even if it is, it may use key presses
             * in a different way than you expect, so there is no way to reliably catch soft
             * input key presses.
             *
             * @param v The view the key has been dispatched to.
             * @param keyCode The code for the physical key that was pressed
             * @param event The KeyEvent object containing full information about
             *        the event.
             * @return True if the listener has consumed the event, false otherwise.
             */
            OnKey(
                [in] IView* v,
                [in] Int32 keyCode,
                [in] IKeyEvent* event,
                [out] Boolean* result);
        }

        /**
         * Interface definition for a callback to be invoked when a touch event is
         * dispatched to this view. The callback will be invoked before the touch
         * event is given to the view.
         */
        interface IViewOnTouchListener {
            /**
             * Called when a touch event is dispatched to a view. This allows listeners to
             * get a chance to respond before the target view.
             *
             * @param v The view the touch event has been dispatched to.
             * @param event The MotionEvent object containing full information about
             *        the event.
             * @return True if the listener has consumed the event, false otherwise.
             */
            OnTouch(
                [in] IView* v,
                [in] IMotionEvent* event,
                [out] Boolean* result);
        }

        /**
         * Interface definition for a callback to be invoked when a hover event is
         * dispatched to this view. The callback will be invoked before the hover
         * event is given to the view.
         */
        interface IViewOnHoverListener {
            /**
             * Called when a hover event is dispatched to a view. This allows listeners to
             * get a chance to respond before the target view.
             *
             * @param v The view the hover event has been dispatched to.
             * @param event The MotionEvent object containing full information about
             *        the event.
             * @return True if the listener has consumed the event, false otherwise.
             */
            OnHover(
                [in] IView* v,
                [in] IMotionEvent* event,
                [out] Boolean* comsumed);
        }

        /**
         * Interface definition for a callback to be invoked when a generic motion event is
         * dispatched to this view. The callback will be invoked before the generic motion
         * event is given to the view.
         */
        interface IViewOnGenericMotionListener {
            /**
             * Called when a generic motion event is dispatched to a view. This allows listeners to
             * get a chance to respond before the target view.
             *
             * @param v The view the generic motion event has been dispatched to.
             * @param event The MotionEvent object containing full information about
             *        the event.
             * @return True if the listener has consumed the event, false otherwise.
             */
            OnGenericMotion(
                [in] IView* v,
                [in] IMotionEvent* event,
                [out] Boolean* consumed);
        }

        /**
         * Interface definition for a callback to be invoked when a drag is being dispatched
         * to this view.  The callback will be invoked before the hosting view's own
         * onDrag(event) method.  If the listener wants to fall back to the hosting view's
         * onDrag(event) behavior, it should return 'false' from this callback.
         *
         * <div class="special reference">
         * <h3>Developer Guides</h3>
         * <p>For a guide to implementing drag and drop features, read the
         * <a href="{@docRoot}guide/topics/ui/drag-drop.html">Drag and Drop</a> developer guide.</p>
         * </div>
         */
        interface IViewOnDragListener {
            /**
             * Called when a drag event is dispatched to a view. This allows listeners
             * to get a chance to override base View behavior.
             *
             * @param v The View that received the drag event.
             * @param event The {@link android.view.DragEvent} object for the drag event.
             * @return {@code true} if the drag event was handled successfully, or {@code false}
             * if the drag event was not handled. Note that {@code false} will trigger the View
             * to call its {@link #onDragEvent(DragEvent) onDragEvent()} handler.
             */
            OnDrag(
                [in] IView* v,
                [in] IDragEvent* event,
                [out] Boolean* handled);
        }

        /**
         * Interface definition for a callback to be invoked when the focus state of
         * a view changed.
         */
        interface IViewOnFocusChangeListener {
            /**
             * Called when the focus state of a view has changed.
             *
             * @param v The view whose state has changed.
             * @param hasFocus The new focus state of v.
             */
            OnFocusChange(
                [in] IView* v,
                [in] Boolean hasFocus);
        }

        /**
         * Interface definition for a callback to be invoked when a view is clicked.
         */
        interface IViewOnClickListener {
            /**
             * Called when a view has been clicked.
             *
             * @param v The view that was clicked.
             */
            OnClick(
                [in] IView* v);
        }

        /**
         * Interface definition for a callback to be invoked when the context menu
         * for this view is being built.
         */
        interface IViewOnCreateContextMenuListener {
            /**
             * Called when the context menu for this view is being built. It is not
             * safe to hold onto the menu after this method returns.
             *
             * @param menu The context menu that is being built
             * @param v The view for which the context menu is being built
             * @param menuInfo Extra information about the item for which the
             *            context menu should be shown. This information will vary
             *            depending on the class of v.
             */
            OnCreateContextMenu(
                [in] IContextMenu* menu,
                [in] IView* v,
                [in] IContextMenuInfo* menuInfo);
        }

        /**
         * Interface definition for a callback to be invoked when the status bar changes
         * visibility.  This reports <strong>global</strong> changes to the system UI
         * state, not what the application is requesting.
         *
         * @see View#setOnSystemUiVisibilityChangeListener(android.view.View.OnSystemUiVisibilityChangeListener)
         */
        interface IViewOnSystemUiVisibilityChangeListener {
            /**
             * Called when the status bar changes visibility because of a call to
             * {@link View#setSystemUiVisibility(int)}.
             *
             * @param visibility  Bitwise-or of flags {@link #SYSTEM_UI_FLAG_LOW_PROFILE},
             * {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION}, and {@link #SYSTEM_UI_FLAG_FULLSCREEN}.
             * This tells you the <strong>global</strong> state of these UI visibility
             * flags, not what your app is currently applying.
             */
            OnSystemUiVisibilityChange(
                [in] Int32 visibility);
        }

        /**
         * Interface definition for a callback to be invoked when this view is attached
         * or detached from its window.
         */
        interface IViewOnAttachStateChangeListener {
            /**
             * Called when the view is attached to a window.
             * @param v The view that was attached
             */
            OnViewAttachedToWindow(
                [in] IView* v);

            /**
             * Called when the view is detached from a window.
             * @param v The view that was detached
             */
            OnViewDetachedFromWindow(
                [in] IView* v);
        }

        /**
         * Listener for applying window insets on a view in a custom way.
         *
         * <p>Apps may choose to implement this interface if they want to apply custom policy
         * to the way that window insets are treated for a view. If an OnApplyWindowInsetsListener
         * is set, its
         * {@link OnApplyWindowInsetsListener#onApplyWindowInsets(View, WindowInsets) onApplyWindowInsets}
         * method will be called instead of the View's own
         * {@link #onApplyWindowInsets(WindowInsets) onApplyWindowInsets} method. The listener
         * may optionally call the parameter View's <code>onApplyWindowInsets</code> method to apply
         * the View's normal behavior as part of its own.</p>
         */
        interface IViewOnApplyWindowInsetsListener {
            /**
             * When {@link View#setOnApplyWindowInsetsListener(View.OnApplyWindowInsetsListener) set}
             * on a View, this listener method will be called instead of the view's own
             * {@link View#onApplyWindowInsets(WindowInsets) onApplyWindowInsets} method.
             *
             * @param v The view applying window insets
             * @param insets The insets to apply
             * @return The insets supplied, minus any insets that were consumed
             */
            OnApplyWindowInsets(
                [in] IView* v,
                [in] IWindowInsets* insets,
                [out] IWindowInsets** result);
        }

        /**
         * @Involve
         * interface IAbsSavedState
         */
        interface IViewBaseSavedState {
        }

        interface IAccessibilityDelegate {
            /**
             * Sends an accessibility event of the given type. If accessibility is not
             * enabled this method has no effect.
             * <p>
             * The default implementation behaves as {@link View#sendAccessibilityEvent(int)
             *  View#sendAccessibilityEvent(int)} for the case of no accessibility delegate
             * been set.
             * </p>
             *
             * @param host The View hosting the delegate.
             * @param eventType The type of the event to send.
             *
             * @see View#sendAccessibilityEvent(int) View#sendAccessibilityEvent(int)
             */
            SendAccessibilityEvent(
                [in] IView* host,
                [in] Int32 eventType);

            /**
             * Performs the specified accessibility action on the view. For
             * possible accessibility actions look at {@link AccessibilityNodeInfo}.
             * <p>
             * The default implementation behaves as
             * {@link View#performAccessibilityAction(int, Bundle)
             *  View#performAccessibilityAction(int, Bundle)} for the case of
             *  no accessibility delegate been set.
             * </p>
             *
             * @param action The action to perform.
             * @return Whether the action was performed.
             *
             * @see View#performAccessibilityAction(int, Bundle)
             *      View#performAccessibilityAction(int, Bundle)
             */
            PerformAccessibilityAction(
                [in] IView* host,
                [in] Int32 action,
                [in] IBundle* args,
                [out] Boolean* res);

            /**
             * Sends an accessibility event. This method behaves exactly as
             * {@link #sendAccessibilityEvent(View, int)} but takes as an argument an
             * empty {@link AccessibilityEvent} and does not perform a check whether
             * accessibility is enabled.
             * <p>
             * The default implementation behaves as
             * {@link View#sendAccessibilityEventUnchecked(AccessibilityEvent)
             *  View#sendAccessibilityEventUnchecked(AccessibilityEvent)} for
             * the case of no accessibility delegate been set.
             * </p>
             *
             * @param host The View hosting the delegate.
             * @param event The event to send.
             *
             * @see View#sendAccessibilityEventUnchecked(AccessibilityEvent)
             *      View#sendAccessibilityEventUnchecked(AccessibilityEvent)
             */
            SendAccessibilityEventUnchecked(
                [in] IView* host,
                [in] IAccessibilityEvent* event);

            /**
             * Dispatches an {@link AccessibilityEvent} to the host {@link View} first and then
             * to its children for adding their text content to the event.
             * <p>
             * The default implementation behaves as
             * {@link View#dispatchPopulateAccessibilityEvent(AccessibilityEvent)
             *  View#dispatchPopulateAccessibilityEvent(AccessibilityEvent)} for
             * the case of no accessibility delegate been set.
             * </p>
             *
             * @param host The View hosting the delegate.
             * @param event The event.
             * @return True if the event population was completed.
             *
             * @see View#dispatchPopulateAccessibilityEvent(AccessibilityEvent)
             *      View#dispatchPopulateAccessibilityEvent(AccessibilityEvent)
             */
            DispatchPopulateAccessibilityEvent(
                [in] IView* host,
                [in] IAccessibilityEvent* event,
                [out] Boolean* res);

            /**
             * Gives a chance to the host View to populate the accessibility event with its
             * text content.
             * <p>
             * The default implementation behaves as
             * {@link View#onPopulateAccessibilityEvent(AccessibilityEvent)
             *  View#onPopulateAccessibilityEvent(AccessibilityEvent)} for
             * the case of no accessibility delegate been set.
             * </p>
             *
             * @param host The View hosting the delegate.
             * @param event The accessibility event which to populate.
             *
             * @see View#onPopulateAccessibilityEvent(AccessibilityEvent)
             *      View#onPopulateAccessibilityEvent(AccessibilityEvent)
             */
            OnPopulateAccessibilityEvent(
                [in] IView* host,
                [in] IAccessibilityEvent* event);

            /**
             * Initializes an {@link AccessibilityEvent} with information about the
             * the host View which is the event source.
             * <p>
             * The default implementation behaves as
             * {@link View#onInitializeAccessibilityEvent(AccessibilityEvent)
             *  View#onInitializeAccessibilityEvent(AccessibilityEvent)} for
             * the case of no accessibility delegate been set.
             * </p>
             *
             * @param host The View hosting the delegate.
             * @param event The event to initialize.
             *
             * @see View#onInitializeAccessibilityEvent(AccessibilityEvent)
             *      View#onInitializeAccessibilityEvent(AccessibilityEvent)
             */
            OnInitializeAccessibilityEvent(
                [in] IView* host,
                [in] IAccessibilityEvent* event);

            /**
             * Initializes an {@link AccessibilityNodeInfo} with information about the host view.
             * <p>
             * The default implementation behaves as
             * {@link View#onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)
             *  View#onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)} for
             * the case of no accessibility delegate been set.
             * </p>
             *
             * @param host The View hosting the delegate.
             * @param info The instance to initialize.
             *
             * @see View#onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)
             *      View#onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)
             */
            OnInitializeAccessibilityNodeInfo(
                [in] IView* host,
                [in] IAccessibilityNodeInfo* info);

            /**
             * Called when a child of the host View has requested sending an
             * {@link AccessibilityEvent} and gives an opportunity to the parent (the host)
             * to augment the event.
             * <p>
             * The default implementation behaves as
             * {@link ViewGroup#onRequestSendAccessibilityEvent(View, AccessibilityEvent)
             *  ViewGroup#onRequestSendAccessibilityEvent(View, AccessibilityEvent)} for
             * the case of no accessibility delegate been set.
             * </p>
             *
             * @param host The View hosting the delegate.
             * @param child The child which requests sending the event.
             * @param event The event to be sent.
             * @return True if the event should be sent
             *
             * @see ViewGroup#onRequestSendAccessibilityEvent(View, AccessibilityEvent)
             *      ViewGroup#onRequestSendAccessibilityEvent(View, AccessibilityEvent)
             */
            OnRequestSendAccessibilityEvent(
                [in] IViewGroup* host,
                [in] IView* child,
                [in] IAccessibilityEvent* event,
                [out] Boolean* res);

            /**
             * Gets the provider for managing a virtual view hierarchy rooted at this View
             * and reported to {@link android.accessibilityservice.AccessibilityService}s
             * that explore the window content.
             * <p>
             * The default implementation behaves as
             * {@link View#getAccessibilityNodeProvider() View#getAccessibilityNodeProvider()} for
             * the case of no accessibility delegate been set.
             * </p>
             *
             * @return The provider.
             *
             * @see AccessibilityNodeProvider
             */
            GetAccessibilityNodeProvider(
                [in] IView* host,
                [out] IAccessibilityNodeProvider** anp);

            CreateAccessibilityNodeInfo(
                [in] IView* host,
                [out] IAccessibilityNodeInfo** res);
        }

        /**
         * @Involve
         * interface Elastos.Droid.View.IKeyEventCallback
         * interface Elastos.Droid.View.Accessibility.IAccessibilityEventSource
         * interface Elastos.Droid.Graphics.Drawable.IDrawableCallback
         */
        [local, deprecated]
        interface IView {
            /**
             * When set to true, apps will draw debugging information about their layouts.
             *
             * @hide
             */
            const String DEBUG_LAYOUT_PROPERTY = "debug.layout";

            /**
             * Used to mark a View that has no ID.
             */
            const Int32 NO_ID = -1;


            /**
             * This view is visible.
             * Use with {@link #setVisibility} and <a href="#attr_android:visibility">{@code
             * android:visibility}.
             */
            const Int32 VISIBLE = 0x00000000;

            /**
             * This view is invisible, but it still takes up space for layout purposes.
             * Use with {@link #setVisibility} and <a href="#attr_android:visibility">{@code
             * android:visibility}.
             */
            const Int32 INVISIBLE = 0x00000004;

            /**
             * This view is invisible, and it doesn't take any space for layout
             * purposes. Use with {@link #setVisibility} and <a href="#attr_android:visibility">{@code
             * android:visibility}.
             */
            const Int32 GONE = 0x00000008;

            /**
             * <p>Enables low quality mode for the drawing cache.</p>
             */
            const Int32 DRAWING_CACHE_QUALITY_LOW = 0x00080000;

            /**
             * <p>Enables high quality mode for the drawing cache.</p>
             */
            const Int32 DRAWING_CACHE_QUALITY_HIGH = 0x00100000;

            /**
             * <p>Enables automatic quality mode for the drawing cache.</p>
             */
            const Int32 DRAWING_CACHE_QUALITY_AUTO = 0x00000000;

            /**
             * The scrollbar style to display the scrollbars inside the content area,
             * without increasing the padding. The scrollbars will be overlaid with
             * translucency on the view's content.
             */
            const Int32 SCROLLBARS_INSIDE_OVERLAY = 0;

            /**
             * The scrollbar style to display the scrollbars inside the padded area,
             * increasing the padding of the view. The scrollbars will not overlap the
             * content area of the view.
             */
            const Int32 SCROLLBARS_INSIDE_INSET = 0x01000000;

            /**
             * The scrollbar style to display the scrollbars at the edge of the view,
             * without increasing the padding. The scrollbars will be overlaid with
             * translucency.
             */
            const Int32 SCROLLBARS_OUTSIDE_OVERLAY = 0x02000000;

            /**
             * The scrollbar style to display the scrollbars at the edge of the view,
             * increasing the padding of the view. The scrollbars will only overlap the
             * background, if any.
             */
            const Int32 SCROLLBARS_OUTSIDE_INSET = 0x03000000;

            /**
             * View flag indicating that the screen should remain on while the
             * window containing this view is visible to the user.  This effectively
             * takes care of automatically setting the WindowManager's
             * {@link WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON}.
             */
            const Int32 KEEP_SCREEN_ON = 0x04000000;

            /**
             * View flag indicating whether this view should have sound effects enabled
             * for events such as clicking and touching.
             */
            const Int32 SOUND_EFFECTS_ENABLED = 0x08000000;

            /**
             * View flag indicating whether this view should have haptic feedback
             * enabled for events such as long presses.
             */
            const Int32 HAPTIC_FEEDBACK_ENABLED = 0x10000000;

            /**
             * View flag indicating whether {@link #addFocusables(ArrayList, int, int)}
             * should add all focusable Views regardless if they are focusable in touch mode.
             */
            const Int32 FOCUSABLES_ALL = 0x00000000;

            /**
             * View flag indicating whether {@link #addFocusables(ArrayList, int, int)}
             * should add only Views focusable in touch mode.
             */
            const Int32 FOCUSABLES_TOUCH_MODE = 0x00000001;

            /**
             * Use with {@link #focusSearch(int)}. Move focus to the previous selectable
             * item.
             */
            const Int32 FOCUS_BACKWARD = 0x00000001;

            /**
             * Use with {@link #focusSearch(int)}. Move focus to the next selectable
             * item.
             */
            const Int32 FOCUS_FORWARD = 0x00000002;

            /**
             * Use with {@link #focusSearch(int)}. Move focus to the left.
             */
            const Int32 FOCUS_LEFT = 0x00000011;

            /**
             * Use with {@link #focusSearch(int)}. Move focus up.
             */
            const Int32 FOCUS_UP = 0x00000021;

            /**
             * Use with {@link #focusSearch(int)}. Move focus to the right.
             */
            const Int32 FOCUS_RIGHT = 0x00000042;

            /**
             * Use with {@link #focusSearch(int)}. Move focus down.
             */
            const Int32 FOCUS_DOWN = 0x00000082;

            /**
             * Bits of {@link #getMeasuredWidthAndState()} and
             * {@link #getMeasuredWidthAndState()} that provide the actual measured size.
             */
            const Int32 MEASURED_SIZE_MASK = 0x00ffffff;

            /**
             * Bits of {@link #getMeasuredWidthAndState()} and
             * {@link #getMeasuredWidthAndState()} that provide the additional state bits.
             */
            const Int32 MEASURED_STATE_MASK = 0xff000000;

            /**
             * Bit shift of {@link #MEASURED_STATE_MASK} to get to the height bits
             * for functions that combine both width and height into a single int,
             * such as {@link #getMeasuredState()} and the childState argument of
             * {@link #resolveSizeAndState(int, int, int)}.
             */
            const Int32 MEASURED_HEIGHT_STATE_SHIFT = 16;

            /**
             * Bit of {@link #getMeasuredWidthAndState()} and
             * {@link #getMeasuredWidthAndState()} that indicates the measured size
             * is smaller that the space the view would like to have.
             */
            const Int32 MEASURED_STATE_TOO_SMALL = 0x01000000;

            /**
             * Horizontal layout direction of this view is from Left to Right.
             * Use with {@link #setLayoutDirection}.
             */
            const Int32 LAYOUT_DIRECTION_LTR = 0;

            /**
             * Horizontal layout direction of this view is from Right to Left.
             * Use with {@link #setLayoutDirection}.
             */
            const Int32 LAYOUT_DIRECTION_RTL = 1;

            /**
             * Horizontal layout direction of this view is inherited from its parent.
             * Use with {@link #setLayoutDirection}.
             */
            const Int32 LAYOUT_DIRECTION_INHERIT = 2;

            /**
             * Horizontal layout direction of this view is from deduced from the default language
             * script for the locale. Use with {@link #setLayoutDirection}.
             */
            const Int32 LAYOUT_DIRECTION_LOCALE = 3;


            /**
             * Text direction is inherited thru {@link ViewGroup}
             */
            const Int32 TEXT_DIRECTION_INHERIT = 0;

            /**
             * Text direction is using "first strong algorithm". The first strong directional character
             * determines the paragraph direction. If there is no strong directional character, the
             * paragraph direction is the view's resolved layout direction.
             */
            const Int32 TEXT_DIRECTION_FIRST_STRONG = 1;

            /**
             * Text direction is using "any-RTL" algorithm. The paragraph direction is RTL if it contains
             * any strong RTL character, otherwise it is LTR if it contains any strong LTR characters.
             * If there are neither, the paragraph direction is the view's resolved layout direction.
             */
            const Int32 TEXT_DIRECTION_ANY_RTL = 2;

            /**
             * Text direction is forced to LTR.
             */
            const Int32 TEXT_DIRECTION_LTR = 3;

            /**
             * Text direction is forced to RTL.
             */
            const Int32 TEXT_DIRECTION_RTL = 4;

            /**
             * Text direction is coming from the system Locale.
             */
            const Int32 TEXT_DIRECTION_LOCALE = 5;

           /*
             * Default text alignment. The text alignment of this View is inherited from its parent.
             * Use with {@link #setTextAlignment(int)}
             */
            const Int32 TEXT_ALIGNMENT_INHERIT = 0;

            /**
             * Default for the root view. The gravity determines the text alignment, ALIGN_NORMAL,
             * ALIGN_CENTER, or ALIGN_OPPOSITE, which are relative to each paragraph’s text direction.
             *
             * Use with {@link #setTextAlignment(int)}
             */
            const Int32 TEXT_ALIGNMENT_GRAVITY = 1;

            /**
             * Align to the start of the paragraph, e.g. ALIGN_NORMAL.
             *
             * Use with {@link #setTextAlignment(int)}
             */
            const Int32 TEXT_ALIGNMENT_TEXT_START = 2;

            /**
             * Align to the end of the paragraph, e.g. ALIGN_OPPOSITE.
             *
             * Use with {@link #setTextAlignment(int)}
             */
            const Int32 TEXT_ALIGNMENT_TEXT_END = 3;

            /**
             * Center the paragraph, e.g. ALIGN_CENTER.
             *
             * Use with {@link #setTextAlignment(int)}
             */
            const Int32 TEXT_ALIGNMENT_CENTER = 4;

            /**
             * Align to the start of the view, which is ALIGN_LEFT if the view’s resolved
             * layoutDirection is LTR, and ALIGN_RIGHT otherwise.
             *
             * Use with {@link #setTextAlignment(int)}
             */
            const Int32 TEXT_ALIGNMENT_VIEW_START = 5;

            /**
             * Align to the end of the view, which is ALIGN_RIGHT if the view’s resolved
             * layoutDirection is LTR, and ALIGN_LEFT otherwise.
             *
             * Use with {@link #setTextAlignment(int)}
             */
            const Int32 TEXT_ALIGNMENT_VIEW_END = 6;

            /**
             * Automatically determine whether a view is important for accessibility.
             */
            const Int32 IMPORTANT_FOR_ACCESSIBILITY_AUTO = 0x00000000;

            /**
             * The view is important for accessibility.
             */
            const Int32 IMPORTANT_FOR_ACCESSIBILITY_YES = 0x00000001;

            /**
             * The view is not important for accessibility.
             */
            const Int32 IMPORTANT_FOR_ACCESSIBILITY_NO = 0x00000002;

            /**
             * The view is not important for accessibility, nor are any of its
             * descendant views.
             */
            const Int32 IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS = 0x00000004;

            /**
             * Live region mode specifying that accessibility services should not
             * automatically announce changes to this view. This is the default live
             * region mode for most views.
             * <p>
             * Use with {@link #setAccessibilityLiveRegion(int)}.
             */
            const Int32 ACCESSIBILITY_LIVE_REGION_NONE = 0x00000000;

            /**
             * Live region mode specifying that accessibility services should announce
             * changes to this view.
             * <p>
             * Use with {@link #setAccessibilityLiveRegion(int)}.
             */
            const Int32 ACCESSIBILITY_LIVE_REGION_POLITE = 0x00000001;

            /**
             * Live region mode specifying that accessibility services should interrupt
             * ongoing speech to immediately announce changes to this view.
             * <p>
             * Use with {@link #setAccessibilityLiveRegion(int)}.
             */
            const Int32 ACCESSIBILITY_LIVE_REGION_ASSERTIVE = 0x00000002;

            /**
             * Always allow a user to over-scroll this view, provided it is a
             * view that can scroll.
             *
             * @see #getOverScrollMode()
             * @see #setOverScrollMode(int)
             */
            const Int32 OVER_SCROLL_ALWAYS = 0;

            /**
             * Allow a user to over-scroll this view only if the content is large
             * enough to meaningfully scroll, provided it is a view that can scroll.
             *
             * @see #getOverScrollMode()
             * @see #setOverScrollMode(int)
             */
            const Int32 OVER_SCROLL_IF_CONTENT_SCROLLS = 1;

            /**
             * Never allow a user to over-scroll this view.
             *
             * @see #getOverScrollMode()
             * @see #setOverScrollMode(int)
             */
            const Int32 OVER_SCROLL_NEVER = 2;

            /**
             * Special constant for {@link #setSystemUiVisibility(int)}: View has
             * requested the system UI (status bar) to be visible (the default).
             *
             * @see #setSystemUiVisibility(int)
             */
            const Int32 SYSTEM_UI_FLAG_VISIBLE = 0;

            /**
             * Flag for {@link #setSystemUiVisibility(int)}: View has requested the
             * system UI to enter an unobtrusive "low profile" mode.
             *
             * <p>This is for use in games, book readers, video players, or any other
             * "immersive" application where the usual system chrome is deemed too distracting.
             *
             * <p>In low profile mode, the status bar and/or navigation icons may dim.
             *
             * @see #setSystemUiVisibility(int)
             */
            const Int32 SYSTEM_UI_FLAG_LOW_PROFILE = 0x00000001;

            /**
             * Flag for {@link #setSystemUiVisibility(int)}: View has requested that the
             * system navigation be temporarily hidden.
             *
             * <p>This is an even less obtrusive state than that called for by
             * {@link #SYSTEM_UI_FLAG_LOW_PROFILE}; on devices that draw essential navigation controls
             * (Home, Back, and the like) on screen, <code>SYSTEM_UI_FLAG_HIDE_NAVIGATION</code> will cause
             * those to disappear. This is useful (in conjunction with the
             * {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN FLAG_FULLSCREEN} and
             * {@link android.view.WindowManager.LayoutParams#FLAG_LAYOUT_IN_SCREEN FLAG_LAYOUT_IN_SCREEN}
             * window flags) for displaying content using every last pixel on the display.
             *
             * <p>There is a limitation: because navigation controls are so important, the least user
             * interaction will cause them to reappear immediately.  When this happens, both
             * this flag and {@link #SYSTEM_UI_FLAG_FULLSCREEN} will be cleared automatically,
             * so that both elements reappear at the same time.
             *
             * @see #setSystemUiVisibility(int)
             */
            const Int32 SYSTEM_UI_FLAG_HIDE_NAVIGATION = 0x00000002;

            /**
             * Flag for {@link #setSystemUiVisibility(int)}: View has requested to go
             * into the normal fullscreen mode so that its content can take over the screen
             * while still allowing the user to interact with the application.
             *
             * <p>This has the same visual effect as
             * {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN
             * WindowManager.LayoutParams.FLAG_FULLSCREEN},
             * meaning that non-critical screen decorations (such as the status bar) will be
             * hidden while the user is in the View's window, focusing the experience on
             * that content.  Unlike the window flag, if you are using ActionBar in
             * overlay mode with {@link Window#FEATURE_ACTION_BAR_OVERLAY
             * Window.FEATURE_ACTION_BAR_OVERLAY}, then enabling this flag will also
             * hide the action bar.
             *
             * <p>This approach to going fullscreen is best used over the window flag when
             * it is a transient state -- that is, the application does this at certain
             * points in its user interaction where it wants to allow the user to focus
             * on content, but not as a continuous state.  For situations where the application
             * would like to simply stay full screen the entire time (such as a game that
             * wants to take over the screen), the
             * {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN window flag}
             * is usually a better approach.  The state set here will be removed by the system
             * in various situations (such as the user moving to another application) like
             * the other system UI states.
             *
             * <p>When using this flag, the application should provide some easy facility
             * for the user to go out of it.  A common example would be in an e-book
             * reader, where tapping on the screen brings back whatever screen and UI
             * decorations that had been hidden while the user was immersed in reading
             * the book.
             *
             * @see #setSystemUiVisibility(int)
             */
            const Int32 SYSTEM_UI_FLAG_FULLSCREEN = 0x00000004;

            /**
             * Flag for {@link #setSystemUiVisibility(int)}: When using other layout
             * flags, we would like a stable view of the content insets given to
             * {@link #fitSystemWindows(Rect)}.  This means that the insets seen there
             * will always represent the worst case that the application can expect
             * as a continuous state.  In the stock Android UI this is the space for
             * the system bar, nav bar, and status bar, but not more transient elements
             * such as an input method.
             *
             * The stable layout your UI sees is based on the system UI modes you can
             * switch to.  That is, if you specify {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}
             * then you will get a stable layout for changes of the
             * {@link #SYSTEM_UI_FLAG_FULLSCREEN} mode; if you specify
             * {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN} and
             * {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION}, then you can transition
             * to {@link #SYSTEM_UI_FLAG_FULLSCREEN} and {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION}
             * with a stable layout.  (Note that you should avoid using
             * {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} by itself.)
             *
             * If you have set the window flag {@link WindowManager.LayoutParams#FLAG_FULLSCREEN}
             * to hide the status bar (instead of using {@link #SYSTEM_UI_FLAG_FULLSCREEN}),
             * then a hidden status bar will be considered a "stable" state for purposes
             * here.  This allows your UI to continually hide the status bar, while still
             * using the system UI flags to hide the action bar while still retaining
             * a stable layout.  Note that changing the window fullscreen flag will never
             * provide a stable layout for a clean transition.
             *
             * <p>If you are using ActionBar in
             * overlay mode with {@link Window#FEATURE_ACTION_BAR_OVERLAY
             * Window.FEATURE_ACTION_BAR_OVERLAY}, this flag will also impact the
             * insets it adds to those given to the application.
             */
            const Int32 SYSTEM_UI_FLAG_LAYOUT_STABLE = 0x00000100;

            /**
             * Flag for {@link #setSystemUiVisibility(int)}: View would like its window
             * to be layed out as if it has requested
             * {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION}, even if it currently hasn't.  This
             * allows it to avoid artifacts when switching in and out of that mode, at
             * the expense that some of its user interface may be covered by screen
             * decorations when they are shown.  You can perform layout of your inner
             * UI elements to account for the navagation system UI through the
             * {@link #fitSystemWindows(Rect)} method.
             */
            const Int32 SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION = 0x00000200;

            /**
             * Flag for {@link #setSystemUiVisibility(int)}: View would like its window
             * to be layed out as if it has requested
             * {@link #SYSTEM_UI_FLAG_FULLSCREEN}, even if it currently hasn't.  This
             * allows it to avoid artifacts when switching in and out of that mode, at
             * the expense that some of its user interface may be covered by screen
             * decorations when they are shown.  You can perform layout of your inner
             * UI elements to account for non-fullscreen system UI through the
             * {@link #fitSystemWindows(Rect)} method.
             */
            const Int32 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN = 0x00000400;

            /**
             * Flag for {@link #setSystemUiVisibility(int)}: View would like to remain interactive when
             * hiding the navigation bar with {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION}.  If this flag is
             * not set, {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION} will be force cleared by the system on any
             * user interaction.
             * <p>Since this flag is a modifier for {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION}, it only
             * has an effect when used in combination with that flag.</p>
             */
            const Int32 SYSTEM_UI_FLAG_IMMERSIVE = 0x00000800;

            /**
             * Flag for {@link #setSystemUiVisibility(int)}: View would like to remain interactive when
             * hiding the status bar with {@link #SYSTEM_UI_FLAG_FULLSCREEN} and/or hiding the navigation
             * bar with {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION}.  Use this flag to create an immersive
             * experience while also hiding the system bars.  If this flag is not set,
             * {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION} will be force cleared by the system on any user
             * interaction, and {@link #SYSTEM_UI_FLAG_FULLSCREEN} will be force-cleared by the system
             * if the user swipes from the top of the screen.
             * <p>When system bars are hidden in immersive mode, they can be revealed temporarily with
             * system gestures, such as swiping from the top of the screen.  These transient system bars
             * will overlay app’s content, may have some degree of transparency, and will automatically
             * hide after a short timeout.
             * </p><p>Since this flag is a modifier for {@link #SYSTEM_UI_FLAG_FULLSCREEN} and
             * {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION}, it only has an effect when used in combination
             * with one or both of those flags.</p>
             */
            const Int32 SYSTEM_UI_FLAG_IMMERSIVE_STICKY = 0x00001000;

            /**
             * @deprecated Use {@link #SYSTEM_UI_FLAG_LOW_PROFILE} instead.
             */
            const Int32 STATUS_BAR_HIDDEN = SYSTEM_UI_FLAG_LOW_PROFILE;

            /**
             * @deprecated Use {@link #SYSTEM_UI_FLAG_VISIBLE} instead.
             */
            const Int32 STATUS_BAR_VISIBLE = SYSTEM_UI_FLAG_VISIBLE;

            /**
             * @hide
             *
             * NOTE: This flag may only be used in subtreeSystemUiVisibility. It is masked
             * out of the public fields to keep the undefined bits out of the developer's way.
             *
             * Flag to make the status bar not expandable.  Unless you also
             * set {@link #STATUS_BAR_DISABLE_NOTIFICATION_ICONS}, new notifications will continue to show.
             */
            const Int32 STATUS_BAR_DISABLE_EXPAND = 0x00010000;

            /**
             * @hide
             *
             * NOTE: This flag may only be used in subtreeSystemUiVisibility. It is masked
             * out of the public fields to keep the undefined bits out of the developer's way.
             *
             * Flag to hide notification icons and scrolling ticker text.
             */
            const Int32 STATUS_BAR_DISABLE_NOTIFICATION_ICONS = 0x00020000;

            /**
             * @hide
             *
             * NOTE: This flag may only be used in subtreeSystemUiVisibility. It is masked
             * out of the public fields to keep the undefined bits out of the developer's way.
             *
             * Flag to disable incoming notification alerts.  This will not block
             * icons, but it will block sound, vibrating and other visual or aural notifications.
             */
            const Int32 STATUS_BAR_DISABLE_NOTIFICATION_ALERTS = 0x00040000;

            /**
             * @hide
             *
             * NOTE: This flag may only be used in subtreeSystemUiVisibility. It is masked
             * out of the public fields to keep the undefined bits out of the developer's way.
             *
             * Flag to hide only the scrolling ticker.  Note that
             * {@link #STATUS_BAR_DISABLE_NOTIFICATION_ICONS} implies
             * {@link #STATUS_BAR_DISABLE_NOTIFICATION_TICKER}.
             */
            const Int32 STATUS_BAR_DISABLE_NOTIFICATION_TICKER = 0x00080000;

            /**
             * @hide
             *
             * NOTE: This flag may only be used in subtreeSystemUiVisibility. It is masked
             * out of the public fields to keep the undefined bits out of the developer's way.
             *
             * Flag to hide the center system info area.
             */
            const Int32 STATUS_BAR_DISABLE_SYSTEM_INFO = 0x00100000;

            /**
             * @hide
             *
             * NOTE: This flag may only be used in subtreeSystemUiVisibility. It is masked
             * out of the public fields to keep the undefined bits out of the developer's way.
             *
             * Flag to hide only the home button.  Don't use this
             * unless you're a special part of the system UI (i.e., setup wizard, keyguard).
             */
            const Int32 STATUS_BAR_DISABLE_HOME = 0x00200000;

            /**
             * @hide
             *
             * NOTE: This flag may only be used in subtreeSystemUiVisibility. It is masked
             * out of the public fields to keep the undefined bits out of the developer's way.
             *
             * Flag to hide only the back button. Don't use this
             * unless you're a special part of the system UI (i.e., setup wizard, keyguard).
             */
            const Int32 STATUS_BAR_DISABLE_BACK = 0x00400000;

            /**
             * @hide
             *
             * NOTE: This flag may only be used in subtreeSystemUiVisibility. It is masked
             * out of the public fields to keep the undefined bits out of the developer's way.
             *
             * Flag to hide only the clock.  You might use this if your activity has
             * its own clock making the status bar's clock redundant.
             */
            const Int32 STATUS_BAR_DISABLE_CLOCK = 0x00800000;

            /**
             * @hide
             *
             * NOTE: This flag may only be used in subtreeSystemUiVisibility. It is masked
             * out of the public fields to keep the undefined bits out of the developer's way.
             *
             * Flag to hide only the recent apps button. Don't use this
             * unless you're a special part of the system UI (i.e., setup wizard, keyguard).
             */
            const Int32 STATUS_BAR_DISABLE_RECENT = 0x01000000;

            /**
             * @hide
             *
             * NOTE: This flag may only be used in subtreeSystemUiVisibility. It is masked
             * out of the public fields to keep the undefined bits out of the developer's way.
             *
             * Flag to disable the global search gesture. Don't use this
             * unless you're a special part of the system UI (i.e., setup wizard, keyguard).
             */
            const Int32 STATUS_BAR_DISABLE_SEARCH = 0x02000000;

            /**
             * @hide
             *
             * NOTE: This flag may only be used in subtreeSystemUiVisibility. It is masked
             * out of the public fields to keep the undefined bits out of the developer's way.
             *
             * Flag to specify that the status bar is displayed in transient mode.
             */
            const Int32 STATUS_BAR_TRANSIENT = 0x04000000;

            /**
             * @hide
             *
             * NOTE: This flag may only be used in subtreeSystemUiVisibility. It is masked
             * out of the public fields to keep the undefined bits out of the developer's way.
             *
             * Flag to specify that the navigation bar is displayed in transient mode.
             */
            const Int32 NAVIGATION_BAR_TRANSIENT = 0x08000000;

            /**
             * @hide
             *
             * NOTE: This flag may only be used in subtreeSystemUiVisibility. It is masked
             * out of the public fields to keep the undefined bits out of the developer's way.
             *
             * Flag to specify that the hidden status bar would like to be shown.
             */
            const Int32 STATUS_BAR_UNHIDE = 0x10000000;

            /**
             * @hide
             *
             * NOTE: This flag may only be used in subtreeSystemUiVisibility. It is masked
             * out of the public fields to keep the undefined bits out of the developer's way.
             *
             * Flag to specify that the hidden navigation bar would like to be shown.
             */
            const Int32 NAVIGATION_BAR_UNHIDE = 0x20000000;

            /**
             * @hide
             *
             * NOTE: This flag may only be used in subtreeSystemUiVisibility. It is masked
             * out of the public fields to keep the undefined bits out of the developer's way.
             *
             * Flag to specify that the status bar is displayed in translucent mode.
             */
            const Int32 STATUS_BAR_TRANSLUCENT = 0x40000000;

            /**
             * @hide
             *
             * NOTE: This flag may only be used in subtreeSystemUiVisibility. It is masked
             * out of the public fields to keep the undefined bits out of the developer's way.
             *
             * Flag to specify that the navigation bar is displayed in translucent mode.
             */
            const Int32 NAVIGATION_BAR_TRANSLUCENT = 0x80000000;

            /**
             * @hide
             *
             * Whether Recents is visible or not.
             */
            const Int32 RECENT_APPS_VISIBLE = 0x00004000;

            /**
             * @hide
             *
             * Makes system ui transparent.
             */
            const Int32 SYSTEM_UI_TRANSPARENT = 0x00008000;

            /**
             * @hide
             */
            const Int32 PUBLIC_STATUS_BAR_VISIBILITY_MASK = 0x00003FFF;

            /**
             * These are the system UI flags that can be cleared by events outside
             * of an application.  Currently this is just the ability to tap on the
             * screen while hiding the navigation bar to have it return.
             * @hide
             */
            const Int32 SYSTEM_UI_CLEARABLE_FLAGS =
                    SYSTEM_UI_FLAG_LOW_PROFILE | SYSTEM_UI_FLAG_HIDE_NAVIGATION
                    | SYSTEM_UI_FLAG_FULLSCREEN;

            /**
             * Flags that can impact the layout in relation to system UI.
             */
            const Int32 SYSTEM_UI_LAYOUT_FLAGS =
                    SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                    | SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;

            /**
             * Find views that render the specified text.
             *
             * @see #findViewsWithText(ArrayList, CharSequence, int)
             */
            const Int32 FIND_VIEWS_WITH_TEXT = 0x00000001;

            /**
             * Find find views that contain the specified content description.
             *
             * @see #findViewsWithText(ArrayList, CharSequence, int)
             */
            const Int32 FIND_VIEWS_WITH_CONTENT_DESCRIPTION = 0x00000002;

            /**
             * Find views that contain {@link AccessibilityNodeProvider}. Such
             * a View is a root of virtual view hierarchy and may contain the searched
             * text. If this flag is set Views with providers are automatically
             * added and it is a responsibility of the client to call the APIs of
             * the provider to determine whether the virtual tree rooted at this View
             * contains the text, i.e. getting the list of {@link AccessibilityNodeInfo}s
             * represeting the virtual views with this text.
             *
             * @see #findViewsWithText(ArrayList, CharSequence, int)
             *
             * @hide
             */
            const Int32 FIND_VIEWS_WITH_ACCESSIBILITY_NODE_PROVIDERS = 0x00000004;

            /**
             * The undefined cursor position.
             *
             * @hide
             */
            const Int32 ACCESSIBILITY_CURSOR_POSITION_UNDEFINED = -1;

            /**
             * Indicates that the screen has changed state and is now off.
             *
             * @see #onScreenStateChanged(int)
             */
            const Int32 SCREEN_STATE_OFF = 0x0;

            /**
             * Indicates that the screen has changed state and is now on.
             *
             * @see #onScreenStateChanged(int)
             */
            const Int32 SCREEN_STATE_ON = 0x1;

            /**
             * Indicates no axis of view scrolling.
             */
            const Int32 SCROLL_AXIS_NONE = 0;

            /**
             * Indicates scrolling along the horizontal axis.
             */
            const Int32 SCROLL_AXIS_HORIZONTAL = 1 << 0;

            /**
             * Indicates scrolling along the vertical axis.
             */
            const Int32 SCROLL_AXIS_VERTICAL = 1 << 1;

            /**
             * Flag indicating that a drag can cross window boundaries.  When
             * {@link #startDrag(ClipData, DragShadowBuilder, Object, int)} is called
             * with this flag set, all visible applications will be able to participate
             * in the drag operation and receive the dragged content.
             *
             * @hide
             */
            const Int32 DRAG_FLAG_GLOBAL = 1;

            /**
             * Position the scroll bar at the default position as determined by the system.
             */
            const Int32 SCROLLBAR_POSITION_DEFAULT = 0;

            /**
             * Position the scroll bar along the left edge.
             */
            const Int32 SCROLLBAR_POSITION_LEFT = 1;

            /**
             * Position the scroll bar along the right edge.
             */
            const Int32 SCROLLBAR_POSITION_RIGHT = 2;

            /**
             * Indicates that the view does not have a layer.
             *
             * @see #getLayerType()
             * @see #setLayerType(int, android.graphics.Paint)
             * @see #LAYER_TYPE_SOFTWARE
             * @see #LAYER_TYPE_HARDWARE
             */
            const Int32 LAYER_TYPE_NONE = 0;

            /**
             * <p>Indicates that the view has a software layer. A software layer is backed
             * by a bitmap and causes the view to be rendered using Android's software
             * rendering pipeline, even if hardware acceleration is enabled.</p>
             *
             * <p>Software layers have various usages:</p>
             * <p>When the application is not using hardware acceleration, a software layer
             * is useful to apply a specific color filter and/or blending mode and/or
             * translucency to a view and all its children.</p>
             * <p>When the application is using hardware acceleration, a software layer
             * is useful to render drawing primitives not supported by the hardware
             * accelerated pipeline. It can also be used to cache a complex view tree
             * into a texture and reduce the complexity of drawing operations. For instance,
             * when animating a complex view tree with a translation, a software layer can
             * be used to render the view tree only once.</p>
             * <p>Software layers should be avoided when the affected view tree updates
             * often. Every update will require to re-render the software layer, which can
             * potentially be slow (particularly when hardware acceleration is turned on
             * since the layer will have to be uploaded into a hardware texture after every
             * update.)</p>
             *
             * @see #getLayerType()
             * @see #setLayerType(int, android.graphics.Paint)
             * @see #LAYER_TYPE_NONE
             * @see #LAYER_TYPE_HARDWARE
             */
            const Int32 LAYER_TYPE_SOFTWARE = 1;

            /**
             * <p>Indicates that the view has a hardware layer. A hardware layer is backed
             * by a hardware specific texture (generally Frame Buffer Objects or FBO on
             * OpenGL hardware) and causes the view to be rendered using Android's hardware
             * rendering pipeline, but only if hardware acceleration is turned on for the
             * view hierarchy. When hardware acceleration is turned off, hardware layers
             * behave exactly as {@link #LAYER_TYPE_SOFTWARE software layers}.</p>
             *
             * <p>A hardware layer is useful to apply a specific color filter and/or
             * blending mode and/or translucency to a view and all its children.</p>
             * <p>A hardware layer can be used to cache a complex view tree into a
             * texture and reduce the complexity of drawing operations. For instance,
             * when animating a complex view tree with a translation, a hardware layer can
             * be used to render the view tree only once.</p>
             * <p>A hardware layer can also be used to increase the rendering quality when
             * rotation transformations are applied on a view. It can also be used to
             * prevent potential clipping issues when applying 3D transforms on a view.</p>
             *
             * @see #getLayerType()
             * @see #setLayerType(int, android.graphics.Paint)
             * @see #LAYER_TYPE_NONE
             * @see #LAYER_TYPE_SOFTWARE
             */
            const Int32 LAYER_TYPE_HARDWARE = 2;


            /**
             * Returns the size of the vertical faded edges used to indicate that more
             * content in this view is visible.
             *
             * @return The size in pixels of the vertical faded edge or 0 if vertical
             *         faded edges are not enabled for this view.
             * @attr ref android.R.styleable#Int32 fadingEdgeLength
             */
            GetVerticalFadingEdgeLength(
                [out] Int32* length);

            /**
             * Set the size of the faded edge used to indicate that more content in this
             * view is available.  Will not change whether the fading edge is enabled; use
             * {@link #setVerticalFadingEdgeEnabled(boolean)} or
             * {@link #setHorizontalFadingEdgeEnabled(boolean)} to enable the fading edge
             * for the vertical or horizontal fading edges.
             *
             * @param length The size in pixels of the faded edge used to indicate that more
             *        content in this view is visible.
             */
            SetFadingEdgeLength(
                [in] Int32 length);

            /**
             * Returns the size of the horizontal faded edges used to indicate that more
             * content in this view is visible.
             *
             * @return The size in pixels of the horizontal faded edge or 0 if horizontal
             *         faded edges are not enabled for this view.
             * @attr ref android.R.styleable#Int32 fadingEdgeLength
             */
            GetHorizontalFadingEdgeLength(
                [out] Int32* length);

            /**
             * Returns the width of the vertical scrollbar.
             *
             * @return The width in pixels of the vertical scrollbar or 0 if there
             *         is no vertical scrollbar.
             */
            GetVerticalScrollbarWidth(
                [out] Int32* width);

            /**
             * Set the position of the vertical scroll bar. Should be one of
             * {@link #SCROLLBAR_POSITION_DEFAULT}, {@link #SCROLLBAR_POSITION_LEFT} or
             * {@link #SCROLLBAR_POSITION_RIGHT}.
             *
             * @param position Where the vertical scroll bar should be positioned.
             */
            SetVerticalScrollbarPosition(
                [in] Int32 position);

            /**
             * @return The position where the vertical scroll bar will show, if applicable.
             * @see #setVerticalScrollbarPosition(int)
             */
            GetVerticalScrollbarPosition(
                [out] Int32* position);

            /**
             * Returns the height of the horizontal scrollbar.
             *
             * @return The height in pixels of the horizontal scrollbar or 0 if
             *         there is no horizontal scrollbar.
             */
            GetHorizontalScrollbarHeight(
                [out] Int32* height);

            /**
             * Register a callback to be invoked when focus of this view changed.
             *
             * @param l The callback that will run.
             */
            SetOnFocusChangeListener(
                [in] IViewOnFocusChangeListener* l);

            /**
             * Add a listener that will be called when the bounds of the view change due to
             * layout processing.
             *
             * @param listener The listener that will be called when layout bounds change.
             */
            AddOnLayoutChangeListener(
                [in] IViewOnLayoutChangeListener* listener);

            /**
             * Remove a listener for layout changes.
             *
             * @param listener The listener for layout bounds change.
             */
            RemoveOnLayoutChangeListener(
                [in] IViewOnLayoutChangeListener* listener);

            /**
             * Add a listener for attach state changes.
             *
             * This listener will be called whenever this view is attached or detached
             * from a window. Remove the listener using
             * {@link #removeOnAttachStateChangeListener(OnAttachStateChangeListener)}.
             *
             * @param listener Listener to attach
             * @see #removeOnAttachStateChangeListener(OnAttachStateChangeListener)
             */
            AddOnAttachStateChangeListener(
                [in] IViewOnAttachStateChangeListener* listener);

            /**
             * Remove a listener for attach state changes. The listener will receive no further
             * notification of window attach/detach events.
             *
             * @param listener Listener to remove
             * @see #addOnAttachStateChangeListener(OnAttachStateChangeListener)
             */
            RemoveOnAttachStateChangeListener(
                [in] IViewOnAttachStateChangeListener* listener);

            /**
             * Returns the focus-change callback registered for this view.
             *
             * @return The callback, or NULL if one is not registered.
             */
            GetOnFocusChangeListener(
                [out] IViewOnFocusChangeListener** l);

            /**
             * Register a callback to be invoked when this view is clicked. If this view is not
             * clickable, it becomes clickable.
             *
             * @param l The callback that will run
             *
             * @see #setClickable(Boolean)
             */
            SetOnClickListener(
                [in] IViewOnClickListener* l);

            /**
             * Return whether this view has an attached OnClickListener.  Returns
             * true if there is a listener, false if there is none.
             */
            HasOnClickListeners(
                [out] Boolean* has);

            /**
             * Register a callback to be invoked when this view is clicked and held. If this view is not
             * long clickable, it becomes long clickable.
             *
             * @param l The callback that will run
             *
             * @see #setLongClickable(Boolean)
             */
            SetOnLongClickListener(
                [in] IViewOnLongClickListener* l);

            /**
             * Register a callback to be invoked when the context menu for this view is
             * being built. If this view is not long clickable, it becomes long clickable.
             *
             * @param l The callback that will run
             *
             */
            SetOnCreateContextMenuListener(
                [in] IViewOnCreateContextMenuListener* l);

            /**
             * Call this view's OnClickListener, if it is defined.  Performs all normal
             * actions associated with clicking: reporting accessibility event, playing
             * a sound, etc.
             *
             * @return True there was an assigned OnClickListener that was called, false
             *         otherwise is returned.
             */
            PerformClick(
                [out] Boolean* result);

            /**
             * Directly call any attached OnClickListener.  Unlike {@link #performClick()},
             * this only calls the listener, and does not do any associated clicking
             * actions like reporting an accessibility event.
             *
             * @return True there was an assigned OnClickListener that was called, false
             *         otherwise is returned.
             */
            CallOnClick(
                [out] Boolean* result);

            /**
             * Call this view's OnLongClickListener, if it is defined. Invokes the context menu if the
             * OnLongClickListener did not consume the event.
             *
             * @return True if one of the above receivers consumed the event, FALSE otherwise.
             */
            PerformLongClick(
                [out] Boolean* result);

            /**
             * Bring up the context menu for this view.
             *
             * @return Whether a context menu was displayed.
             */
            ShowContextMenu(
                [out] Boolean* result);

            /**
             * Bring up the context menu for this view, referring to the item under the specified point.
             *
             * @param x The referenced x coordinate.
             * @param y The referenced y coordinate.
             * @param metaState The keyboard modifiers that were pressed.
             * @return Whether a context menu was displayed.
             *
             * @hide
             */
            ShowContextMenu(
                [in] Float x,
                [in] Float y,
                [in] Int32 metaState,
                [out] Boolean* result);

            /**
             * Start an action mode.
             *
             * @param callback Callback that will control the lifecycle of the action mode
             * @return The new action mode if it is started, null otherwise
             *
             * @see ActionMode
             */
            StartActionMode(
                [in] IActionModeCallback* cback,
                [out] IActionMode** mode);

            /**
             * Register a callback to be invoked when a hardware key is pressed in this view.
             * Key presses in software input methods will generally not trigger the methods of
             * this listener.
             * @param l the key listener to attach to this view
             */
            SetOnKeyListener(
                [in] IViewOnKeyListener* l);

            /**
             * Register a callback to be invoked when a touch event is sent to this view.
             * @param l the touch listener to attach to this view
             */
            SetOnTouchListener(
                [in] IViewOnTouchListener* l);

            /**
             * Register a callback to be invoked when a generic motion event is sent to this view.
             * @param l the generic motion listener to attach to this view
             */
            SetOnGenericMotionListener(
                [in] IViewOnGenericMotionListener* l);

            /**
             * Register a callback to be invoked when a hover event is sent to this view.
             * @param l the hover listener to attach to this view
             */
            SetOnHoverListener(
                [in] IViewOnHoverListener* l);

            /**
             * Register a drag event listener callback object for this View. The parameter is
             * an implementation of {@link android.view.View.OnDragListener}. To send a drag event to a
             * View, the system calls the
             * {@link android.view.View.OnDragListener#onDrag(View,DragEvent)} method.
             * @param l An implementation of {@link android.view.View.OnDragListener}.
             */
            SetOnDragListener(
                [in] IViewOnDragListener* l);

            /**
             * Populates <code>outRect</code> with the hotspot bounds. By default,
             * the hotspot bounds are identical to the screen bounds.
             *
             * @param outRect rect to populate with hotspot bounds
             * @hide Only for internal use by views and widgets.
             */
            GetHotspotBounds(
                [in] IRect* outRect);

            /**
             * Request that a rectangle of this view be visible on the screen,
             * scrolling if necessary just enough.
             *
             * <p>A View should call this if it maintains some notion of which part
             * of its content is interesting.  For example, a text editing view
             * should call this when its cursor moves.
             *
             * @param rectangle The rectangle.
             * @return Whether any parent scrolled.
             */
            RequestRectangleOnScreen(
                [in] IRect* rectangle,
                [out] Boolean* result);

            /**
             * Request that a rectangle of this view be visible on the screen,
             * scrolling if necessary just enough.
             *
             * <p>A View should call this if it maintains some notion of which part
             * of its content is interesting.  For example, a text editing view
             * should call this when its cursor moves.
             *
             * <p>When <code>immediate</code> is set to true, scrolling will not be
             * animated.
             *
             * @param rectangle The rectangle.
             * @param immediate True to forbid animated scrolling, false otherwise
             * @return Whether any parent scrolled.
             */
            RequestRectangleOnScreen(
                [in] IRect* rectangle,
                [in] Boolean immediate,
                [out] Boolean* result);

            /**
             * Called when this view wants to give up focus. If focus is cleared
             * {@link #onFocusChanged(boolean, int, android.graphics.Rect)} is called.
             * <p>
             * <strong>Note:</strong> When a View clears focus the framework is trying
             * to give focus to the first focusable View from the top. Hence, if this
             * View is the first from the top that can take focus, then all callbacks
             * related to clearing focus will be invoked after wich the framework will
             * give focus to this view.
             * </p>
             */
            ClearFocus();

            /**
             * Returns true if this view has focus iteself, or is the ancestor of the
             * view that has focus.
             *
             * @return True if this view has or contains focus, false otherwise.
             */
            HasFocus(
                [out] Boolean* hasFocus);

            /**
             * Returns true if this view is focusable or if it contains a reachable View
             * for which {@link #hasFocusable()} returns true. A "reachable hasFocusable()"
             * is a View whose parents do not block descendants focus.
             *
             * Only {@link #VISIBLE} views are considered focusable.
             *
             * @return True if the view is focusable or if the view contains a focusable
             *         View, false otherwise.
             *
             * @see ViewGroup#FOCUS_BLOCK_DESCENDANTS
             */
            HasFocusable(
                [out] Boolean* hasFocusable);

            /**
             * Sends an accessibility event of the given type. If accessibility is
             * not enabled this method has no effect. The default implementation calls
             * {@link #onInitializeAccessibilityEvent(AccessibilityEvent)} first
             * to populate information about the event source (this View), then calls
             * {@link #dispatchPopulateAccessibilityEvent(AccessibilityEvent)} to
             * populate the text content of the event source including its descendants,
             * and last calls
             * {@link ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
             * on its parent to resuest sending of the event to interested parties.
             * <p>
             * If an {@link AccessibilityDelegate} has been specified via calling
             * {@link #setAccessibilityDelegate(AccessibilityDelegate)} its
             * {@link AccessibilityDelegate#sendAccessibilityEvent(View, int)} is
             * responsible for handling this call.
             * </p>
             *
             * @param eventType The type of the event to send, as defined by several types from
             * {@link android.view.accessibility.AccessibilityEvent}, such as
             * {@link android.view.accessibility.AccessibilityEvent#TYPE_VIEW_CLICKED} or
             * {@link android.view.accessibility.AccessibilityEvent#TYPE_VIEW_HOVER_ENTER}.
             *
             * @see #onInitializeAccessibilityEvent(AccessibilityEvent)
             * @see #dispatchPopulateAccessibilityEvent(AccessibilityEvent)
             * @see ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)
             * @see AccessibilityDelegate
             */
            SendAccessibilityEvent(
                [in] Int32 eventType);

            /**
             * Convenience method for sending a {@link AccessibilityEvent#TYPE_ANNOUNCEMENT}
             * {@link AccessibilityEvent} to make an announcement which is related to some
             * sort of a context change for which none of the events representing UI transitions
             * is a good fit. For example, announcing a new page in a book. If accessibility
             * is not enabled this method does nothing.
             *
             * @param text The announcement text.
             */
            AnnounceForAccessibility(
                [in] ICharSequence* text);

            /**
             * This method behaves exactly as {@link #sendAccessibilityEvent(int)} but
             * takes as an argument an empty {@link AccessibilityEvent} and does not
             * perform a check whether accessibility is enabled.
             * <p>
             * If an {@link AccessibilityDelegate} has been specified via calling
             * {@link #setAccessibilityDelegate(AccessibilityDelegate)} its
             * {@link AccessibilityDelegate#sendAccessibilityEventUnchecked(View, AccessibilityEvent)}
             * is responsible for handling this call.
             * </p>
             *
             * @param event The event to send.
             *
             * @see #sendAccessibilityEvent(int)
             */
            SendAccessibilityEventUnchecked(
                [in] IAccessibilityEvent* event);

            /**
             * Dispatches an {@link AccessibilityEvent} to the {@link View} children
             * to be populated.
             *
             * @param event The event.
             *
             * @return True if the event population was completed.
             */
            DispatchPopulateAccessibilityEvent(
                [in] IAccessibilityEvent* event,
                [out] Boolean* result);

            /**
             * Called from {@link #dispatchPopulateAccessibilityEvent(AccessibilityEvent)}
             * giving a chance to this View to populate the accessibility event with its
             * text content. While this method is free to modify event
             * attributes other than text content, doing so should normally be performed in
             * {@link #onInitializeAccessibilityEvent(AccessibilityEvent)}.
             * <p>
             * Example: Adding formatted date string to an accessibility event in addition
             *          to the text added by the super implementation:
             * <pre> public void onPopulateAccessibilityEvent(AccessibilityEvent event) {
             *     super.onPopulateAccessibilityEvent(event);
             *     final int flags = DateUtils.FORMAT_SHOW_DATE | DateUtils.FORMAT_SHOW_WEEKDAY;
             *     String selectedDateUtterance = DateUtils.formatDateTime(mContext,
             *         mCurrentDate.getTimeInMillis(), flags);
             *     event.getText().add(selectedDateUtterance);
             * }</pre>
             * <p>
             * If an {@link AccessibilityDelegate} has been specified via calling
             * {@link #setAccessibilityDelegate(AccessibilityDelegate)} its
             * {@link AccessibilityDelegate#onPopulateAccessibilityEvent(View, AccessibilityEvent)}
             * is responsible for handling this call.
             * </p>
             * <p class="note"><strong>Note:</strong> Always call the super implementation before adding
             * information to the event, in case the default implementation has basic information to add.
             * </p>
             *
             * @param event The accessibility event which to populate.
             *
             * @see #sendAccessibilityEvent(int)
             * @see #dispatchPopulateAccessibilityEvent(AccessibilityEvent)
             */
            OnPopulateAccessibilityEvent(
                [in] IAccessibilityEvent* event);

            /**
             * Initializes an {@link AccessibilityEvent} with information about
             * this View which is the event source. In other words, the source of
             * an accessibility event is the view whose state change triggered firing
             * the event.
             * <p>
             * Example: Setting the password property of an event in addition
             *          to properties set by the super implementation:
             * <pre> public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
             *     super.onInitializeAccessibilityEvent(event);
             *     event.setPassword(true);
             * }</pre>
             * <p>
             * If an {@link AccessibilityDelegate} has been specified via calling
             * {@link #setAccessibilityDelegate(AccessibilityDelegate)} its
             * {@link AccessibilityDelegate#onInitializeAccessibilityEvent(View, AccessibilityEvent)}
             * is responsible for handling this call.
             * </p>
             * <p class="note"><strong>Note:</strong> Always call the super implementation before adding
             * information to the event, in case the default implementation has basic information to add.
             * </p>
             * @param event The event to initialize.
             *
             * @see #sendAccessibilityEvent(int)
             * @see #dispatchPopulateAccessibilityEvent(AccessibilityEvent)
             */
            OnInitializeAccessibilityEvent(
                [in] IAccessibilityEvent* event);

            /**
             * Returns an {@link AccessibilityNodeInfo} representing this view from the
             * point of view of an {@link android.accessibilityservice.AccessibilityService}.
             * This method is responsible for obtaining an accessibility node info from a
             * pool of reusable instances and calling
             * {@link #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)} on this view to
             * initialize the former.
             * <p>
             * Note: The client is responsible for recycling the obtained instance by calling
             *       {@link AccessibilityNodeInfo#recycle()} to minimize object creation.
             * </p>
             *
             * @return A populated {@link AccessibilityNodeInfo}.
             *
             * @see AccessibilityNodeInfo
             */
            CreateAccessibilityNodeInfo(
                [out] IAccessibilityNodeInfo** info);

            /**
             * Initializes an {@link AccessibilityNodeInfo} with information about this view.
             * The base implementation sets:
             * <ul>
             *   <li>{@link AccessibilityNodeInfo#setParent(View)},</li>
             *   <li>{@link AccessibilityNodeInfo#setBoundsInParent(Rect)},</li>
             *   <li>{@link AccessibilityNodeInfo#setBoundsInScreen(Rect)},</li>
             *   <li>{@link AccessibilityNodeInfo#setPackageName(CharSequence)},</li>
             *   <li>{@link AccessibilityNodeInfo#setClassName(CharSequence)},</li>
             *   <li>{@link AccessibilityNodeInfo#setContentDescription(CharSequence)},</li>
             *   <li>{@link AccessibilityNodeInfo#setEnabled(boolean)},</li>
             *   <li>{@link AccessibilityNodeInfo#setClickable(boolean)},</li>
             *   <li>{@link AccessibilityNodeInfo#setFocusable(boolean)},</li>
             *   <li>{@link AccessibilityNodeInfo#setFocused(boolean)},</li>
             *   <li>{@link AccessibilityNodeInfo#setLongClickable(boolean)},</li>
             *   <li>{@link AccessibilityNodeInfo#setSelected(boolean)},</li>
             * </ul>
             * <p>
             * Subclasses should override this method, call the super implementation,
             * and set additional attributes.
             * </p>
             * <p>
             * If an {@link AccessibilityDelegate} has been specified via calling
             * {@link #setAccessibilityDelegate(AccessibilityDelegate)} its
             * {@link AccessibilityDelegate#onInitializeAccessibilityNodeInfo(View, AccessibilityNodeInfo)}
             * is responsible for handling this call.
             * </p>
             *
             * @param info The instance to initialize.
             */
            OnInitializeAccessibilityNodeInfo(
                [in] IAccessibilityNodeInfo* info);

            GetBoundsOnScreen(
                [in] IRect* outRect);

            /**
             * Returns the delegate for implementing accessibility support via
             * composition. For more details see {@link AccessibilityDelegate}.
             *
             * @return The delegate, or null if none set.
             *
             * @hide
             */
            GetAccessibilityDelegate(
                [out] IAccessibilityDelegate** accessibilityDelegate);

            /**
             * Sets a delegate for implementing accessibility support via composition as
             * opposed to inheritance. The delegate's primary use is for implementing
             * backwards compatible widgets. For more details see {@link AccessibilityDelegate}.
             *
             * @param delegate The delegate instance.
             *
             * @see AccessibilityDelegate
             */
            SetAccessibilityDelegate(
                [in] IAccessibilityDelegate* accessibilityDelegate);

            /**
             * Gets the provider for managing a virtual view hierarchy rooted at this View
             * and reported to {@link android.accessibilityservice.AccessibilityService}s
             * that explore the window content.
             * <p>
             * If this method returns an instance, this instance is responsible for managing
             * {@link AccessibilityNodeInfo}s describing the virtual sub-tree rooted at this
             * View including the one representing the View itself. Similarly the returned
             * instance is responsible for performing accessibility actions on any virtual
             * view or the root view itself.
             * </p>
             * <p>
             * If an {@link AccessibilityDelegate} has been specified via calling
             * {@link #setAccessibilityDelegate(AccessibilityDelegate)} its
             * {@link AccessibilityDelegate#getAccessibilityNodeProvider(View)}
             * is responsible for handling this call.
             * </p>
             *
             * @return The provider.
             *
             * @see AccessibilityNodeProvider
             */
            GetAccessibilityNodeProvider(
                [out] IAccessibilityNodeProvider** provider);

            /**
             * Gets the unique identifier of this view on the screen for accessibility purposes.
             * If this {@link View} is not attached to any window, {@value #NO_ID} is returned.
             *
             * @return The view accessibility id.
             *
             * @hide
             */
            GetAccessibilityViewId(
                [out] Int32* id);

            /**
             * Gets the unique identifier of the window in which this View reseides.
             *
             * @return The window accessibility id.
             *
             * @hide
             */
            GetAccessibilityWindowId(
                [out] Int32* id);

            /**
             * Gets the {@link View} description. It briefly describes the view and is
             * primarily used for accessibility support. Set this property to enable
             * better accessibility support for your application. This is especially
             * true for views that do not have textual representation (For example,
             * ImageButton).
             *
             * @return The content description.
             *
             * @attr ref android.R.styleable#View_contentDescription
             */
            GetContentDescription(
                [out] ICharSequence** seq);

            /**
             * Sets the {@link View} description. It briefly describes the view and is
             * primarily used for accessibility support. Set this property to enable
             * better accessibility support for your application. This is especially
             * true for views that do not have textual representation (For example,
             * ImageButton).
             *
             * @param contentDescription The content description.
             *
             * @attr ref android.R.styleable#View_contentDescription
             */
            SetContentDescription(
                [in] ICharSequence* seq);

            /**
             * Gets the id of a view for which this view serves as a label for
             * accessibility purposes.
             *
             * @return The labeled view id.
             */
            //@ViewDebug.ExportedProperty(category = "accessibility")
            GetLabelFor(
                [out] Int32* id);

            /**
             * Sets the id of a view for which this view serves as a label for
             * accessibility purposes.
             *
             * @param id The labeled view id.
             */
            //@RemotableViewMethod
            SetLabelFor(
                [in] Int32 id);

            /**
             * Returns true if this view has focus
             *
             * @return True if this view has focus, false otherwise.
             */
            IsFocused(
                [out] Boolean* focused);

            /**
             * Find the view in the hierarchy rooted at this view that currently has
             * focus.
             *
             * @return The view that currently has focus, or NULL if no focused view can
             *         be found.
             */
            FindFocus(
                [out] IView** view);

            /**
             * Indicates whether this view is one of the set of scrollable containers in
             * its window.
             *
             * @return whether this view is one of the set of scrollable containers in
             * its window
             *
             * @attr ref android.R.styleable#View_isScrollContainer
             */
            IsScrollContainer(
                [out] Boolean* result);

            /**
             * Change whether this view is one of the set of scrollable containers in
             * its window.  This will be used to determine whether the window can
             * resize or must pan when a soft input area is open -- scrollable
             * containers allow the window to use resize mode since the container
             * will appropriately shrink.
             *
             * @attr ref android.R.styleable#View_isScrollContainer
             */
            SetScrollContainer(
                [in] Boolean isScrollContainer);

            /**
             * Returns the quality of the drawing cache.
             *
             * @return One of {@link #DRAWING_CACHE_QUALITY_AUTO},
             *         {@link #DRAWING_CACHE_QUALITY_LOW}, or {@link #DRAWING_CACHE_QUALITY_HIGH}
             *
             * @see #setDrawingCacheQuality(int)
             * @see #setDrawingCacheEnabled(boolean)
             * @see #isDrawingCacheEnabled()
             *
             * @attr ref android.R.styleable#Int32 drawingCacheQuality
             */
            GetDrawingCacheQuality(
                [out] Int32* quality);

            /**
             * Set the drawing cache quality of this view. This value is used only when the
             * drawing cache is enabled
             *
             * @param quality One of {@link #DRAWING_CACHE_QUALITY_AUTO},
             *        {@link #DRAWING_CACHE_QUALITY_LOW}, or {@link #DRAWING_CACHE_QUALITY_HIGH}
             *
             * @see #getDrawingCacheQuality()
             * @see #setDrawingCacheEnabled(boolean)
             * @see #isDrawingCacheEnabled()
             *
             * @attr ref android.R.styleable#Int32 drawingCacheQuality
             */
            SetDrawingCacheQuality(
                [in] Int32 quality);

            /**
             * Returns whether the screen should remain on, corresponding to the current
             * value of {@link #KEEP_SCREEN_ON}.
             *
             * @return Returns true if {@link #KEEP_SCREEN_ON} is set.
             *
             * @see #setKeepScreenOn(boolean)
             *
             * @attr ref android.R.styleable#Int32 keepScreenOn
             */
            GetKeepScreenOn(
                [out] Boolean* result);

            /**
             * Controls whether the screen should remain on, modifying the
             * value of {@link #KEEP_SCREEN_ON}.
             *
             * @param keepScreenOn Supply true to set {@link #KEEP_SCREEN_ON}.
             *
             * @see #getKeepScreenOn()
             *
             * @attr ref android.R.styleable#Int32 keepScreenOn
             */
            SetKeepScreenOn(
                [in] Boolean keepScreenOn);

            /**
             * Gets the id of the view to use when the next focus is {@link #FOCUS_LEFT}.
             * @return The next focus ID, or {@link #NO_ID} if the framework should decide automatically.
             *
             * @attr ref android.R.styleable#View_nextFocusLeft
             */
            GetNextFocusLeftId(
                [out] Int32* nextFocusLeftId);

            /**
             * Sets the id of the view to use when the next focus is {@link #FOCUS_LEFT}.
             * @param nextFocusLeftId The next focus ID, or {@link #NO_ID} if the framework should
             * decide automatically.
             *
             * @attr ref android.R.styleable#View_nextFocusLeft
             */
            SetNextFocusLeftId(
                [in] Int32 nextFocusLeftId);

            /**
             * Gets the id of the view to use when the next focus is {@link #FOCUS_RIGHT}.
             * @return The next focus ID, or {@link #NO_ID} if the framework should decide automatically.
             *
             * @attr ref android.R.styleable#View_nextFocusRight
             */
            GetNextFocusRightId(
                [out] Int32* nextFocusRightId);

            /**
             * Sets the id of the view to use when the next focus is {@link #FOCUS_RIGHT}.
             * @param nextFocusRightId The next focus ID, or {@link #NO_ID} if the framework should
             * decide automatically.
             *
             * @attr ref android.R.styleable#View_nextFocusRight
             */
            SetNextFocusRightId(
                [in] Int32 nextFocusRightId);

            /**
             * Gets the id of the view to use when the next focus is {@link #FOCUS_UP}.
             * @return The next focus ID, or {@link #NO_ID} if the framework should decide automatically.
             *
             * @attr ref android.R.styleable#View_nextFocusUp
             */
            GetNextFocusUpId(
                [out] Int32* nextFocusUpId);

            /**
             * Sets the id of the view to use when the next focus is {@link #FOCUS_UP}.
             * @param nextFocusUpId The next focus ID, or {@link #NO_ID} if the framework should
             * decide automatically.
             *
             * @attr ref android.R.styleable#View_nextFocusUp
             */
            SetNextFocusUpId(
                [in] Int32 nextFocusUpId);

            /**
             * Gets the id of the view to use when the next focus is {@link #FOCUS_DOWN}.
             * @return The next focus ID, or {@link #NO_ID} if the framework should decide automatically.
             *
             * @attr ref android.R.styleable#View_nextFocusDown
             */
            GetNextFocusDownId(
                [out] Int32* nextFocusDownId);

            /**
             * Sets the id of the view to use when the next focus is {@link #FOCUS_DOWN}.
             * @param nextFocusDownId The next focus ID, or {@link #NO_ID} if the framework should
             * decide automatically.
             *
             * @attr ref android.R.styleable#View_nextFocusDown
             */
            SetNextFocusDownId(
                [in] Int32 nextFocusDownId);

            /**
             * Gets the id of the view to use when the next focus is {@link #FOCUS_FORWARD}.
             * @return The next focus ID, or {@link #NO_ID} if the framework should decide automatically.
             *
             * @attr ref android.R.styleable#View_nextFocusForward
             */
            GetNextFocusForwardId(
                [out] Int32* id);

            /**
             * Sets the id of the view to use when the next focus is {@link #FOCUS_FORWARD}.
             * @param nextFocusForwardId The next focus ID, or {@link #NO_ID} if the framework should
             * decide automatically.
             *
             * @attr ref android.R.styleable#View_nextFocusForward
             */
            SetNextFocusForwardId(
                [in] Int32 nextFocusForwardId);

            /**
             * Returns the visibility of this view and all of its ancestors
             *
             * @return True if this view and all of its ancestors are {@link #VISIBLE}
             */
            IsShown(
                [out] Boolean* shown);

            /**
             * Called when the view should apply {@link WindowInsets} according to its internal policy.
             *
             * <p>This method should be overridden by views that wish to apply a policy different from or
             * in addition to the default behavior. Clients that wish to force a view subtree
             * to apply insets should call {@link #dispatchApplyWindowInsets(WindowInsets)}.</p>
             *
             * <p>Clients may supply an {@link OnApplyWindowInsetsListener} to a view. If one is set
             * it will be called during dispatch instead of this method. The listener may optionally
             * call this method from its own implementation if it wishes to apply the view's default
             * insets policy in addition to its own.</p>
             *
             * <p>Implementations of this method should either return the insets parameter unchanged
             * or a new {@link WindowInsets} cloned from the supplied insets with any insets consumed
             * that this view applied itself. This allows new inset types added in future platform
             * versions to pass through existing implementations unchanged without being erroneously
             * consumed.</p>
             *
             * <p>By default if a view's {@link #setFitsSystemWindows(boolean) fitsSystemWindows}
             * property is set then the view will consume the system window insets and apply them
             * as padding for the view.</p>
             *
             * @param insets Insets to apply
             * @return The supplied insets with any applied insets consumed
             */
            OnApplyWindowInsets(
                [in] IWindowInsets* insets,
                [out] IWindowInsets** result);

            /**
             * Set an {@link OnApplyWindowInsetsListener} to take over the policy for applying
             * window insets to this view. The listener's
             * {@link OnApplyWindowInsetsListener#onApplyWindowInsets(View, WindowInsets) onApplyWindowInsets}
             * method will be called instead of the view's
             * {@link #onApplyWindowInsets(WindowInsets) onApplyWindowInsets} method.
             *
             * @param listener Listener to set
             *
             * @see #onApplyWindowInsets(WindowInsets)
             */
            SetOnApplyWindowInsetsListener(
                [in] IViewOnApplyWindowInsetsListener* listener);

            /**
             * Request to apply the given window insets to this view or another view in its subtree.
             *
             * <p>This method should be called by clients wishing to apply insets corresponding to areas
             * obscured by window decorations or overlays. This can include the status and navigation bars,
             * action bars, input methods and more. New inset categories may be added in the future.
             * The method returns the insets provided minus any that were applied by this view or its
             * children.</p>
             *
             * <p>Clients wishing to provide custom behavior should override the
             * {@link #onApplyWindowInsets(WindowInsets)} method or alternatively provide a
             * {@link OnApplyWindowInsetsListener} via the
             * {@link #setOnApplyWindowInsetsListener(View.OnApplyWindowInsetsListener) setOnApplyWindowInsetsListener}
             * method.</p>
             *
             * <p>This method replaces the older {@link #fitSystemWindows(Rect) fitSystemWindows} method.
             * </p>
             *
             * @param insets Insets to apply
             * @return The provided insets minus the insets that were consumed
             */
            DispatchApplyWindowInsets(
                [in] IWindowInsets* insets,
                [out] IWindowInsets** res);

            /**
             * Compute insets that should be consumed by this view and the ones that should propagate
             * to those under it.
             *
             * @param in Insets currently being processed by this View, likely received as a parameter
             *           to {@link #onApplyWindowInsets(WindowInsets)}.
             * @param outLocalInsets A Rect that will receive the insets that should be consumed
             *                       by this view
             * @return Insets that should be passed along to views under this one
             */
            ComputeSystemWindowInsets(
                [in] IWindowInsets* insets,
                [in] IRect* outLocalInsets,
                [out] IWindowInsets** result);

            /**
             * Sets whether or not this view should account for system screen decorations
             * such as the status bar and inset its content; that is, controlling whether
             * the default implementation of {@link #fitSystemWindows(Rect)} will be
             * executed.  See that method for more details.
             *
             * <p>Note that if you are providing your own implementation of
             * {@link #fitSystemWindows(Rect)}, then there is no need to set this
             * flag to true -- your implementation will be overriding the default
             * implementation that checks this flag.
             *
             * @param fitSystemWindows If true, then the default implementation of
             * {@link #fitSystemWindows(Rect)} will be executed.
             *
             * @attr ref android.R.styleable#View_fitsSystemWindows
             * @see #getFitsSystemWindows()
             * @see #fitSystemWindows(Rect)
             * @see #setSystemUiVisibility(int)
             */
            SetFitsSystemWindows(
                [in] Boolean fitSystemWindows);

            /**
             * Check for state of {@link #setFitsSystemWindows(boolean). If this method
             * returns true, the default implementation of {@link #fitSystemWindows(Rect)}
             * will be executed.
             *
             * @return Returns true if the default implementation of
             * {@link #fitSystemWindows(Rect)} will be executed.
             *
             * @attr ref android.R.styleable#View_fitsSystemWindows
             * @see #setFitsSystemWindows()
             * @see #fitSystemWindows(Rect)
             * @see #setSystemUiVisibility(int)
             */
            GetFitsSystemWindows(
                [out] Boolean* result);

            /** @hide */
            FitsSystemWindows(
                [out] Boolean* result);

            /**
             * Ask that a new dispatch of {@link #fitSystemWindows(Rect)} be performed.
             */
            RequestFitSystemWindows();

            /**
             * Ask that a new dispatch of {@link #onApplyWindowInsets(WindowInsets)} be performed.
             */
            RequestApplyInsets();

            /**
             * For use by PhoneWindow to make its own system window fitting optional.
             * @hide
             */
            MakeOptionalFitsSystemWindows();

            /**
             * Returns the visibility status for this view.
             *
             * @param visibility One of {@link #VISIBLE}, {@link #INVISIBLE}, or {@link #GONE}.
             * @attr ref android.R.styleable#Int32 visibility
             */
            GetVisibility(
                [out] Int32* visibility);

            /**
             * Set the enabled state of this view.
             *
             * @param visibility One of {@link #VISIBLE}, {@link #INVISIBLE}, or {@link #GONE}.
             * @attr ref android.R.styleable#Int32 visibility
             */
            SetVisibility(
                [in] Int32 visibility);

            /**
             * Returns the enabled status for this view. The interpretation of the
             * enabled state varies by subclass.
             *
             * @return True if this view is enabled, false otherwise.
             */
            IsEnabled(
                [out] Boolean* enabled);

            /**
             * Set the enabled state of this view. The interpretation of the enabled
             * state varies by subclass.
             *
             * @param enabled True if this view is enabled, false otherwise.
             */
            SetEnabled(
                [in] Boolean enabled);

            /**
             * Set whether this view can receive the focus.
             *
             * Setting this to false will also ensure that this view is not focusable
             * in touch mode.
             *
             * @param focusable If true, this view can receive the focus.
             *
             * @see #setFocusableInTouchMode(boolean)
             * @attr ref android.R.styleable#Int32 focusable
             */
            SetFocusable(
                [in] Boolean focusable);

            /**
             * Set whether this view can receive focus while in touch mode.
             *
             * Setting this to true will also ensure that this view is focusable.
             *
             * @param focusableInTouchMode If true, this view can receive the focus while
             *   in touch mode.
             *
             * @see #setFocusable(boolean)
             * @attr ref android.R.styleable#Int32 focusableInTouchMode
             */
            SetFocusableInTouchMode(
                [in] Boolean focusableInTouchMode);

            /**
             * Set whether this view should have sound effects enabled for events such as
             * clicking and touching.
             *
             * <p>You may wish to disable sound effects for a view if you already play sounds,
             * for instance, a dial key that plays dtmf tones.
             *
             * @param soundEffectsEnabled whether sound effects are enabled for this view.
             * @see #isSoundEffectsEnabled()
             * @see #playSoundEffect(int)
             * @attr ref android.R.styleable#Int32 soundEffectsEnabled
             */
            SetSoundEffectsEnabled(
                [in] Boolean soundEffectsEnabled);

            /**
             * @return whether this view should have sound effects enabled for events such as
             *     clicking and touching.
             *
             * @see #setSoundEffectsEnabled(boolean)
             * @see #playSoundEffect(int)
             * @attr ref android.R.styleable#Int32 soundEffectsEnabled
             */
            IsSoundEffectsEnabled(
                [out] Boolean* soundEffectsEnabled);

            /**
             * Set whether this view should have haptic feedback for events such as
             * long presses.
             *
             * <p>You may wish to disable haptic feedback if your view already controls
             * its own haptic feedback.
             *
             * @param hapticFeedbackEnabled whether haptic feedback enabled for this view.
             * @see #isHapticFeedbackEnabled()
             * @see #performHapticFeedback(int)
             * @attr ref android.R.styleable#Int32 hapticFeedbackEnabled
             */
            SetHapticFeedbackEnabled(
                [in] Boolean hapticFeedbackEnabled);

            /**
             * @return whether this view should have haptic feedback enabled for events
             * long presses.
             *
             * @see #setHapticFeedbackEnabled(boolean)
             * @see #performHapticFeedback(int)
             * @attr ref android.R.styleable#Int32 hapticFeedbackEnabled
             */
            IsHapticFeedbackEnabled(
                [out] Boolean* hapticFeedbackEnabled);

            /**
             * Returns the layout direction for this view.
             *
             * @return One of {@link #LAYOUT_DIRECTION_LTR},
             *   {@link #LAYOUT_DIRECTION_RTL},
             *   {@link #LAYOUT_DIRECTION_INHERIT} or
             *   {@link #LAYOUT_DIRECTION_LOCALE}.
             * @attr ref android.R.styleable#View_layoutDirection
             *
             * @hide
             */
            //@ViewDebug.ExportedProperty(category = "layout", mapping = {
            //    @ViewDebug.IntToString(from = LAYOUT_DIRECTION_LTR,     to = "LTR"),
            //    @ViewDebug.IntToString(from = LAYOUT_DIRECTION_RTL,     to = "RTL"),
            //    @ViewDebug.IntToString(from = LAYOUT_DIRECTION_INHERIT, to = "INHERIT"),
            //    @ViewDebug.IntToString(from = LAYOUT_DIRECTION_LOCALE,  to = "LOCALE")
            //})
            GetRawLayoutDirection(
                [out] Int32* direction);

            /**
             * Set the layout direction for this view. This will propagate a reset of layout direction
             * resolution to the view's children and resolve layout direction for this view.
             *
             * @param layoutDirection the layout direction to set. Should be one of:
             *
             * {@link #LAYOUT_DIRECTION_LTR},
             * {@link #LAYOUT_DIRECTION_RTL},
             * {@link #LAYOUT_DIRECTION_INHERIT},
             * {@link #LAYOUT_DIRECTION_LOCALE}.
             *
             * Resolution will be done if the value is set to LAYOUT_DIRECTION_INHERIT. The resolution
             * proceeds up the parent chain of the view to get the value. If there is no parent, then it
             * will return the default {@link #LAYOUT_DIRECTION_LTR}.
             *
             * @attr ref android.R.styleable#View_layoutDirection
             */
            //@RemotableViewMethod
            SetLayoutDirection(
                [in] Int32 layoutDirection);

            /**
             * Returns the resolved layout direction for this view.
             *
             * @return {@link #LAYOUT_DIRECTION_RTL} if the layout direction is RTL or returns
             * {@link #LAYOUT_DIRECTION_LTR} if the layout direction is not RTL.
             *
             * For compatibility, this will return {@link #LAYOUT_DIRECTION_LTR} if API version
             * is lower than {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}.
             */
            // @ViewDebug.ExportedProperty(category = "layout", mapping = {
            //     @ViewDebug.IntToString(from = LAYOUT_DIRECTION_LTR, to = "RESOLVED_DIRECTION_LTR"),
            //     @ViewDebug.IntToString(from = LAYOUT_DIRECTION_RTL, to = "RESOLVED_DIRECTION_RTL")
            // })
            GetLayoutDirection(
                [out] Int32* direction);

            /**
             * Indicates whether or not this view's layout is right-to-left. This is resolved from
             * layout attribute and/or the inherited value from the parent
             *
             * @return true if the layout is right-to-left.
             *
             * @hide
             */
            //@ViewDebug.ExportedProperty(category = "layout")
            IsLayoutRtl(
                [out] Boolean* rtl);

            /**
             * Indicates whether the view is currently tracking transient state that the
             * app should not need to concern itself with saving and restoring, but that
             * the framework should take special note to preserve when possible.
             *
             * <p>A view with transient state cannot be trivially rebound from an external
             * data source, such as an adapter binding item views in a list. This may be
             * because the view is performing an animation, tracking user selection
             * of content, or similar.</p>
             *
             * @return true if the view has transient state
             */
            //@ViewDebug.ExportedProperty(category = "layout")
            HasTransientState(
                [out] Boolean* has);

            /**
             * Set whether this view is currently tracking transient state that the
             * framework should attempt to preserve when possible. This flag is reference counted,
             * so every call to setHasTransientState(true) should be paired with a later call
             * to setHasTransientState(false).
             *
             * <p>A view with transient state cannot be trivially rebound from an external
             * data source, such as an adapter binding item views in a list. This may be
             * because the view is performing an animation, tracking user selection
             * of content, or similar.</p>
             *
             * @param hasTransientState true if this view has transient state
             */
            SetHasTransientState(
                [in] Boolean hasTransientState);

            /**
             * Returns true if this view is currently attached to a window.
             */
            IsAttachedToWindow(
                [out] Boolean* result);

            /**
             * Returns true if this view has been through at least one layout since it
             * was last attached to or detached from a window.
             */
            IsLaidOut(
                [out] Boolean* result);

            /**
             * If this view doesn't do any drawing on its own, set this flag to
             * allow further optimizations. By default, this flag is not set on
             * View, but could be set on some View subclasses such as ViewGroup.
             *
             * Typically, if you override {@link #onDraw(android.graphics.Canvas)}
             * you should clear this flag.
             *
             * @param willNotDraw whether or not this View draw on its own
             */
            SetWillNotDraw(
                [in] Boolean willNotDraw);

            /**
             * Returns whether or not this View draws on its own.
             *
             * @return true if this view has nothing to draw, false otherwise
             */
            WillNotDraw(
                [out] Boolean* willNotDraw);

            /**
             * When a View's drawing cache is enabled, drawing is redirected to an
             * offscreen bitmap. Some views, like an ImageView, must be able to
             * bypass this mechanism if they already draw a single bitmap, to avoid
             * unnecessary usage of the memory.
             *
             * @param willNotCacheDrawing true if this view does not cache its
             *        drawing, false otherwise
             */
            SetWillNotCacheDrawing(
                [in] Boolean willNotCacheDrawing);

            /**
             * Returns whether or not this View can cache its drawing or not.
             *
             * @return true if this view does not cache its drawing, false otherwise
             */
            WillNotCacheDrawing(
                [out] Boolean* cache);

            /**
             * Indicates whether this view reacts to click events or not.
             *
             * @return true if the view is clickable, false otherwise
             *
             * @see #setClickable(boolean)
             * @attr ref android.R.styleable#Int32 clickable
             */
            IsClickable(
                [out] Boolean* clickable);

            /**
             * Enables or disables click events for this view. When a view
             * is clickable it will change its state to "pressed" on every click.
             * Subclasses should set the view clickable to visually react to
             * user's clicks.
             *
             * @param clickable true to make the view clickable, false otherwise
             *
             * @see #isClickable()
             * @attr ref android.R.styleable#Int32 clickable
             */
            SetClickable(
                [in] Boolean clickable);

            /**
             * Indicates whether this view reacts to long click events or not.
             *
             * @return true if the view is long clickable, false otherwise
             *
             * @see #setLongClickable(boolean)
             * @attr ref android.R.styleable#Int32 longClickable
             */
            IsLongClickable(
                [out] Boolean* longClickable);

            /**
             * Enables or disables long click events for this view. When a view is long
             * clickable it reacts to the user holding down the button for a longer
             * duration than a tap. This event can either launch the listener or a
             * context menu.
             *
             * @param longClickable true to make the view long clickable, false otherwise
             * @see #isLongClickable()
             * @attr ref android.R.styleable#Int32 longClickable
             */
            SetLongClickable(
                [in] Boolean longClickable);

            /**
             * Sets the pressed state for this view.
             *
             * @see #isClickable()
             * @see #setClickable(boolean)
             *
             * @param pressed Pass true to set the View's internal state to "pressed", or false to reverts
             *        the View's internal state from a previously set "pressed" state.
             */
            SetPressed(
                [in] Boolean pressed);

            /**
             * Indicates whether the view is currently in pressed state. Unless
             * {@link #setPressed(boolean)} is explicitly called, only clickable views can enter
             * the pressed state.
             *
             * @see #setPressed(boolean)
             * @see #isClickable()
             * @see #setClickable(boolean)
             *
             * @return true if the view is currently pressed, false otherwise
             */
            IsPressed(
                [out] Boolean* pressed);

            /**
             * Indicates whether this view will save its state (that is,
             * whether its {@link #onSaveInstanceState} method will be called).
             *
             * @return Returns true if the view state saving is enabled, else false.
             *
             * @see #setSaveEnabled(boolean)
             * @attr ref android.R.styleable#Int32 saveEnabled
             */
            IsSaveEnabled(
                [out] Boolean* enabled);

            /**
             * Controls whether the saving of this view's state is
             * enabled (that is, whether its {@link #onSaveInstanceState} method
             * will be called).  Note that even if freezing is enabled, the
             * view still must have an id assigned to it (via {@link #setId(int)})
             * for its state to be saved.  This flag can only disable the
             * saving of this view; any child views may still have their state saved.
             *
             * @param enabled Set to false to <em>disable</em> state saving, or true
             * (the default) to allow it.
             *
             * @see #isSaveEnabled()
             * @see #setId(int)
             * @see #onSaveInstanceState()
             * @attr ref android.R.styleable#View_saveEnabled
             */
            SetSaveEnabled(
                [in] Boolean enabled);

            /**
             * Gets whether the framework should discard touches when the view's
             * window is obscured by another visible window.
             * Refer to the {@link View} security documentation for more details.
             *
             * @return True if touch filtering is enabled.
             *
             * @see #setFilterTouchesWhenObscured(boolean)
             * @attr ref android.R.styleable#Int32 filterTouchesWhenObscured
             */
            GetFilterTouchesWhenObscured(
                [out] Boolean* enabled);

            /**
             * Sets whether the framework should discard touches when the view's
             * window is obscured by another visible window.
             * Refer to the {@link View} security documentation for more details.
             *
             * @param enabled True if touch filtering should be enabled.
             *
             * @see #getFilterTouchesWhenObscured
             * @attr ref android.R.styleable#Int32 filterTouchesWhenObscured
             */
            SetFilterTouchesWhenObscured(
                [in] Boolean enabled);

            /**
             * Indicates whether the entire hierarchy under this view will save its
             * state when a state saving traversal occurs from its parent.  The default
             * is true; if false, these views will not be saved unless
             * {@link #saveHierarchyState(SparseArray)} is called directly on this view.
             *
             * @return Returns true if the view state saving from parent is enabled, else false.
             *
             * @see #setSaveFromParentEnabled(boolean)
             */
            IsSaveFromParentEnabled(
                [out] Boolean* enabled);

            /**
             * Controls whether the entire hierarchy under this view will save its
             * state when a state saving traversal occurs from its parent.  The default
             * is true; if false, these views will not be saved unless
             * {@link #saveHierarchyState(SparseArray)} is called directly on this view.
             *
             * @param enabled Set to false to <em>disable</em> state saving, or true
             * (the default) to allow it.
             *
             * @see #isSaveFromParentEnabled()
             * @see #setId(int)
             * @see #onSaveInstanceState()
             */
            SetSaveFromParentEnabled(
                [in] Boolean enabled);

            /**
             * Returns whether this View is able to take focus.
             *
             * @return True if this view can take focus, or false otherwise.
             * @attr ref android.R.styleable#Int32 focusable
             */
            IsFocusable(
                [out] Boolean* focusable);

            /**
             * When a view is focusable, it may not want to take focus when in touch mode.
             * For example, a button would like focus when the user is navigating via a D-pad
             * so that the user can click on it, but once the user starts touching the screen,
             * the button shouldn't take focus
             * @return Whether the view is focusable in touch mode.
             * @attr ref android.R.styleable#Int32 focusableInTouchMode
             */
            IsFocusableInTouchMode(
                [out] Boolean* focusable);

            /**
             * Find the nearest view in the specified direction that can take focus.
             * This does not actually give focus to that view.
             *
             * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
             *
             * @return The nearest focusable in the specified direction, or NULL if none
             *         can be found.
             */
            FocusSearch(
                [in] Int32 direction,
                [out] IView** view);

            /**
             * This method is the last chance for the focused view and its ancestors to
             * respond to an arrow key. This is called when the focused view did not
             * consume the key internally, nor could the view system find a new view in
             * the requested direction to give focus to.
             *
             * @param focused The currently focused view.
             * @param direction The direction focus wants to move. One of FOCUS_UP,
             *        FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT.
             * @return True if the this view consumed this unhandled move.
             */
            DispatchUnhandledMove(
                [in] IView* focused,
                [in] Int32 direction,
                [out] Boolean* result);

            /**
             * Find and return all focusable views that are descendants of this view,
             * possibly including this view if it is focusable itself.
             *
             * @param direction The direction of the focus
             * @return A list of focusable views
             */
            GetFocusables(
                [in] Int32 direction,
                [out] IArrayList** views);

            /**
             * Add any focusable views that are descendants of this view (possibly
             * including this view if it is focusable itself) to views.  If we are in touch mode,
             * only add views that are also focusable in touch mode.
             *
             * @param views Focusable views found so far
             * @param direction The direction of the focus
             */
            AddFocusables(
                [in] IArrayList* views,
                [in] Int32 direction);

            /**
             * Adds any focusable views that are descendants of this view (possibly
             * including this view if it is focusable itself) to views. This method
             * adds all focusable views regardless if we are in touch mode or
             * only views focusable in touch mode if we are in touch mode or
             * only views that can take accessibility focus if accessibility is enabeld
             * depending on the focusable mode paramater.
             *
             * @param views Focusable views found so far or null if all we are interested is
             *        the number of focusables.
             * @param direction The direction of the focus.
             * @param focusableMode The type of focusables to be added.
             *
             * @see #FOCUSABLES_ALL
             * @see #FOCUSABLES_TOUCH_MODE
             */
            AddFocusables(
                [in] IArrayList* views,
                [in] Int32 direction,
                [in] Int32 focusableMode);

            /**
             * Finds the Views that contain given text. The containment is case insensitive.
             * The search is performed by either the text that the View renders or the content
             * description that describes the view for accessibility purposes and the view does
             * not render or both. Clients can specify how the search is to be performed via
             * passing the {@link #FIND_VIEWS_WITH_TEXT} and
             * {@link #FIND_VIEWS_WITH_CONTENT_DESCRIPTION} flags.
             *
             * @param outViews The output list of matching Views.
             * @param searched The text to match against.
             *
             * @see #FIND_VIEWS_WITH_TEXT
             * @see #FIND_VIEWS_WITH_CONTENT_DESCRIPTION
             * @see #setContentDescription(CharSequence)
             */
            FindViewsWithText(
                [in] IArrayList* outViews,
                [in] ICharSequence* searched,
                [in] Int32 flags);

            /**
             * Find and return all touchable views that are descendants of this view,
             * possibly including this view if it is touchable itself.
             *
             * @return A list of touchable views
             */
            GetTouchables(
                [out] IArrayList** views);

            /**
             * Add any touchable views that are descendants of this view (possibly
             * including this view if it is touchable itself) to views.
             *
             * @param views Touchable views found so far
             */
            AddTouchables(
                [in] IArrayList* views);

            /**
             * Returns whether this View is accessibility focused.
             *
             * @return True if this View is accessibility focused.
             */
            IsAccessibilityFocused(
                [out] Boolean* result);

            /**
             * Call this to try to give accessibility focus to this view.
             *
             * A view will not actually take focus if {@link AccessibilityManager#isEnabled()}
             * returns false or the view is no visible or the view already has accessibility
             * focus.
             *
             * See also {@link #focusSearch(int)}, which is what you call to say that you
             * have focus, and you want your parent to look for the next one.
             *
             * @return Whether this view actually took accessibility focus.
             *
             * @hide
             */
            RequestAccessibilityFocus(
                [out] Boolean* focus);

            /**
             * Call this to try to clear accessibility focus of this view.
             *
             * See also {@link #focusSearch(int)}, which is what you call to say that you
             * have focus, and you want your parent to look for the next one.
             *
             * @hide
             */
            ClearAccessibilityFocus();

            /**
             * Call this to try to give focus to a specific view or to one of its
             * descendants.
             *
             * A view will not actually take focus if it is not focusable ({@link #isFocusable} returns
             * false), or if it is focusable and it is not focusable in touch mode
             * ({@link #isFocusableInTouchMode}) while the device is in touch mode.
             *
             * See also {@link #focusSearch(int)}, which is what you call to say that you
             * have focus, and you want your parent to look for the next one.
             *
             * This is equivalent to calling {@link #requestFocus(int, Rect)} with arguments
             * {@link #FOCUS_DOWN} and <code>null</code>.
             *
             * @return Whether this view or one of its descendants actually took focus.
             */
            RequestFocus(
                [out] Boolean* result);

            /**
             * Call this to try to give focus to a specific view or to one of its
             * descendants and give it a hint about what direction focus is heading.
             *
             * A view will not actually take focus if it is not focusable ({@link #isFocusable} returns
             * false), or if it is focusable and it is not focusable in touch mode
             * ({@link #isFocusableInTouchMode}) while the device is in touch mode.
             *
             * See also {@link #focusSearch(int)}, which is what you call to say that you
             * have focus, and you want your parent to look for the next one.
             *
             * This is equivalent to calling {@link #requestFocus(int, Rect)} with
             * <code>null</code> set for the previously focused rectangle.
             *
             * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
             * @return Whether this view or one of its descendants actually took focus.
             */
            RequestFocus(
                [in] Int32 direction,
                [out] Boolean* result);

            /**
             * Call this to try to give focus to a specific view or to one of its descendants
             * and give it hints about the direction and a specific rectangle that the focus
             * is coming from.  The rectangle can help give larger views a finer grained hint
             * about where focus is coming from, and therefore, where to show selection, or
             * forward focus change internally.
             *
             * A view will not actually take focus if it is not focusable ({@link #isFocusable} returns
             * false), or if it is focusable and it is not focusable in touch mode
             * ({@link #isFocusableInTouchMode}) while the device is in touch mode.
             *
             * A View will not take focus if it is not visible.
             *
             * A View will not take focus if one of its parents has
             * {@link android.view.ViewGroup#getDescendantFocusability()} equal to
             * {@link ViewGroup#FOCUS_BLOCK_DESCENDANTS}.
             *
             * See also {@link #focusSearch(int)}, which is what you call to say that you
             * have focus, and you want your parent to look for the next one.
             *
             * You may wish to override this method if your custom {@link View} has an internal
             * {@link View} that it wishes to forward the request to.
             *
             * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
             * @param previouslyFocusedRect The rectangle (in this View's coordinate system)
             *        to give a finer grained hint about where focus is coming from.  May be null
             *        if there is no hint.
             * @return Whether this view or one of its descendants actually took focus.
             */
            RequestFocus(
                [in] Int32 direction,
                [in] IRect* previouslyFocusedRect,
                [out] Boolean* result);

            /**
             * Call this to try to give focus to a specific view or to one of its descendants. This is a
             * special variant of {@link #requestFocus() } that will allow views that are not focuable in
             * touch mode to request focus when they are touched.
             *
             * @return Whether this view or one of its descendants actually took focus.
             *
             * @see #isInTouchMode()
             *
             */
            RequestFocusFromTouch(
                [out] Boolean* result);

            /**
             * Gets the mode for determining whether this View is important for accessibility
             * which is if it fires accessibility events and if it is reported to
             * accessibility services that query the screen.
             *
             * @return The mode for determining whether a View is important for accessibility.
             *
             * @attr ref android.R.styleable#View_importantForAccessibility
             *
             * @see #IMPORTANT_FOR_ACCESSIBILITY_YES
             * @see #IMPORTANT_FOR_ACCESSIBILITY_NO
             * @see #IMPORTANT_FOR_ACCESSIBILITY_AUTO
             */
            // @ViewDebug.ExportedProperty(category = "accessibility", mapping = {
            //         @ViewDebug.IntToString(from = IMPORTANT_FOR_ACCESSIBILITY_AUTO, to = "auto"),
            //         @ViewDebug.IntToString(from = IMPORTANT_FOR_ACCESSIBILITY_YES, to = "yes"),
            //         @ViewDebug.IntToString(from = IMPORTANT_FOR_ACCESSIBILITY_NO, to = "no")
            //     })
            GetImportantForAccessibility(
                [out] Int32* mode);

            /**
             * Sets the live region mode for this view. This indicates to accessibility
             * services whether they should automatically notify the user about changes
             * to the view's content description or text, or to the content descriptions
             * or text of the view's children (where applicable).
             * <p>
             * For example, in a login screen with a TextView that displays an "incorrect
             * password" notification, that view should be marked as a live region with
             * mode {@link #ACCESSIBILITY_LIVE_REGION_POLITE}.
             * <p>
             * To disable change notifications for this view, use
             * {@link #ACCESSIBILITY_LIVE_REGION_NONE}. This is the default live region
             * mode for most views.
             * <p>
             * To indicate that the user should be notified of changes, use
             * {@link #ACCESSIBILITY_LIVE_REGION_POLITE}.
             * <p>
             * If the view's changes should interrupt ongoing speech and notify the user
             * immediately, use {@link #ACCESSIBILITY_LIVE_REGION_ASSERTIVE}.
             *
             * @param mode The live region mode for this view, one of:
             *        <ul>
             *        <li>{@link #ACCESSIBILITY_LIVE_REGION_NONE}
             *        <li>{@link #ACCESSIBILITY_LIVE_REGION_POLITE}
             *        <li>{@link #ACCESSIBILITY_LIVE_REGION_ASSERTIVE}
             *        </ul>
             * @attr ref android.R.styleable#View_accessibilityLiveRegion
             */
            SetAccessibilityLiveRegion(
                [in] Int32 mode);

            /**
             * Gets the live region mode for this View.
             *
             * @return The live region mode for the view.
             *
             * @attr ref android.R.styleable#View_accessibilityLiveRegion
             *
             * @see #setAccessibilityLiveRegion(int)
             */
            GetAccessibilityLiveRegion(
                [out] Int32* result);

            /**
             * Sets how to determine whether this view is important for accessibility
             * which is if it fires accessibility events and if it is reported to
             * accessibility services that query the screen.
             *
             * @param mode How to determine whether this view is important for accessibility.
             *
             * @attr ref android.R.styleable#View_importantForAccessibility
             *
             * @see #IMPORTANT_FOR_ACCESSIBILITY_YES
             * @see #IMPORTANT_FOR_ACCESSIBILITY_NO
             * @see #IMPORTANT_FOR_ACCESSIBILITY_AUTO
             */
            SetImportantForAccessibility(
                [in] Int32 mode);

            /**
             * Gets whether this view should be exposed for accessibility.
             *
             * @return Whether the view is exposed for accessibility.
             *
             * @hide
             */
            IsImportantForAccessibility(
                [out] Boolean* exposed);

            /**
             * Gets the parent for accessibility purposes. Note that the parent for
             * accessibility is not necessary the immediate parent. It is the first
             * predecessor that is important for accessibility.
             *
             * @return The parent for accessibility purposes.
             */
            GetParentForAccessibility(
                [out] IViewParent** parent);

            /**
             * Adds the children of a given View for accessibility. Since some Views are
             * not important for accessibility the children for accessibility are not
             * necessarily direct children of the riew, rather they are the first level of
             * descendants important for accessibility.
             *
             * @param children The list of children for accessibility.
             */
            AddChildrenForAccessibility(
                [in] IArrayList* children);

            /**
             * Whether to regard this view for accessibility. A view is regarded for
             * accessibility if it is important for accessibility or the querying
             * accessibility service has explicitly requested that view not
             * important for accessibility are regarded.
             *
             * @return Whether to regard the view for accessibility.
             *
             * @hide
             */
            IncludeForAccessibility(
                [out] Boolean* include);

            /**
             * Returns whether the View is considered actionable from
             * accessibility perspective. Such view are important for
             * accessibility.
             *
             * @return True if the view is actionable for accessibility.
             *
             * @hide
             */
            IsActionableForAccessibility(
                [out] Boolean* actionable);

            /**
             * Notifies that the accessibility state of this view changed. The change
             * is local to this view and does not represent structural changes such
             * as children and parent. For example, the view became focusable. The
             * notification is at at most once every
             * {@link ViewConfiguration#getSendRecurringAccessibilityEventsInterval()}
             * to avoid unnecessary load to the system. Also once a view has a pending
             * notification this method is a NOP until the notification has been sent.
             *
             * @hide
             */
            NotifyViewAccessibilityStateChangedIfNeeded(
                [in] Int32 changeType);

            /**
             * Notifies that the accessibility state of this view changed. The change
             * is *not* local to this view and does represent structural changes such
             * as children and parent. For example, the view size changed. The
             * notification is at at most once every
             * {@link ViewConfiguration#getSendRecurringAccessibilityEventsInterval()}
             * to avoid unnecessary load to the system. Also once a view has a pending
             * notification this method is a NOP until the notification has been sent.
             *
             * @hide
             */
            NotifySubtreeAccessibilityStateChangedIfNeeded();

            /**
             * Performs the specified accessibility action on the view. For
             * possible accessibility actions look at {@link AccessibilityNodeInfo}.
             * <p>
             * If an {@link AccessibilityDelegate} has been specified via calling
             * {@link #setAccessibilityDelegate(AccessibilityDelegate)} its
             * {@link AccessibilityDelegate#performAccessibilityAction(View, int, Bundle)}
             * is responsible for handling this call.
             * </p>
             *
             * @param action The action to perform.
             * @param arguments Optional action arguments.
             * @return Whether the action was performed.
             */
            PerformAccessibilityAction(
                [in] Int32 action,
                [in] IBundle* arguments,
                [out] Boolean* performed);

            /**
             * Gets the text reported for accessibility purposes.
             *
             * @return The accessibility text.
             *
             * @hide
             */
            GetIterableTextForAccessibility(
                [out] ICharSequence** text);

            /**
             * Gets whether accessibility selection can be extended.
             *
             * @return If selection is extensible.
             *
             * @hide
             */
            IsAccessibilitySelectionExtendable(
                [out] Boolean* result);

            /**
             * @hide
             */
            GetAccessibilitySelectionStart(
                [out] Int32* result);

            /**
             * @hide
             */
            GetAccessibilitySelectionEnd(
                [out] Int32* result);

            SetAccessibilitySelection(
                [in] Int32 start,
                [in] Int32 end);

            /**
             * @hide
             */
            GetIteratorForGranularity(
                [in] Int32 granularity,
                [out] ITextSegmentIterator** iterator);

            DispatchStartTemporaryDetach();

            /**
             * This is called when a container is going to temporarily detach a child, with
             * {@link ViewGroup#detachViewFromParent(View) ViewGroup.detachViewFromParent}.
             * It will either be followed by {@link #onFinishTemporaryDetach()} or
             * {@link #onDetachedFromWindow()} when the container is done.
             */
            OnStartTemporaryDetach();

            DispatchFinishTemporaryDetach();

            /**
             * Called after {@link #onStartTemporaryDetach} when the container is done
             * changing the view.
             */
            OnFinishTemporaryDetach();

            /**
             * Return the global {@link KeyEvent.DispatcherState KeyEvent.DispatcherState}
             * for this view's window.  Returns null if the view is not currently attached
             * to the window.  Normally you will not need to use this directly, but
             * just use the standard high-level event callbacks like {@link #onKeyDown}.
             */
            GetKeyDispatcherState(
                [out] IDispatcherState** state);

            /**
             * Dispatch a key event before it is processed by any input method
             * associated with the view hierarchy.  This can be used to intercept
             * key events in special situations before the IME consumes them; a
             * typical example would be handling the BACK key to update the application's
             * UI instead of allowing the IME to see it and close itself.
             *
             * @param event The key event to be dispatched.
             * @return True if the event was handled, false otherwise.
             */
            DispatchKeyEventPreIme(
                [in] IKeyEvent* event,
                [out] Boolean* result);

            /**
             * Dispatch a key event to the next view on the focus path. This path runs
             * from the top of the view tree down to the currently focused view. If this
             * view has focus, it will dispatch to itself. Otherwise it will dispatch
             * the next node down the focus path. This method also fires any key
             * listeners.
             *
             * @param event The key event to be dispatched.
             * @return True if the event was handled, false otherwise.
             */
            DispatchKeyEvent(
                [in] IKeyEvent* event,
                [out] Boolean* result);

            /**
             * Dispatches a key shortcut event.
             *
             * @param event The key event to be dispatched.
             * @return True if the event was handled by the view, false otherwise.
             */
            DispatchKeyShortcutEvent(
                [in] IKeyEvent* event,
                [out] Boolean* result);

            /**
             * Pass the touch screen motion event down to the target view, or this
             * view if it is the target.
             *
             * @param event The motion event to be dispatched.
             * @return True if the event was handled by the view, false otherwise.
             */
            DispatchTouchEvent(
                [in] IMotionEvent* event,
                [out] Boolean* result);

            /**
             * Filter the touch event to apply security policies.
             *
             * @param event The motion event to be filtered.
             * @return True if the event should be dispatched, false if the event should be dropped.
             *
             * @see #getFilterTouchesWhenObscured
             */
            OnFilterTouchEventForSecurity(
                [in] IMotionEvent* event,
                [out] Boolean* result);

            /**
             * Pass a trackball motion event down to the focused view.
             *
             * @param event The motion event to be dispatched.
             * @return True if the event was handled by the view, false otherwise.
             */
            DispatchTrackballEvent(
                [in] IMotionEvent* event,
                [out] Boolean* result);

            /**
             * Dispatch a generic motion event.
             * <p>
             * Generic motion events with source class {@link InputDevice#SOURCE_CLASS_POINTER}
             * are delivered to the view under the pointer.  All other generic motion events are
             * delivered to the focused view.  Hover events are handled specially and are delivered
             * to {@link #onHoverEvent(MotionEvent)}.
             * </p>
             *
             * @param event The motion event to be dispatched.
             * @return True if the event was handled by the view, false otherwise.
             */
            DispatchGenericMotionEvent(
                [in] IMotionEvent* event,
                [out] Boolean* handled);

            /**

             * Dispatch a pointer event.
             * <p>
             * Dispatches touch related pointer events to {@link #onTouchEvent(MotionEvent)} and all
             * other events to {@link #onGenericMotionEvent(MotionEvent)}.  This separation of concerns
             * reinforces the invariant that {@link #onTouchEvent(MotionEvent)} is really about touches
             * and should not be expected to handle other pointing device features.
             * </p>
             *
             * @param event The motion event to be dispatched.
             * @return True if the event was handled by the view, false otherwise.
             * @hide
             */
            DispatchPointerEvent(
                [in] IMotionEvent* event,
                [out] Boolean* handled);

            /**
             * Called when the window containing this view gains or loses window focus.
             * ViewGroups should override to route to their children.
             *
             * @param hasFocus True if the window containing this view now has focus,
             *        false otherwise.
             */
            DispatchWindowFocusChanged(
                [in] Boolean hasFocus);

            /**
             * Called when the window containing this view gains or loses focus.  Note
             * that this is separate from view focus: to receive key events, both
             * your view and its window must have focus.  If a window is displayed
             * on top of yours that takes input focus, then your own window will lose
             * focus but the view focus will remain unchanged.
             *
             * @param hasWindowFocus True if the window containing this view now has
             *        focus, false otherwise.
             */
            OnWindowFocusChanged(
                [in] Boolean hasWindowFocus);

            /**
             * Returns true if this view is in a window that currently has window focus.
             * Note that this is not the same as the view itself having focus.
             *
             * @return True if this view is in a window that currently has window focus.
             */
            HasWindowFocus(
                [out] Boolean* focus);

            /**
             * Dispatch a hint about whether this view is displayed. For instance, when
             * a View moves out of the screen, it might receives a display hint indicating
             * the view is not displayed. Applications should not <em>rely</em> on this hint
             * as there is no guarantee that they will receive one.
             *
             * @param hint A hint about whether or not this view is displayed:
             * {@link #VISIBLE} or {@link #INVISIBLE}.
             */
            DispatchDisplayHint(
                [in] Int32 hint);

            /**
             * Dispatch a window visibility change down the view hierarchy.
             * ViewGroups should override to route to their children.
             *
             * @param visibility The new visibility of the window.
             *
             * @see #onWindowVisibilityChanged
             */
            DispatchWindowVisibilityChanged(
                [in] Int32 visibility);

            /**
             * Returns the current visibility of the window this view is attached to
             * (either {@link #GONE}, {@link #INVISIBLE}, or {@link #VISIBLE}).
             *
             * @return Returns the current visibility of the view's window.
             */
            GetWindowVisibility(
                [out] Int32* visibility);

            /**
             * Retrieve the overall visible display size in which the window this view is
             * attached to has been positioned in.  This takes into account screen
             * decorations above the window, for both cases where the window itself
             * is being position inside of them or the window is being placed under
             * then and covered insets are used for the window to position its content
             * inside.  In effect, this tells you the available area where content can
             * be placed and remain visible to users.
             *
             * <p>This function requires an IPC back to the window manager to retrieve
             * the requested information, so should not be used in performance critical
             * code like drawing.
             *
             * @param outRect Filled in with the visible display frame.  If the view
             * is not attached to a window, this is simply the raw display size.
             */
            GetWindowVisibleDisplayFrame(
                [in/*, out*/] IRect* outRect);

            /**
             * Dispatch a notification about a resource configuration change down
             * the view hierarchy.
             * ViewGroups should override to route to their children.
             *
             * @param newConfig The new resource configuration.
             *
             * @see #onConfigurationChanged(android.content.res.Configuration)
             */
            DispatchConfigurationChanged(
                [in] IConfiguration* newConfig);

            /**
             * Returns whether the device is currently in touch mode.  Touch mode is entered
             * once the user begins interacting with the device by touch, and affects various
             * things like whether focus is always visible to the user.
             *
             * @return Whether the device is in touch mode.
             */
            IsInTouchMode(
                [out] Boolean* result);

            /**
             * Returns the context the view is running in, through which it can
             * access the current theme, resources, etc.
             *
             * @return The view's Context.
             */
            GetContext(
                [out] IContext** ctx);

            /**
             * Handle a key event before it is processed by any input method
             * associated with the view hierarchy.  This can be used to intercept
             * key events in special situations before the IME consumes them; a
             * typical example would be handling the BACK key to update the application's
             * UI instead of allowing the IME to see it and close itself.
             *
             * @param keyCode The value in event.getKeyCode().
             * @param event Description of the key event.
             * @return If you handled the event, return true. If you want to allow the
             *         event to be handled by the next receiver, return false.
             */
            OnKeyPreIme(
                [in] Int32 keyCode,
                [in] IKeyEvent* event,
                [out] Boolean* result);

            /**
             * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
             * KeyEvent.Callback.onKeyDown()}: perform press of the view
             * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
             * is released, if the view is enabled and clickable.
             *
             * <p>Key presses in software keyboards will generally NOT trigger this listener,
             * although some may elect to do so in some situations. Do not rely on this to
             * catch software key presses.
             *
             * @param keyCode A key code that represents the button pressed, from
             *                {@link android.view.KeyEvent}.
             * @param event   The KeyEvent object that defines the button action.
             */
            OnKeyDown(
                [in] Int32 keyCode,
                [in] IKeyEvent* event,
                [out] Boolean* result);

            /**
             * Default implementation of {@link KeyEvent.Callback#onKeyLongPress(int, KeyEvent)
             * KeyEvent.Callback.onKeyLongPress()}: always returns false (doesn't handle
             * the event).
             * <p>Key presses in software keyboards will generally NOT trigger this listener,
             * although some may elect to do so in some situations. Do not rely on this to
             * catch software key presses.
             */
            OnKeyLongPress(
                [in] Int32 keyCode,
                [in] IKeyEvent* event,
                [out] Boolean* result);

            /**
             * Default implementation of {@link KeyEvent.Callback#onKeyUp(int, KeyEvent)
             * KeyEvent.Callback.onKeyUp()}: perform clicking of the view
             * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or
             * {@link KeyEvent#KEYCODE_ENTER} is released.
             * <p>Key presses in software keyboards will generally NOT trigger this listener,
             * although some may elect to do so in some situations. Do not rely on this to
             * catch software key presses.
             *
             * @param keyCode A key code that represents the button pressed, from
             *                {@link android.view.KeyEvent}.
             * @param event   The KeyEvent object that defines the button action.
             */
            OnKeyUp(
                [in] Int32 keyCode,
                [in] IKeyEvent* event,
                [out] Boolean* result);

            /**
             * Default implementation of {@link KeyEvent.Callback#onKeyMultiple(int, int, KeyEvent)
             * KeyEvent.Callback.onKeyMultiple()}: always returns false (doesn't handle
             * the event).
             * <p>Key presses in software keyboards will generally NOT trigger this listener,
             * although some may elect to do so in some situations. Do not rely on this to
             * catch software key presses.
             *
             * @param keyCode     A key code that represents the button pressed, from
             *                    {@link android.view.KeyEvent}.
             * @param repeatCount The number of times the action was made.
             * @param event       The KeyEvent object that defines the button action.
             */
            OnKeyMultiple(
                [in] Int32 keyCode,
                [in] Int32 repeatCount,
                [in] IKeyEvent* event,
                [out] Boolean* result);

            /**
             * Called when an unhandled key shortcut event occurs.
             *
             * @param keyCode The value in event.getKeyCode().
             * @param event Description of the key event.
             * @return If you handled the event, return true. If you want to allow the
             *         event to be handled by the next receiver, return false.
             */
            OnKeyShortcut(
                [in] Int32 keyCode,
                [in] IKeyEvent* event,
                [out] Boolean* result);

            /**
             * Check whether the called view is a text editor, in which case it
             * would make sense to automatically display a soft input window for
             * it.  Subclasses should override this if they implement
             * {@link #onCreateInputConnection(EditorInfo)} to return true if
             * a call on that method would return a non-NULL InputConnection, and
             * they are really a first-class editor that the user would normally
             * start typing on when the go into a window containing your view.
             *
             * <p>The default implementation always returns false.  This does
             * <em>not</em> mean that its {@link #onCreateInputConnection(EditorInfo)}
             * will not be called or the user can not otherwise perform edits on your
             * view; it is just a hint to the system that this is not the primary
             * purpose of this view.
             *
             * @return Returns true if this view is a text editor, else false.
             */
            OnCheckIsTextEditor(
                [out] Boolean* result);

            /**
             * Create a new InputConnection for an InputMethod to interact
             * with the view.  The default implementation returns null, since it doesn't
             * support input methods.  You can override this to implement such support.
             * This is only needed for views that take focus and text input.
             *
             * <p>When implementing this, you probably also want to implement
             * {@link #onCheckIsTextEditor()} to indicate you will return a
             * non-null InputConnection.
             *
             * @param outAttrs Fill in with attribute information about the connection.
             */
            OnCreateInputConnection(
                [in] IEditorInfo* outAttrs,
                [out] IInputConnection** inputConnection);

            /**
             * Called by the {@link android.view.inputmethod.InputMethodManager}
             * when a view who is not the current
             * input connection target is trying to make a call on the manager.  The
             * default implementation returns false; you can override this to return
             * true for certain views if you are performing InputConnection proxying
             * to them.
             * @param view The View that is making the InputMethodManager call.
             * @return Return true to allow the call, false to reject.
             */
            CheckInputConnectionProxy(
                [in] IView* view,
                [out] Boolean* result);

            /**
             * Show the context menu for this view. It is not safe to hold on to the
             * menu after returning from this method.
             *
             * You should normally not overload this method. Overload
             * {@link #onCreateContextMenu(ContextMenu)} or define an
             * {@link OnCreateContextMenuListener} to add items to the context menu.
             *
             * @param menu The context menu to populate
             */
            CreateContextMenu(
                [in] IContextMenu* menu);

            /**
             * Implement this method to handle trackball motion events.  The
             * <em>relative</em> movement of the trackball since the last event
             * can be retrieve with {@link MotionEvent#getX MotionEvent.getX()} and
             * {@link MotionEvent#getY MotionEvent.getY()}.  These are normalized so
             * that a movement of 1 corresponds to the user pressing one DPAD key (so
             * they will often be fractional values, representing the more fine-grained
             * movement information available from a trackball).
             *
             * @param event The motion event.
             * @return True if the event was handled, false otherwise.
             */
            OnTrackballEvent(
                [in] IMotionEvent* event,
                [out] Boolean* result);

            /**
             * Implement this method to handle generic motion events.
             * <p>
             * Generic motion events describe joystick movements, mouse hovers, track pad
             * touches, scroll wheel movements and other input events.  The
             * {@link MotionEvent#getSource() source} of the motion event specifies
             * the class of input that was received.  Implementations of this method
             * must examine the bits in the source before processing the event.
             * The following code example shows how this is done.
             * </p><p>
             * Generic motion events with source class {@link InputDevice#SOURCE_CLASS_POINTER}
             * are delivered to the view under the pointer.  All other generic motion events are
             * delivered to the focused view.
             * </p>
             * <pre> public boolean onGenericMotionEvent(MotionEvent event) {
             *     if ((event.getSource() &amp; InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
             *         if (event.getAction() == MotionEvent.ACTION_MOVE) {
             *             // process the joystick movement...
             *             return true;
             *         }
             *     }
             *     if ((event.getSource() &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) {
             *         switch (event.getAction()) {
             *             case MotionEvent.ACTION_HOVER_MOVE:
             *                 // process the mouse hover movement...
             *                 return true;
             *             case MotionEvent.ACTION_SCROLL:
             *                 // process the scroll wheel movement...
             *                 return true;
             *         }
             *     }
             *     return super.onGenericMotionEvent(event);
             * }</pre>
             *
             * @param event The generic motion event being processed.
             * @return True if the event was handled, false otherwise.
             */
            OnGenericMotionEvent(
                [in] IMotionEvent* event,
                [out] Boolean* handled);

            /**
             * Implement this method to handle hover events.
             * <p>
             * This method is called whenever a pointer is hovering into, over, or out of the
             * bounds of a view and the view is not currently being touched.
             * Hover events are represented as pointer events with action
             * {@link MotionEvent#ACTION_HOVER_ENTER}, {@link MotionEvent#ACTION_HOVER_MOVE},
             * or {@link MotionEvent#ACTION_HOVER_EXIT}.
             * </p>
             * <ul>
             * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_ENTER}
             * when the pointer enters the bounds of the view.</li>
             * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_MOVE}
             * when the pointer has already entered the bounds of the view and has moved.</li>
             * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_EXIT}
             * when the pointer has exited the bounds of the view or when the pointer is
             * about to go down due to a button click, tap, or similar user action that
             * causes the view to be touched.</li>
             * </ul>
             * <p>
             * The view should implement this method to return true to indicate that it is
             * handling the hover event, such as by changing its drawable state.
             * </p><p>
             * The default implementation calls {@link #setHovered} to update the hovered state
             * of the view when a hover enter or hover exit event is received, if the view
             * is enabled and is clickable.  The default implementation also sends hover
             * accessibility events.
             * </p>
             *
             * @param event The motion event that describes the hover.
             * @return True if the view handled the hover event.
             *
             * @see #isHovered
             * @see #setHovered
             * @see #onHoverChanged
             */
            OnHoverEvent(
                [in] IMotionEvent* event,
                [out] Boolean* handled);

            /**
             * Returns true if the view is currently hovered.
             *
             * @return True if the view is currently hovered.
             *
             * @see #setHovered
             * @see #onHoverChanged
             */
            //@ViewDebug.ExportedProperty
            IsHovered(
                [out] Boolean* hovered);

            /**
             * Sets whether the view is currently hovered.
             * <p>
             * Calling this method also changes the drawable state of the view.  This
             * enables the view to react to hover by using different drawable resources
             * to change its appearance.
             * </p><p>
             * The {@link #onHoverChanged} method is called when the hovered state changes.
             * </p>
             *
             * @param hovered True if the view is hovered.
             *
             * @see #isHovered
             * @see #onHoverChanged
             */
            SetHovered(
                [in] Boolean hovered);

            /**
             * Implement this method to handle hover state changes.
             * <p>
             * This method is called whenever the hover state changes as a result of a
             * call to {@link #setHovered}.
             * </p>
             *
             * @param hovered The current hover state, as returned by {@link #isHovered}.
             *
             * @see #isHovered
             * @see #setHovered
             */
            OnHoverChanged(
                [in] Boolean hovered);

            /**
             * Implement this method to handle touch screen motion events.
             *
             * @param event The motion event.
             * @return True if the event was handled, false otherwise.
             */
            OnTouchEvent(
                [in] IMotionEvent* event,
                [out] Boolean* result);

            /**
             * @hide
             */
            IsInScrollingContainer(
                [out] Boolean* result);

            /**
             * Cancels a pending long press.  Your subclass can use this if you
             * want the context menu to come up if the user presses and holds
             * at the same place, but you don't want it to come up if they press
             * and then move around enough to cause scrolling.
             */
            CancelLongPress();

            /**
             * Sets the TouchDelegate for this View.
             */
            SetTouchDelegate(
                [in] ITouchDelegate* touchDelegate);

            /**
             * Gets the TouchDelegate for this View.
             */
            GetTouchDelegate(
                [out] ITouchDelegate** touchDelegate);

            /**
             * Request unbuffered dispatch of the given stream of MotionEvents to this View.
             *
             * Until this View receives a corresponding {@link MotionEvent#ACTION_UP}, ask that the input
             * system not batch {@link MotionEvent}s but instead deliver them as soon as they're
             * available. This method should only be called for touch events.
             *
             * <p class="note">This api is not intended for most applications. Buffered dispatch
             * provides many of benefits, and just requesting unbuffered dispatch on most MotionEvent
             * streams will not improve your input latency. Side effects include: increased latency,
             * jittery scrolls and inability to take advantage of system resampling. Talk to your input
             * professional to see if {@link #requestUnbufferedDispatch(MotionEvent)} is right for
             * you.</p>
             */
            RequestUnbufferedDispatch(
                [in] IMotionEvent* event);

            /**
             * Change the view's z order in the tree, so it's on top of other sibling
             * views
             */
            BringToFront();

            /**
             * Gets the parent of this view. Note that the parent is a
             * ViewParent and not necessarily a View.
             *
             * @return Parent of this view.
             */
            GetParent(
                [out] IViewParent** parent);

            /**
             * Set the horizontal scrolled position of your view. This will cause a call to
             * {@link #onScrollChanged(int, int, int, int)} and the view will be
             * invalidated.
             * @param value the x position to scroll to
             */
            SetScrollX(
                [in] Int32 value);

            /**
             * Set the vertical scrolled position of your view. This will cause a call to
             * {@link #onScrollChanged(int, int, int, int)} and the view will be
             * invalidated.
             * @param value the y position to scroll to
             */
            SetScrollY(
                [in] Int32 value);

            /**
             * Return the scrolled left position of this view. This is the left edge of
             * the displayed part of your view. You do not need to draw any pixels
             * farther left, since those are outside of the frame of your view on
             * screen.
             *
             * @return The left edge of the displayed part of your view, in pixels.
             */
            GetScrollX(
                [out] Int32* x);

            /**
             * Return the scrolled top position of this view. This is the top edge of
             * the displayed part of your view. You do not need to draw any pixels above
             * it, since those are outside of the frame of your view on screen.
             *
             * @return The top edge of the displayed part of your view, in pixels.
             */
            GetScrollY(
                [out] Int32* y);

            /**
             * Return the width of the your view.
             *
             * @return The width of your view, in pixels.
             */
            GetWidth(
                [out] Int32* width);

            /**
             * Return the height of your view.
             *
             * @return The height of your view, in pixels.
             */
            GetHeight(
                [out] Int32* height);

            /**
             * Return the visible drawing bounds of your view. Fills in the output
             * rectangle with the values from getScrollX(), getScrollY(),
             * getWidth(), and getHeight(). These bounds do not account for any
             * transformation properties currently set on the view, such as
             * {@link #setScaleX(float)} or {@link #setRotation(float)}.
             *
             * @param outRect The (scrolled) drawing bounds of the view.
             */
            GetDrawingRect(
                [in] IRect* outRect);

            /**
             * Like {@link #getMeasuredWidthAndState()}, but only returns the
             * raw width component (that is the result is masked by
             * {@link #MEASURED_SIZE_MASK}).
             *
             * @return The raw measured width of this view.
             */
            GetMeasuredWidth(
                [out] Int32* width);

            /**
             * Return the full width measurement information for this view as computed
             * by the most recent call to {@link #measure(int, int)}.  This result is a bit mask
             * as defined by {@link #MEASURED_SIZE_MASK} and {@link #MEASURED_STATE_TOO_SMALL}.
             * This should be used during measurement and layout calculations only. Use
             * {@link #getWidth()} to see how wide a view is after layout.
             *
             * @return The measured width of this view as a bit mask.
             */
            GetMeasuredWidthAndState(
                [out] Int32* width);

            /**
             * Like {@link #getMeasuredHeightAndState()}, but only returns the
             * raw width component (that is the result is masked by
             * {@link #MEASURED_SIZE_MASK}).
             *
             * @return The raw measured height of this view.
             */
            GetMeasuredHeight(
                [out] Int32* height);

            /**
             * Return the full height measurement information for this view as computed
             * by the most recent call to {@link #measure(int, int)}.  This result is a bit mask
             * as defined by {@link #MEASURED_SIZE_MASK} and {@link #MEASURED_STATE_TOO_SMALL}.
             * This should be used during measurement and layout calculations only. Use
             * {@link #getHeight()} to see how wide a view is after layout.
             *
             * @return The measured width of this view as a bit mask.
             */
            GetMeasuredHeightAndState(
                [out] Int32* height);

            /**
             * Return only the state bits of {@link #getMeasuredWidthAndState()}
             * and {@link #getMeasuredHeightAndState()}, combined into one integer.
             * The width component is in the regular bits {@link #MEASURED_STATE_MASK}
             * and the height component is at the shifted bits
             * {@link #MEASURED_HEIGHT_STATE_SHIFT}>>{@link #MEASURED_STATE_MASK}.
             */
            GetMeasuredState(
                [out] Int32* state);

            /**
             * The transform matrix of this view, which is calculated based on the current
             * roation, scale, and pivot properties.
             *
             * @see #getRotation()
             * @see #getScaleX()
             * @see #getScaleY()
             * @see #getPivotX()
             * @see #getPivotY()
             * @return The current transform matrix for the view
             */
            GetMatrix(
                [out] IMatrix** matrix);

           /**
             * Utility method to retrieve the inverse of the current mMatrix property.
             * We cache the matrix to avoid recalculating it when transform properties
             * have not changed.
             *
             * @return The inverse of the current matrix of this view.
             * @hide
             */
            GetInverseMatrix(
                [out] IMatrix** matrix);

            /**
             * Gets the distance along the Z axis from the camera to this view.
             *
             * @see #setCameraDistance(Float)
             *
             * @return The distance along the Z axis.
             */
            GetCameraDistance(
                [out] Float* distance);

            /**
             * <p>Sets the distance along the Z axis (orthogonal to the X/Y plane on which
             * views are drawn) from the camera to this view. The camera's distance
             * affects 3D transformations, for instance rotations around the X and Y
             * axis. If the rotationX or rotationY properties are changed and this view is
             * large (more than half the size of the screen), it is recommended to always
             * use a camera distance that's greater than the height (X axis rotation) or
             * the width (Y axis rotation) of this view.</p>
             *
             * <p>The distance of the camera from the view plane can have an affect on the
             * perspective distortion of the view when it is rotated around the x or y axis.
             * For example, a large distance will result in a large viewing angle, and there
             * will not be much perspective distortion of the view as it rotates. A short
             * distance may cause much more perspective distortion upon rotation, and can
             * also result in some drawing artifacts if the rotated view ends up partially
             * behind the camera (which is why the recommendation is to use a distance at
             * least as far as the size of the view, if the view is to be rotated.)</p>
             *
             * <p>The distance is expressed in "depth pixels." The default distance depends
             * on the screen density. For instance, on a medium density display, the
             * default distance is 1280. On a high density display, the default distance
             * is 1920.</p>
             *
             * <p>If you want to specify a distance that leads to visually consistent
             * results across various densities, use the following formula:</p>
             * <pre>
             * Float scale = context.getResources().getDisplayMetrics().density;
             * view.setCameraDistance(distance * scale);
             * </pre>
             *
             * <p>The density scale factor of a high density display is 1.5,
             * and 1920 = 1280 * 1.5.</p>
             *
             * @param distance The distance in "depth pixels", if negative the opposite
             *        value is used
             *
             * @see #setRotationX(Float)
             * @see #setRotationY(Float)
             */
            SetCameraDistance(
                [in] Float distance);

            /**
             * The degrees that the view is rotated around the pivot point.
             *
             * @see #setRotation(Float)
             * @see #getPivotX()
             * @see #getPivotY()
             *
             * @return The degrees of rotation.
             */
            //@ViewDebug.ExportedProperty(category = "drawing")
            GetRotation(
                [out] Float* rotation);

            /**
             * Sets the degrees that the view is rotated around the pivot point. Increasing values
             * result in clockwise rotation.
             *
             * @param rotation The degrees of rotation.
             *
             * @see #getRotation()
             * @see #getPivotX()
             * @see #getPivotY()
             * @see #setRotationX(Float)
             * @see #setRotationY(Float)
             *
             * @attr ref android.R.styleable#View_rotation
             */
            SetRotation(
                [in] Float rotation);

            /**
             * The degrees that the view is rotated around the vertical axis through the pivot point.
             *
             * @see #getPivotX()
             * @see #getPivotY()
             * @see #setRotationY(Float)
             *
             * @return The degrees of Y rotation.
             */
            //@ViewDebug.ExportedProperty(category = "drawing")
            GetRotationY(
                [out] Float* y);

            /**
             * Sets the degrees that the view is rotated around the vertical axis through the pivot point.
             * Increasing values result in counter-clockwise rotation from the viewpoint of looking
             * down the y axis.
             *
             * When rotating large views, it is recommended to adjust the camera distance
             * accordingly. Refer to {@link #setCameraDistance(Float)} for more information.
             *
             * @param rotationY The degrees of Y rotation.
             *
             * @see #getRotationY()
             * @see #getPivotX()
             * @see #getPivotY()
             * @see #setRotation(Float)
             * @see #setRotationX(Float)
             * @see #setCameraDistance(Float)
             *
             * @attr ref android.R.styleable#View_rotationY
             */
            SetRotationY(
                [in] Float rotationY);

            /**
             * The degrees that the view is rotated around the horizontal axis through the pivot point.
             *
             * @see #getPivotX()
             * @see #getPivotY()
             * @see #setRotationX(Float)
             *
             * @return The degrees of X rotation.
             */
            //@ViewDebug.ExportedProperty(category = "drawing")
            GetRotationX(
                [out] Float* x);

            /**
             * Sets the degrees that the view is rotated around the horizontal axis through the pivot point.
             * Increasing values result in clockwise rotation from the viewpoint of looking down the
             * x axis.
             *
             * When rotating large views, it is recommended to adjust the camera distance
             * accordingly. Refer to {@link #setCameraDistance(Float)} for more information.
             *
             * @param rotationX The degrees of X rotation.
             *
             * @see #getRotationX()
             * @see #getPivotX()
             * @see #getPivotY()
             * @see #setRotation(Float)
             * @see #setRotationY(Float)
             * @see #setCameraDistance(Float)
             *
             * @attr ref android.R.styleable#View_rotationX
             */
            SetRotationX(
                [in] Float rotationX);

            /**
             * The amount that the view is scaled in x around the pivot point, as a proportion of
             * the view's unscaled width. A value of 1, the default, means that no scaling is applied.
             *
             * <p>By default, this is 1.0f.
             *
             * @see #getPivotX()
             * @see #getPivotY()
             * @return The scaling factor.
             */
            //@ViewDebug.ExportedProperty(category = "drawing")
            GetScaleX(
                [out] Float* x);

            /**
             * Sets the amount that the view is scaled in x around the pivot point, as a proportion of
             * the view's unscaled width. A value of 1 means that no scaling is applied.
             *
             * @param scaleX The scaling factor.
             * @see #getPivotX()
             * @see #getPivotY()
             *
             * @attr ref android.R.styleable#View_scaleX
             */
            SetScaleX(
             [in] Float scaleX);

            /**
             * The amount that the view is scaled in y around the pivot point, as a proportion of
             * the view's unscaled height. A value of 1, the default, means that no scaling is applied.
             *
             * <p>By default, this is 1.0f.
             *
             * @see #getPivotX()
             * @see #getPivotY()
             * @return The scaling factor.
             */
            //@ViewDebug.ExportedProperty(category = "drawing")
            GetScaleY(
                [out] Float* y);

            /**
             * Sets the amount that the view is scaled in Y around the pivot point, as a proportion of
             * the view's unscaled width. A value of 1 means that no scaling is applied.
             *
             * @param scaleY The scaling factor.
             * @see #getPivotX()
             * @see #getPivotY()
             *
             * @attr ref android.R.styleable#View_scaleY
             */
            SetScaleY(
                [in] Float scaleY);

            /**
             * The x location of the point around which the view is {@link #setRotation(Float) rotated}
             * and {@link #setScaleX(Float) scaled}.
             *
             * @see #getRotation()
             * @see #getScaleX()
             * @see #getScaleY()
             * @see #getPivotY()
             * @return The x location of the pivot point.
             *
             * @attr ref android.R.styleable#View_transformPivotX
             */
            //@ViewDebug.ExportedProperty(category = "drawing")
            GetPivotX(
                [out] Float* x);

            /**
             * Sets the x location of the point around which the view is
             * {@link #setRotation(Float) rotated} and {@link #setScaleX(Float) scaled}.
             * By default, the pivot point is centered on the object.
             * Setting this property disables this behavior and causes the view to use only the
             * explicitly set pivotX and pivotY values.
             *
             * @param pivotX The x location of the pivot point.
             * @see #getRotation()
             * @see #getScaleX()
             * @see #getScaleY()
             * @see #getPivotY()
             *
             * @attr ref android.R.styleable#View_transformPivotX
             */
            SetPivotX(
                [in] Float pivotX);

            /**
             * The y location of the point around which the view is {@link #setRotation(Float) rotated}
             * and {@link #setScaleY(Float) scaled}.
             *
             * @see #getRotation()
             * @see #getScaleX()
             * @see #getScaleY()
             * @see #getPivotY()
             * @return The y location of the pivot point.
             *
             * @attr ref android.R.styleable#View_transformPivotY
             */
            //@ViewDebug.ExportedProperty(category = "drawing")
            GetPivotY(
                [out] Float* y);

            /**
             * Sets the y location of the point around which the view is {@link #setRotation(Float) rotated}
             * and {@link #setScaleY(Float) scaled}. By default, the pivot point is centered on the object.
             * Setting this property disables this behavior and causes the view to use only the
             * explicitly set pivotX and pivotY values.
             *
             * @param pivotY The y location of the pivot point.
             * @see #getRotation()
             * @see #getScaleX()
             * @see #getScaleY()
             * @see #getPivotY()
             *
             * @attr ref android.R.styleable#View_transformPivotY
             */
            SetPivotY(
                [in] Float pivotY);

            /**
             * The opacity of the view. This is a value from 0 to 1, where 0 means the view is
             * completely transparent and 1 means the view is completely opaque.
             *
             * <p>By default this is 1.0f.
             * @return The opacity of the view.
             */
            //@ViewDebug.ExportedProperty(category = "drawing")
            GetAlpha(
                [out] Float* alpha);

            /**
             * Returns whether this View has content which overlaps. This function, intended to be
             * overridden by specific View types, is an optimization when alpha is set on a view. If
             * rendering overlaps in a view with alpha < 1, that view is drawn to an offscreen buffer
             * and then composited it into place, which can be expensive. If the view has no overlapping
             * rendering, the view can draw each primitive with the appropriate alpha value directly.
             * An example of overlapping rendering is a TextView with a background image, such as a
             * Button. An example of non-overlapping rendering is a TextView with no background, or
             * an ImageView with only the foreground image. The default implementation returns TRUE;
             * subclasses should override if they have cases which can be optimized.
             *
             * @return TRUE if the content in this view might overlap, FALSE otherwise.
             */
            HasOverlappingRendering(
                [out] Boolean* overlap);

            /**
             * <p>Sets the opacity of the view. This is a value from 0 to 1, where 0 means the view is
             * completely transparent and 1 means the view is completely opaque.</p>
             *
             * <p>If this view overrides {@link #onSetAlpha(Int32)} to return TRUE, then this view is
             * responsible for applying the opacity itself. Otherwise, calling this method is
             * equivalent to calling {@link #setLayerType(Int32, android.graphics.Paint)} and
             * setting a hardware layer.</p>
             *
             * <p>Note that setting alpha to a translucent value (0 < alpha < 1) may have
             * performance implications. It is generally best to use the alpha property sparingly and
             * transiently, as in the case of fading animations.</p>
             *
             * @param alpha The opacity of the view.
             *
             * @see #setLayerType(Int32, android.graphics.Paint)
             *
             * @attr ref android.R.styleable#View_alpha
             */
            SetAlpha(
                [in] Float alpha);

            /**
             * This property is hidden and intended only for use by the Fade transition, which
             * animates it to produce a visual translucency that does not side-effect (or get
             * affected by) the real alpha property. This value is composited with the other
             * alpha value (and the AlphaAnimation value, when that is present) to produce
             * a final visual translucency result, which is what is passed into the DisplayList.
             *
             * @hide
             */
            SetTransitionAlpha(
                [in] Float alpha);

            /**
             * This property is hidden and intended only for use by the Fade transition, which
             * animates it to produce a visual translucency that does not side-effect (or get
             * affected by) the real alpha property. This value is composited with the other
             * alpha value (and the AlphaAnimation value, when that is present) to produce
             * a final visual translucency result, which is what is passed into the DisplayList.
             *
             * @hide
             */
            GetTransitionAlpha(
                [out] Float* alpha);

            /**
             * Top position of this view relative to its parent.
             *
             * @return The top of this view, in pixels.
             */
            GetTop(
                [out] Int32* top);

            /**
             * Sets the top position of this view relative to its parent. This method is meant to be called
             * by the layout system and should not generally be called otherwise, because the property
             * may be changed at any time by the layout.
             *
             * @param top The top of this view, in pixels.
             */
            SetTop(
                [in] Int32 top);

            /**
             * Bottom position of this view relative to its parent.
             *
             * @return The bottom of this view, in pixels.
             */
            GetBottom(
                [out] Int32* bottom);

            /**
             * True if this view has changed since the last time being drawn.
             *
             * @return The dirty state of this view.
             */
            IsDirty(
                [out] Boolean* dirty);

            /**
             * Sets the bottom position of this view relative to its parent. This method is meant to be
             * called by the layout system and should not generally be called otherwise, because the
             * property may be changed at any time by the layout.
             *
             * @param bottom The bottom of this view, in pixels.
             */
            SetBottom(
                [in] Int32 bottom);

            /**
             * Left position of this view relative to its parent.
             *
             * @return The left edge of this view, in pixels.
             */
            GetLeft(
                [out] Int32* left);

            /**
             * Sets the left position of this view relative to its parent. This method is meant to be called
             * by the layout system and should not generally be called otherwise, because the property
             * may be changed at any time by the layout.
             *
             * @param left The bottom of this view, in pixels.
             */
            SetLeft(
                [in] Int32 left);

            /**
             * Right position of this view relative to its parent.
             *
             * @return The right edge of this view, in pixels.
             */
            GetRight(
                [out] Int32* right);

            /**
             * Sets the right position of this view relative to its parent. This method is meant to be called
             * by the layout system and should not generally be called otherwise, because the property
             * may be changed at any time by the layout.
             *
             * @param right The bottom of this view, in pixels.
             */
            SetRight(
                [in] Int32 right);

            /**
             * The visual x position of this view, in pixels. This is equivalent to the
             * {@link #setTranslationX(float) translationX} property plus the current
             * {@link #getLeft() left} property.
             *
             * @return The visual x position of this view, in pixels.
             */
            //@ViewDebug.ExportedProperty(category = "drawing")
            GetX(
                [out] Float* x);

            /**
             * Sets the visual x position of this view, in pixels. This is equivalent to setting the
             * {@link #setTranslationX(float) translationX} property to be the difference between
             * the x value passed in and the current {@link #getLeft() left} property.
             *
             * @param x The visual x position of this view, in pixels.
             */
            SetX(
                [in] Float x);

            /**
             * The visual y position of this view, in pixels. This is equivalent to the
             * {@link #setTranslationY(float) translationY} property plus the current
             * {@link #getTop() top} property.
             *
             * @return The visual y position of this view, in pixels.
             */
            //@ViewDebug.ExportedProperty(category = "drawing")
            GetY(
                [out] Float* y);

            /**
             * Sets the visual y position of this view, in pixels. This is equivalent to setting the
             * {@link #setTranslationY(float) translationY} property to be the difference between
             * the y value passed in and the current {@link #getTop() top} property.
             *
             * @param y The visual y position of this view, in pixels.
             */
            SetY(
                [in] Float y);

            /**
             * The visual z position of this view, in pixels. This is equivalent to the
             * {@link #setTranslationZ(float) translationZ} property plus the current
             * {@link #getElevation() elevation} property.
             *
             * @return The visual z position of this view, in pixels.
             */
            GetZ(
                [out] Float* z);

            /**
             * Sets the visual z position of this view, in pixels. This is equivalent to setting the
             * {@link #setTranslationZ(float) translationZ} property to be the difference between
             * the x value passed in and the current {@link #getElevation() elevation} property.
             *
             * @param z The visual z position of this view, in pixels.
             */
            SetZ(
                [in] Float z);

            /**
             * The base elevation of this view relative to its parent, in pixels.
             *
             * @return The base depth position of the view, in pixels.
             */
            GetElevation(
                [out] Float* result);

            /**
             * Sets the base elevation of this view, in pixels.
             *
             * @attr ref android.R.styleable#View_elevation
             */
            SetElevation(
                [in] Float elevation);

            /**
             * The horizontal location of this view relative to its {@link #getLeft() left} position.
             * This position is post-layout, in addition to wherever the object's
             * layout placed it.
             *
             * @return The horizontal position of this view relative to its left position, in pixels.
             */
            //@ViewDebug.ExportedProperty(category = "drawing")
            GetTranslationX(
                [out] Float* x);

            /**
             * Sets the horizontal location of this view relative to its {@link #getLeft() left} position.
             * This effectively positions the object post-layout, in addition to wherever the object's
             * layout placed it.
             *
             * @param translationX The horizontal position of this view relative to its left position,
             * in pixels.
             *
             * @attr ref android.R.styleable#View_translationX
             */
            SetTranslationX(
                [in] Float translationX);

            /**
             * The horizontal location of this view relative to its {@link #getTop() top} position.
             * This position is post-layout, in addition to wherever the object's
             * layout placed it.
             *
             * @return The vertical position of this view relative to its top position,
             * in pixels.
             */
            //@ViewDebug.ExportedProperty(category = "drawing")
            GetTranslationY(
                [out] Float* y);

            /**
             * Sets the vertical location of this view relative to its {@link #getTop() top} position.
             * This effectively positions the object post-layout, in addition to wherever the object's
             * layout placed it.
             *
             * @param translationY The vertical position of this view relative to its top position,
             * in pixels.
             *
             * @attr ref android.R.styleable#View_translationY
             */
            SetTranslationY(
                [in] Float translationY);

            /**
             * The depth location of this view relative to its {@link #getElevation() elevation}.
             *
             * @return The depth of this view relative to its elevation.
             */
            GetTranslationZ(
                [out] Float* z);

            /**
             * Sets the depth location of this view relative to its {@link #getElevation() elevation}.
             *
             * @attr ref android.R.styleable#View_translationZ
             */
            SetTranslationZ(
                [in] Float translationZ);

            /** @hide */
            SetAnimationMatrix(
                [in] IMatrix* matrix);

            /**
             * Returns the current StateListAnimator if exists.
             *
             * @return StateListAnimator or null if it does not exists
             * @see    #setStateListAnimator(android.animation.StateListAnimator)
             */
            GetStateListAnimator(
                [out] IStateListAnimator** anim);

            /**
             * Attaches the provided StateListAnimator to this View.
             * <p>
             * Any previously attached StateListAnimator will be detached.
             *
             * @param stateListAnimator The StateListAnimator to update the view
             * @see {@link android.animation.StateListAnimator}
             */
            SetStateListAnimator(
                [in] IStateListAnimator* anim);

            /**
             * Returns whether the Outline should be used to clip the contents of the View.
             * <p>
             * Note that this flag will only be respected if the View's Outline returns true from
             * {@link Outline#canClip()}.
             *
             * @see #setOutlineProvider(ViewOutlineProvider)
             * @see #setClipToOutline(boolean)
             */
            GetClipToOutline(
                [out] Boolean* result);

            /**
             * Sets whether the View's Outline should be used to clip the contents of the View.
             * <p>
             * Only a single non-rectangular clip can be applied on a View at any time.
             * Circular clips from a {@link ViewAnimationUtils#createCircularReveal(View, int, int, float, float)
             * circular reveal} animation take priority over Outline clipping, and
             * child Outline clipping takes priority over Outline clipping done by a
             * parent.
             * <p>
             * Note that this flag will only be respected if the View's Outline returns true from
             * {@link Outline#canClip()}.
             *
             * @see #setOutlineProvider(ViewOutlineProvider)
             * @see #getClipToOutline()
             */
            SetClipToOutline(
                [in] Boolean result);

            /**
             * Sets the {@link ViewOutlineProvider} of the view, which generates the Outline that defines
             * the shape of the shadow it casts, and enables outline clipping.
             * <p>
             * The default ViewOutlineProvider, {@link ViewOutlineProvider#BACKGROUND}, queries the Outline
             * from the View's background drawable, via {@link Drawable#getOutline(Outline)}. Changing the
             * outline provider with this method allows this behavior to be overridden.
             * <p>
             * If the ViewOutlineProvider is null, if querying it for an outline returns false,
             * or if the produced Outline is {@link Outline#isEmpty()}, shadows will not be cast.
             * <p>
             * Only outlines that return true from {@link Outline#canClip()} may be used for clipping.
             *
             * @see #setClipToOutline(boolean)
             * @see #getClipToOutline()
             * @see #getOutlineProvider()
             */
            SetOutlineProvider(
                [in] IViewOutlineProvider* provider);

            /**
             * Called to rebuild this View's Outline from its {@link ViewOutlineProvider outline provider}
             *
             * @see #setOutlineProvider(ViewOutlineProvider)
             */
            InvalidateOutline();

            /**
             * HierarchyViewer only
             *
             * @hide
             */
            HasShadow(
                [out] Boolean* result);

            /** @hide */
            SetRevealClip(
                [in] Boolean shouldClip,
                [in] Float x,
                [in] Float y,
                [in] Float radius);

            /**
             * Hit rectangle in parent's coordinates
             *
             * @param outRect The hit rectangle of the view.
             */
            GetHitRect(
                [in/*, out*/] IRect* outRect);

            /**
             * When a view has focus and the user navigates away from it, the next view is searched for
             * starting from the rectangle filled in by this method.
             *
             * By default, the rectangle is the {@link #getDrawingRect(android.graphics.Rect)})
             * of the view.  However, if your view maintains some idea of internal selection,
             * such as a cursor, or a selected row or column, you should override this method and
             * fill in a more specific rectangle.
             *
             * @param r The rectangle to fill in, in this view's coordinates.
             */
            GetFocusedRect(
                [in/*, out*/] IRect* outRect);

            /**
             * If some part of this view is not clipped by any of its parents, then
             * return that area in r in global (root) coordinates. To convert r to local
             * coordinates (without taking possible View rotations into account), offset
             * it by -globalOffset (e.g. r.offset(-globalOffset.x, -globalOffset.y)).
             * If the view is completely clipped or translated out, return false.
             *
             * @param r If true is returned, r holds the global coordinates of the
             *        visible portion of this view.
             * @param globalOffset If true is returned, globalOffset holds the dx,dy
             *        between this view and its root. globalOffet may be null.
             * @return true if r is non-empty (i.e. part of the view is visible at the
             *         root level.
             */
            GetGlobalVisibleRect(
                [in/*, out*/] IRect* outRect,
                [in/*, out*/] IPoint* outGlobalOffset,
                [out] Boolean* result);

            GetGlobalVisibleRect(
                [in/*, out*/] IRect* outRect,
                [out] Boolean* result);

            GetLocalVisibleRect(
                [in/*, out*/] IRect* outRect,
                [out] Boolean* result);

            /**
             * Offset this view's vertical location by the specified number of pixels.
             *
             * @param offset the number of pixels to offset the view by
             */
            OffsetTopAndBottom(
                [in] Int32 offset);

            /**
             * Offset this view's horizontal location by the specified amount of pixels.
             *
             * @param offset the numer of pixels to offset the view by
             */
            OffsetLeftAndRight(
                [in] Int32 offset);

            /**
             * Get the LayoutParams associated with this view. All views should have
             * layout parameters. These supply parameters to the <i>parent</i> of this
             * view specifying how it should be arranged. There are many subclasses of
             * ViewGroup.LayoutParams, and these correspond to the different subclasses
             * of ViewGroup that are responsible for arranging their children.
             *
             * This method may return null if this View is not attached to a parent
             * ViewGroup or {@link #setLayoutParams(android.view.ViewGroup.LayoutParams)}
             * was not invoked successfully. When a View is attached to a parent
             * ViewGroup, this method must not return null.
             *
             * @return The LayoutParams associated with this view, or null if no
             *         parameters have been set yet
             */
            GetLayoutParams(
                [out] IViewGroupLayoutParams** params);

            /**
             * Set the layout parameters associated with this view. These supply
             * parameters to the <i>parent</i> of this view specifying how it should be
             * arranged. There are many subclasses of ViewGroup.LayoutParams, and these
             * correspond to the different subclasses of ViewGroup that are responsible
             * for arranging their children.
             *
             * @param params The layout parameters for this view, cannot be null
             */
            SetLayoutParams(
                [in] IViewGroupLayoutParams* params);

            /**
             * Resolve the layout parameters depending on the resolved layout direction
             *
             * @hide
             */
            ResolveLayoutParams();

            /**
             * Set the scrolled position of your view. This will cause a call to
             * {@link #onScrollChanged(int, int, int, int)} and the view will be
             * invalidated.
             * @param x the x position to scroll to
             * @param y the y position to scroll to
             */
            ScrollTo(
                [in] Int32 x,
                [in] Int32 y);

            /**
             * Move the scrolled position of your view. This will cause a call to
             * {@link #onScrollChanged(int, int, int, int)} and the view will be
             * invalidated.
             * @param x the amount of pixels to scroll by horizontally
             * @param y the amount of pixels to scroll by vertically
             */
            ScrollBy(
                [in] Int32 x,
                [in] Int32 y);

            /**
             * Mark the area defined by dirty as needing to be drawn. If the view is
             * visible, {@link #onDraw(android.graphics.Canvas)} will be called at some point
             * in the future. This must be called from a UI thread. To call from a non-UI
             * thread, call {@link #postInvalidate()}.
             *
             * WARNING: This method is destructive to dirty.
             * @param dirty the rectangle representing the bounds of the dirty region
             */
            Invalidate(
                [in] IRect* dirty);

            /**
             * Mark the area defined by the rect (l,t,r,b) as needing to be drawn.
             * The coordinates of the dirty rect are relative to the view.
             * If the view is visible, {@link #onDraw(android.graphics.Canvas)}
             * will be called at some point in the future. This must be called from
             * a UI thread. To call from a non-UI thread, call {@link #postInvalidate()}.
             * @param l the left position of the dirty region
             * @param t the top position of the dirty region
             * @param r the right position of the dirty region
             * @param b the bottom position of the dirty region
             */
            Invalidate(
                [in] Int32 left,
                [in] Int32 top,
                [in] Int32 right,
                [in] Int32 bottom);

            /**
             * Invalidate the whole view. If the view is visible,
             * {@link #onDraw(android.graphics.Canvas)} will be called at some point in
             * the future. This must be called from a UI thread. To call from a non-UI thread,
             * call {@link #postInvalidate()}.
             */
            Invalidate();

            /**
             * Indicates whether this View is opaque. An opaque View guarantees that it will
             * draw all the pixels overlapping its bounds using a fully opaque color.
             *
             * Subclasses of View should override this method whenever possible to indicate
             * whether an instance is opaque. Opaque Views are treated in a special way by
             * the View hierarchy, possibly allowing it to perform optimizations during
             * invalidate/draw passes.
             *
             * @return True if this View is guaranteed to be fully opaque, false otherwise.
             */
            IsOpaque(
                [out] Boolean* opaque);

            /**
             * @return A handler associated with the thread running the View. This
             * handler can be used to pump events in the UI events queue.
             */
            GetHandler(
                [out] IHandler** apartment);

            GetViewRootImpl(
                [out] IViewRootImpl** impl);

            /**
             * <p>Causes the Runnable to be added to the message queue.
             * The runnable will be run on the user interface thread.</p>
             *
             * @param action The Runnable that will be executed.
             *
             * @return Returns true if the Runnable was successfully placed in to the
             *         message queue.  Returns false on failure, usually because the
             *         looper processing the message queue is exiting.
             *
             * @see #postDelayed
             * @see #removeCallbacks
             */
            Post(
                [in] IRunnable* action,
                [out] Boolean* result);

            /**
             * <p>Causes the Runnable to be added to the message queue, to be run
             * after the specified amount of time elapses.
             * The runnable will be run on the user interface thread.</p>
             *
             * @param action The Runnable that will be executed.
             * @param delayMillis The delay (in milliseconds) until the Runnable
             *        will be executed.
             *
             * @return true if the Runnable was successfully placed in to the
             *         message queue.  Returns false on failure, usually because the
             *         looper processing the message queue is exiting.  Note that a
             *         result of true does not mean the Runnable will be processed --
             *         if the looper is quit before the delivery time of the message
             *         occurs then the message will be dropped.
             *
             * @see #post
             * @see #removeCallbacks
             */
            PostDelayed(
                [in] IRunnable* action,
                [in] Int64 delayMillis,
                [out] Boolean* result);

            /**
             * <p>Causes the Runnable to execute on the next animation time step.
             * The runnable will be run on the user interface thread.</p>
             *
             * @param action The Runnable that will be executed.
             *
             * @see #postOnAnimationDelayed
             * @see #removeCallbacks
             */
            PostOnAnimation(
                [in] IRunnable* action);

            /**
             * <p>Causes the Runnable to execute on the next animation time step,
             * after the specified amount of time elapses.
             * The runnable will be run on the user interface thread.</p>
             *
             * @param action The Runnable that will be executed.
             * @param delayMillis The delay (in milliseconds) until the Runnable
             *        will be executed.
             *
             * @see #postOnAnimation
             * @see #removeCallbacks
             */
            PostOnAnimationDelayed(
                [in] IRunnable* action,
                [in] Int64 delayMillis);

            /**
             * <p>Removes the specified Runnable from the message queue.</p>
             *
             * @param action The Runnable to remove from the message handling queue
             *
             * @return true if this view could ask the Handler to remove the Runnable,
             *         false otherwise. When the returned value is true, the Runnable
             *         may or may not have been actually removed from the message queue
             *         (for instance, if the Runnable was not in the queue already.)
             *
             * @see #post
             * @see #postDelayed
             * @see #postOnAnimation
             * @see #postOnAnimationDelayed
             */
            RemoveCallbacks(
                [in] IRunnable* action,
                [out] Boolean* result);

            /**
             * Cause an invalidate to happen on a subsequent cycle through the event loop.
             * Use this to invalidate the View from a non-UI thread.
             *
             * @see #invalidate()
             */
            PostInvalidate();

            /**
             * Cause an invalidate of the specified area to happen on a subsequent cycle
             * through the event loop. Use this to invalidate the View from a non-UI thread.
             *
             * @param left The left coordinate of the rectangle to invalidate.
             * @param top The top coordinate of the rectangle to invalidate.
             * @param right The right coordinate of the rectangle to invalidate.
             * @param bottom The bottom coordinate of the rectangle to invalidate.
             *
             * @see #invalidate(int, int, int, int)
             * @see #invalidate(Rect)
             */
            PostInvalidate(
                [in] Int32 left,
                [in] Int32 top,
                [in] Int32 right,
                [in] Int32 bottom);

            /**
             * Cause an invalidate to happen on a subsequent cycle through the event
             * loop. Waits for the specified amount of time.
             *
             * @param delayMilliseconds the duration in milliseconds to delay the
             *         invalidation by
             */
            PostInvalidateDelayed(
                [in] Int64 delayMilliseconds);

            /**
             * Cause an invalidate of the specified area to happen on a subsequent cycle
             * through the event loop. Waits for the specified amount of time.
             *
             * @param delayMilliseconds the duration in milliseconds to delay the
             *         invalidation by
             * @param left The left coordinate of the rectangle to invalidate.
             * @param top The top coordinate of the rectangle to invalidate.
             * @param right The right coordinate of the rectangle to invalidate.
             * @param bottom The bottom coordinate of the rectangle to invalidate.
             */
            PostInvalidateDelayed(
                [in] Int64 delayMilliseconds,
                [in] Int32 left,
                [in] Int32 top,
                [in] Int32 right,
                [in] Int32 bottom);

            /**
             * <p>Cause an invalidate to happen on the next animation time step, typically the
             * next display frame.</p>
             *
             * <p>This method can be invoked from outside of the UI thread
             * only when this View is attached to a window.</p>
             *
             * @see #invalidate()
             */
            PostInvalidateOnAnimation();

            /**
             * <p>Cause an invalidate of the specified area to happen on the next animation
             * time step, typically the next display frame.</p>
             *
             * <p>This method can be invoked from outside of the UI thread
             * only when this View is attached to a window.</p>
             *
             * @param left The left coordinate of the rectangle to invalidate.
             * @param top The top coordinate of the rectangle to invalidate.
             * @param right The right coordinate of the rectangle to invalidate.
             * @param bottom The bottom coordinate of the rectangle to invalidate.
             *
             * @see #invalidate(int, int, int, int)
             * @see #invalidate(Rect)
             */
            PostInvalidateOnAnimation(
                [in] Int32 left,
                [in] Int32 top,
                [in] Int32 right,
                [in] Int32 bottom);

            /**
             * Called by a parent to request that a child update its values for mScrollX
             * and mScrollY if necessary. This will typically be done if the child is
             * animating a scroll using a {@link android.widget.Scroller Scroller}
             * object.
             */
            ComputeScroll();

            /**
             * <p>Indicate whether the horizontal edges are faded when the view is
             * scrolled horizontally.</p>
             *
             * @return true if the horizontal edges should are faded on scroll, false
             *         otherwise
             *
             * @see #setHorizontalFadingEdgeEnabled(boolean)
             *
             * @attr ref android.R.styleable#View_requiresFadingEdge
             */
            IsHorizontalFadingEdgeEnabled(
                [out] Boolean* horizontalFadingEdgeEnabled);

            /**
             * <p>Define whether the horizontal edges should be faded when this view
             * is scrolled horizontally.</p>
             *
             * @param horizontalFadingEdgeEnabled true if the horizontal edges should
             *                                    be faded when the view is scrolled
             *                                    horizontally
             *
             * @see #isHorizontalFadingEdgeEnabled()
             *
             * @attr ref android.R.styleable#View_requiresFadingEdge
             */
            SetHorizontalFadingEdgeEnabled(
                [in] Boolean horizontalFadingEdgeEnabled);

            /**
             * <p>Indicate whether the vertical edges are faded when the view is
             * scrolled horizontally.</p>
             *
             * @return true if the vertical edges should are faded on scroll, false
             *         otherwise
             *
             * @see #setVerticalFadingEdgeEnabled(boolean)
             *
             * @attr ref android.R.styleable#View_requiresFadingEdge
             */
            IsVerticalFadingEdgeEnabled(
                [out] Boolean* verticalFadingEdgeEnabled);

            /**
             * <p>Define whether the vertical edges should be faded when this view
             * is scrolled vertically.</p>
             *
             * @param verticalFadingEdgeEnabled true if the vertical edges should
             *                                  be faded when the view is scrolled
             *                                  vertically
             *
             * @see #isVerticalFadingEdgeEnabled()
             *
             * @attr ref android.R.styleable#View_requiresFadingEdge
             */
            SetVerticalFadingEdgeEnabled(
                [in] Boolean verticalFadingEdgeEnabled);

            /**
             * <p>Indicate whether the horizontal scrollbar should be drawn or not. The
             * scrollbar is not drawn by default.</p>
             *
             * @return true if the horizontal scrollbar should be painted, false
             *         otherwise
             *
             * @see #setHorizontalScrollBarEnabled(boolean)
             */
            IsHorizontalScrollBarEnabled(
                [out] Boolean* horizontalScrollBarEnabled);

            /**
             * <p>Define whether the horizontal scrollbar should be drawn or not. The
             * scrollbar is not drawn by default.</p>
             *
             * @param horizontalScrollBarEnabled true if the horizontal scrollbar should
             *                                   be painted
             *
             * @see #isHorizontalScrollBarEnabled()
             */
            SetHorizontalScrollBarEnabled(
                [in] Boolean horizontalScrollBarEnabled);

            /**
             * <p>Indicate whether the vertical scrollbar should be drawn or not. The
             * scrollbar is not drawn by default.</p>
             *
             * @return true if the vertical scrollbar should be painted, false
             *         otherwise
             *
             * @see #setVerticalScrollBarEnabled(boolean)
             */
            IsVerticalScrollBarEnabled(
                [out] Boolean* verticalScrollBarEnabled);

            /**
             * <p>Define whether the vertical scrollbar should be drawn or not. The
             * scrollbar is not drawn by default.</p>
             *
             * @param verticalScrollBarEnabled true if the vertical scrollbar should
             *                                 be painted
             *
             * @see #isVerticalScrollBarEnabled()
             */
            SetVerticalScrollBarEnabled(
                [in] Boolean verticalScrollBarEnabled);

            /**
             * Define whether scrollbars will fade when the view is not scrolling.
             *
             * @param fadeScrollbars wheter to enable fading
             *
             * @attr ref android.R.styleable#View_fadeScrollbars
             */
            SetScrollbarFadingEnabled(
                [in] Boolean fadeScrollbars);

            /**
             *
             * Returns true if scrollbars will fade when this view is not scrolling
             *
             * @return true if scrollbar fading is enabled
             *
             * @attr ref android.R.styleable#View_fadeScrollbars
             */
            IsScrollbarFadingEnabled(
                [out] Boolean* fadeScrollbars);

            /**
             *
             * Returns the delay before scrollbars fade.
             *
             * @return the delay before scrollbars fade
             *
             * @attr ref android.R.styleable#View_scrollbarDefaultDelayBeforeFade
             */
            GetScrollBarDefaultDelayBeforeFade(
                [out] Int32* defaultDelay);

            /**
             * Define the delay before scrollbars fade.
             *
             * @param scrollBarDefaultDelayBeforeFade - the delay before scrollbars fade
             *
             * @attr ref android.R.styleable#View_scrollbarDefaultDelayBeforeFade
             */
            SetScrollBarDefaultDelayBeforeFade(
                [in] Int32 scrollBarDefaultDelayBeforeFade);

            /**
             *
             * Returns the scrollbar fade duration.
             *
             * @return the scrollbar fade duration
             *
             * @attr ref android.R.styleable#View_scrollbarFadeDuration
             */
            GetScrollBarFadeDuration(
                [out] Int32* duration);

            /**
             * Define the scrollbar fade duration.
             *
             * @param scrollBarFadeDuration - the scrollbar fade duration
             *
             * @attr ref android.R.styleable#View_scrollbarFadeDuration
             */
            SetScrollBarFadeDuration(
                [in] Int32 scrollBarFadeDuration);

            /**
             *
             * Returns the scrollbar size.
             *
             * @return the scrollbar size
             *
             * @attr ref android.R.styleable#View_scrollbarSize
             */
            GetScrollBarSize(
                [out] Int32* size);

            /**
             * Define the scrollbar size.
             *
             * @param scrollBarSize - the scrollbar size
             *
             * @attr ref android.R.styleable#View_scrollbarSize
             */
            SetScrollBarSize(
                [in] Int32 scrollBarSize);

            /**
             * <p>Specify the style of the scrollbars. The scrollbars can be overlaid or
             * inset. When inset, they add to the padding of the view. And the scrollbars
             * can be drawn inside the padding area or on the edge of the view. For example,
             * if a view has a background drawable and you want to draw the scrollbars
             * inside the padding specified by the drawable, you can use
             * SCROLLBARS_INSIDE_OVERLAY or SCROLLBARS_INSIDE_INSET. If you want them to
             * appear at the edge of the view, ignoring the padding, then you can use
             * SCROLLBARS_OUTSIDE_OVERLAY or SCROLLBARS_OUTSIDE_INSET.</p>
             * @param style the style of the scrollbars. Should be one of
             * SCROLLBARS_INSIDE_OVERLAY, SCROLLBARS_INSIDE_INSET,
             * SCROLLBARS_OUTSIDE_OVERLAY or SCROLLBARS_OUTSIDE_INSET.
             * @see #SCROLLBARS_INSIDE_OVERLAY
             * @see #SCROLLBARS_INSIDE_INSET
             * @see #SCROLLBARS_OUTSIDE_OVERLAY
             * @see #SCROLLBARS_OUTSIDE_INSET
             *
             * @attr ref android.R.styleable#View_scrollbarStyle
             */
            SetScrollBarStyle(
                [in] Int32 style);

            /**
             * <p>Returns the current scrollbar style.</p>
             * @return the current scrollbar style
             * @see #SCROLLBARS_INSIDE_OVERLAY
             * @see #SCROLLBARS_INSIDE_INSET
             * @see #SCROLLBARS_OUTSIDE_OVERLAY
             * @see #SCROLLBARS_OUTSIDE_INSET
             *
             * @attr ref android.R.styleable#View_scrollbarStyle
             */
            // @ViewDebug.ExportedProperty(mapping = {
            //         @ViewDebug.IntToString(from = SCROLLBARS_INSIDE_OVERLAY, to = "INSIDE_OVERLAY"),
            //         @ViewDebug.IntToString(from = SCROLLBARS_INSIDE_INSET, to = "INSIDE_INSET"),
            //         @ViewDebug.IntToString(from = SCROLLBARS_OUTSIDE_OVERLAY, to = "OUTSIDE_OVERLAY"),
            //         @ViewDebug.IntToString(from = SCROLLBARS_OUTSIDE_INSET, to = "OUTSIDE_INSET")
            // })
            GetScrollBarStyle(
                [out] Int32* style);

            /**
             * Check if this view can be scrolled horizontally in a certain direction.
             *
             * @param direction Negative to check scrolling left, positive to check scrolling right.
             * @return true if this view can be scrolled in the specified direction, false otherwise.
             */
            CanScrollHorizontally(
                [in] Int32 direction,
                [out] Boolean* can);

            /**
             * Check if this view can be scrolled vertically in a certain direction.
             *
             * @param direction Negative to check scrolling up, positive to check scrolling down.
             * @return true if this view can be scrolled in the specified direction, false otherwise.
             */
            CanScrollVertically(
                [in] Int32 direction,
                [out] Boolean* can);

            /**
             * Resolve all RTL related properties.
             *
             * @hide
             */
            ResolveRtlPropertiesIfNeeded(
                [out] Boolean* res);

            /**
             * Reset resolution of all RTL related properties.
             *
             * @hide
             */
            ResetRtlProperties();

            /**
             * This method is called whenever the state of the screen this view is
             * attached to changes. A state change will usually occurs when the screen
             * turns on or off (whether it happens automatically or the user does it
             * manually.)
             *
             * @param screenState The new state of the screen. Can be either
             *                    {@link #SCREEN_STATE_ON} or {@link #SCREEN_STATE_OFF}
             */
            OnScreenStateChanged(
                [in] Int32 screenState);

            /**
             * Called when any RTL property (layout direction or text direction or text alignment) has
             * been changed.
             *
             * Subclasses need to override this method to take care of cached information that depends on the
             * resolved layout direction, or to inform child views that inherit their layout direction.
             *
             * The default implementation does nothing.
             *
             * @param layoutDirection the direction of the layout
             *
             * @see #LAYOUT_DIRECTION_LTR
             * @see #LAYOUT_DIRECTION_RTL
             */
            OnRtlPropertiesChanged(
                [in] Int32 layoutDirection);

            /**
             * Resolve and cache the layout direction. LTR is set initially. This is implicitly supposing
             * that the parent directionality can and will be resolved before its children.
             *
             * @return true if resolution has been done, false otherwise.
             *
             * @hide
             */
            ResolveLayoutDirection(
                [out] Boolean* result);

            /**
             * Check if layout direction resolution can be done.
             *
             * @return true if layout direction resolution can be done otherwise return false.
             *
             * @hide
             */
            CanResolveLayoutDirection(
                [out] Boolean*result);

            /**
             * Reset the resolved layout direction. Layout direction will be resolved during a call to
             * {@link #onMeasure(int, int)}.
             *
             * @hide
             */
            ResetResolvedLayoutDirection();

            /**
             * @return true if the layout direction is inherited.
             *
             * @hide
             */
            IsLayoutDirectionInherited(
                [out] Boolean*result);

            /**
             * @return true if layout direction has been resolved.
             */
            IsLayoutDirectionResolved(
                [out] Boolean*result);

            /**
             * Return if padding has been resolved
             *
             * @hide
             */
            IsPaddingResolved(
                [out] Boolean*result);

            /**
             * Resolve padding depending on layout direction.
             *
             * @hide
             */
            ResolvePadding();

            /**
             * Reset the resolved layout direction.
             *
             * @hide
             */
            ResetResolvedPadding();

            /**
             * Retrieve a unique token identifying the window this view is attached to.
             * @return Return the window's token for use in
             * {@link WindowManager.LayoutParams#token WindowManager.LayoutParams.token}.
             */
            GetWindowToken(
                [out] IBinder** token);

            /**
             * Retrieve the {@link WindowId} for the window this view is
             * currently attached to.
             */
            GetWindowId(
                [out] IWindowId** id);

            /**
             * Retrieve a unique token identifying the top-level "real" window of
             * the window that this view is attached to.  That is, this is like
             * {@link #getWindowToken}, except if the window this view in is a panel
             * window (attached to another containing window), then the token of
             * the containing window is returned instead.
             *
             * @return Returns the associated window token, either
             * {@link #getWindowToken()} or the containing window's token.
             */
            GetApplicationWindowToken(
                [out] IBinder** token);

            /**
             * Gets the logical display to which the view's window has been attached.
             *
             * @return The logical display, or null if the view is not currently attached to a window.
             */
            GetDisplay(
                [out] IDisplay** display);

            /**
             * Cancel any deferred high-level input events that were previously posted to the event queue.
             *
             * <p>Many views post high-level events such as click handlers to the event queue
             * to run deferred in order to preserve a desired user experience - clearing visible
             * pressed states before executing, etc. This method will abort any events of this nature
             * that are currently in flight.</p>
             *
             * <p>Custom views that generate their own high-level deferred input events should override
             * {@link #onCancelPendingInputEvents()} and remove those pending events from the queue.</p>
             *
             * <p>This will also cancel pending input events for any child views.</p>
             *
             * <p>Note that this may not be sufficient as a debouncing strategy for clicks in all cases.
             * This will not impact newer events posted after this call that may occur as a result of
             * lower-level input events still waiting in the queue. If you are trying to prevent
             * double-submitted  events for the duration of some sort of asynchronous transaction
             * you should also take other steps to protect against unexpected double inputs e.g. calling
             * {@link #setEnabled(boolean) setEnabled(false)} and re-enabling the view when
             * the transaction completes, tracking already submitted transaction IDs, etc.</p>
             */
            CancelPendingInputEvents();

            /**
             * Called as the result of a call to {@link #cancelPendingInputEvents()} on this view or
             * a parent view.
             *
             * <p>This method is responsible for removing any pending high-level input events that were
             * posted to the event queue to run later. Custom view classes that post their own deferred
             * high-level events via {@link #post(Runnable)}, {@link #postDelayed(Runnable, long)} or
             * {@link android.os.Handler} should override this method, call
             * <code>super.onCancelPendingInputEvents()</code> and remove those callbacks as appropriate.
             * </p>
             */
            OnCancelPendingInputEvents();

            /**
             * Store this view hierarchy's frozen state into the given container.
             *
             * @param container The SparseArray in which to save the view's state.
             *
             * @see #restoreHierarchyState(android.util.SparseArray)
             * @see #dispatchSaveInstanceState(android.util.SparseArray)
             * @see #onSaveInstanceState()
             */
            SaveHierarchyState(
                [in/*, out*/] ISparseArray* container);

            /**
             * Restore this view hierarchy's frozen state from the given container.
             *
             * @param container The SparseArray which holds previously frozen states.
             *
             * @see #saveHierarchyState(android.util.SparseArray)
             * @see #dispatchRestoreInstanceState(android.util.SparseArray)
             * @see #onRestoreInstanceState(android.os.Parcelable)
             */
            RestoreHierarchyState(
                [in] ISparseArray* container);

            /**
             * <p>Return the time at which the drawing of the view hierarchy started.</p>
             *
             * @return the drawing start time in milliseconds
             */
            GetDrawingTime(
                [out] Int64* time);

            /**
             * <p>Enables or disables the duplication of the parent's state into this view. When
             * duplication is enabled, this view gets its drawable state from its parent rather
             * than from its own internal properties.</p>
             *
             * <p>Note: in the current implementation, setting this property to true after the
             * view was added to a ViewGroup might have no effect at all. This property should
             * always be used from XML or set to true before adding this view to a ViewGroup.</p>
             *
             * <p>Note: if this view's parent addStateFromChildren property is enabled and this
             * property is enabled, an exception will be thrown.</p>
             *
             * <p>Note: if the child view uses and updates additionnal states which are unknown to the
             * parent, these states should not be affected by this method.</p>
             *
             * @param enabled True to enable duplication of the parent's drawable state, false
             *                to disable it.
             *
             * @see #getDrawableState()
             * @see #isDuplicateParentStateEnabled()
             */
            SetDuplicateParentStateEnabled(
                [in] Boolean enabled);

            /**
             * <p>Indicates whether this duplicates its drawable state from its parent.</p>
             *
             * @return True if this view's drawable state is duplicated from the parent,
             *         false otherwise
             *
             * @see #getDrawableState()
             * @see #setDuplicateParentStateEnabled(boolean)
             */
            IsDuplicateParentStateEnabled(
                [out] Boolean* result);

            /**
             * <p>Specifies the type of layer backing this view. The layer can be
             * {@link #LAYER_TYPE_NONE disabled}, {@link #LAYER_TYPE_SOFTWARE software} or
             * {@link #LAYER_TYPE_HARDWARE hardware}.</p>
             *
             * <p>A layer is associated with an optional {@link android.graphics.Paint}
             * instance that controls how the layer is composed on screen. The following
             * properties of the paint are taken into account when composing the layer:</p>
             * <ul>
             * <li>{@link android.graphics.Paint#getAlpha() Translucency (alpha)}</li>
             * <li>{@link android.graphics.Paint#getXfermode() Blending mode}</li>
             * <li>{@link android.graphics.Paint#getColorFilter() Color filter}</li>
             * </ul>
             *
             * <p>If this view has an alpha value set to < 1.0 by calling
             * {@link #setAlpha(float)}, the alpha value of the layer's paint is replaced by
             * this view's alpha value. Calling {@link #setAlpha(float)} is therefore
             * equivalent to setting a hardware layer on this view and providing a paint with
             * the desired alpha value.</p>
             *
             * <p>Refer to the documentation of {@link #LAYER_TYPE_NONE disabled},
             * {@link #LAYER_TYPE_SOFTWARE software} and {@link #LAYER_TYPE_HARDWARE hardware}
             * for more information on when and how to use layers.</p>
             *
             * @param layerType The type of layer to use with this view, must be one of
             *        {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or
             *        {@link #LAYER_TYPE_HARDWARE}
             * @param paint The paint used to compose the layer. This argument is optional
             *        and can be null. It is ignored when the layer type is
             *        {@link #LAYER_TYPE_NONE}
             *
             * @see #getLayerType()
             * @see #LAYER_TYPE_NONE
             * @see #LAYER_TYPE_SOFTWARE
             * @see #LAYER_TYPE_HARDWARE
             * @see #setAlpha(float)
             *
             * @attr ref android.R.styleable#View_layerType
             */
            SetLayerType(
                [in] Int32 layerType,
                [in] IPaint* paint);

            /**
             * Updates the {@link Paint} object used with the current layer (used only if the current
             * layer type is not set to {@link #LAYER_TYPE_NONE}). Changed properties of the Paint
             * provided to {@link #setLayerType(int, android.graphics.Paint)} will be used the next time
             * the View is redrawn, but {@link #setLayerPaint(android.graphics.Paint)} must be called to
             * ensure that the view gets redrawn immediately.
             *
             * <p>A layer is associated with an optional {@link android.graphics.Paint}
             * instance that controls how the layer is composed on screen. The following
             * properties of the paint are taken into account when composing the layer:</p>
             * <ul>
             * <li>{@link android.graphics.Paint#getAlpha() Translucency (alpha)}</li>
             * <li>{@link android.graphics.Paint#getXfermode() Blending mode}</li>
             * <li>{@link android.graphics.Paint#getColorFilter() Color filter}</li>
             * </ul>
             *
             * <p>If this view has an alpha value set to < 1.0 by calling
             * {@link #setAlpha(float)}, the alpha value of the layer's paint is replaced by
             * this view's alpha value. Calling {@link #setAlpha(float)} is therefore
             * equivalent to setting a hardware layer on this view and providing a paint with
             * the desired alpha value.</p>
             *
             * @param paint The paint used to compose the layer. This argument is optional
             *        and can be null. It is ignored when the layer type is
             *        {@link #LAYER_TYPE_NONE}
             *
             * @see #setLayerType(int, android.graphics.Paint)
             */
            SetLayerPaint(
                [in] IPaint* paint);

            /**
             * Indicates what type of layer is currently associated with this view. By default
             * a view does not have a layer, and the layer type is {@link #LAYER_TYPE_NONE}.
             * Refer to the documentation of {@link #setLayerType(int, android.graphics.Paint)}
             * for more information on the different types of layers.
             *
             * @return {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or
             *         {@link #LAYER_TYPE_HARDWARE}
             *
             * @see #setLayerType(int, android.graphics.Paint)
             * @see #buildLayer()
             * @see #LAYER_TYPE_NONE
             * @see #LAYER_TYPE_SOFTWARE
             * @see #LAYER_TYPE_HARDWARE
             */
            GetLayerType(
                [out] Int32* type);

            /**
             * Forces this view's layer to be created and this view to be rendered
             * into its layer. If this view's layer type is set to {@link #LAYER_TYPE_NONE},
             * invoking this method will have no effect.
             *
             * This method can for instance be used to render a view into its layer before
             * starting an animation. If this view is complex, rendering into the layer
             * before starting the animation will avoid skipping frames.
             *
             * @throws IllegalStateException If this view is not attached to a window
             *
             * @see #setLayerType(int, android.graphics.Paint)
             */
            BuildLayer();

            /**
             * <p>Enables or disables the drawing cache. When the drawing cache is enabled, the next call
             * to {@link #getDrawingCache()} or {@link #buildDrawingCache()} will draw the view in a
             * bitmap. Calling {@link #draw(android.graphics.Canvas)} will not draw from the cache when
             * the cache is enabled. To benefit from the cache, you must request the drawing cache by
             * calling {@link #getDrawingCache()} and draw it on screen if the returned bitmap is not
             * null.</p>
             *
             * <p>Enabling the drawing cache is similar to
             * {@link #setLayerType(int, android.graphics.Paint) setting a layer} when hardware
             * acceleration is turned off. When hardware acceleration is turned on, enabling the
             * drawing cache has no effect on rendering because the system uses a different mechanism
             * for acceleration which ignores the flag. If you want to use a Bitmap for the view, even
             * when hardware acceleration is enabled, see {@link #setLayerType(int, android.graphics.Paint)}
             * for information on how to enable software and hardware layers.</p>
             *
             * <p>This API can be used to manually generate
             * a bitmap copy of this view, by setting the flag to <code>true</code> and calling
             * {@link #getDrawingCache()}.</p>
             *
             * @param enabled true to enable the drawing cache, false otherwise
             *
             * @see #isDrawingCacheEnabled()
             * @see #getDrawingCache()
             * @see #buildDrawingCache()
             * @see #setLayerType(int, android.graphics.Paint)
             */
            SetDrawingCacheEnabled(
                [in] Boolean enabled);

            /**
             * <p>Indicates whether the drawing cache is enabled for this view.</p>
             *
             * @return true if the drawing cache is enabled
             *
             * @see #setDrawingCacheEnabled(boolean)
             * @see #getDrawingCache()
             */
            IsDrawingCacheEnabled(
                [out] Boolean* enabled);

            /**
             * A view that is not attached or hardware accelerated cannot create a display list.
             * This method checks these conditions and returns the appropriate result.
             *
             * @return true if view has the ability to create a display list, false otherwise.
             *
             * @hide
             */
            CanHaveDisplayList(
                [out] Boolean* can);

            /**
             * <p>Returns a display list that can be used to draw this view again
             * without executing its draw method.</p>
             *
             * @return A DisplayList ready to replay, or null if caching is not enabled.
             *
             * @hide
             */
            GetDisplayList(
                [out] IRenderNode** list);

            /**
             * <p>Calling this method is equivalent to calling <code>getDrawingCache(false)</code>.</p>
             *
             * @return A non-scaled bitmap representing this view or NULL if cache is disabled.
             *
             * @see #getDrawingCache(boolean)
             */
            GetDrawingCache(
                [out] IBitmap** bitmap);

            /**
             * <p>Returns the bitmap in which this view drawing is cached. The returned bitmap
             * is NULL when caching is disabled. If caching is enabled and the cache is not ready,
             * this method will create it. Calling {@link #draw(android.graphics.Canvas)} will not
             * draw from the cache when the cache is enabled. To benefit from the cache, you must
             * request the drawing cache by calling this method and draw it on screen if the
             * returned bitmap is not NULL.</p>
             *
             * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
             * this method will create a bitmap of the same size as this view. Because this bitmap
             * will be drawn scaled by the parent ViewGroup, the result on screen might show
             * scaling artifacts. To avoid such artifacts, you should call this method by setting
             * the auto scaling to true. Doing so, however, will generate a bitmap of a different
             * size than the view. This implies that your application must be able to handle this
             * size.</p>
             *
             * @param autoScale Indicates whether the generated bitmap should be scaled based on
             *        the current density of the screen when the application is in compatibility
             *        mode.
             *
             * @return A bitmap representing this view or NULL if cache is disabled.
             *
             * @see #setDrawingCacheEnabled(boolean)
             * @see #isDrawingCacheEnabled()
             * @see #buildDrawingCache(boolean)
             * @see #destroyDrawingCache()
             */
            GetDrawingCache(
                [in] Boolean autoScale,
                [out] IBitmap** bitmap);

            /**
             * <p>Frees the resources used by the drawing cache. If you call
             * {@link #buildDrawingCache()} manually without calling
             * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
             * should cleanup the cache with this method afterwards.</p>
             *
             * @see #setDrawingCacheEnabled(boolean)
             * @see #buildDrawingCache()
             * @see #getDrawingCache()
             */
            DestroyDrawingCache();

            /**
             * Setting a solid background color for the drawing cache's bitmaps will improve
             * perfromance and memory usage. Note, though that this should only be used if this
             * view will always be drawn on top of a solid color.
             *
             * @param color The background color to use for the drawing cache's bitmap
             *
             * @see #setDrawingCacheEnabled(boolean)
             * @see #buildDrawingCache()
             * @see #getDrawingCache()
             */
            SetDrawingCacheBackgroundColor(
                [in] Int32 color);

            /**
             * @see #setDrawingCacheBackgroundColor(int)
             *
             * @return The background color to used for the drawing cache's bitmap
             */
            GetDrawingCacheBackgroundColor(
                [out] Int32* color);

            /**
             * <p>Calling this method is equivalent to calling <code>buildDrawingCache(false)</code>.</p>
             *
             * @see #buildDrawingCache(boolean)
             */
            BuildDrawingCache();

            /**
             * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
             *
             * <p>If you call {@link #buildDrawingCache()} manually without calling
             * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
             * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
             *
             * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
             * this method will create a bitmap of the same size as this view. Because this bitmap
             * will be drawn scaled by the parent ViewGroup, the result on screen might show
             * scaling artifacts. To avoid such artifacts, you should call this method by setting
             * the auto scaling to true. Doing so, however, will generate a bitmap of a different
             * size than the view. This implies that your application must be able to handle this
             * size.</p>
             *
             * @see #getDrawingCache()
             * @see #destroyDrawingCache()
             */
            BuildDrawingCache(
                [in] Boolean autoScale);

            /**
             * Indicates whether this View is currently in edit mode. A View is usually
             * in edit mode when displayed within a developer tool. For instance, if
             * this View is being drawn by a visual user interface builder, this method
             * should return true.
             *
             * Subclasses should check the return value of this method to provide
             * different behaviors if their normal behavior might interfere with the
             * host environment. For instance: the class spawns a thread in its
             * constructor, the drawing code relies on device-specific features, etc.
             *
             * This method is usually checked in the drawing code of custom widgets.
             *
             * @return True if this View is in edit mode, false otherwise.
             */
            IsInEditMode(
                [out] Boolean* result);

            /**
             * <p>Indicates whether this view is attached to a hardware accelerated
             * window or not.</p>
             *
             * <p>Even if this method returns true, it does not mean that every call
             * to {@link #draw(android.graphics.Canvas)} will be made with an hardware
             * accelerated {@link android.graphics.Canvas}. For instance, if this view
             * is drawn onto an offscreen {@link android.graphics.Bitmap} and its
             * window is hardware accelerated,
             * {@link android.graphics.Canvas#isHardwareAccelerated()} will likely
             * return false, and this method will return true.</p>
             *
             * @return True if the view is attached to a window and the window is
             *         hardware accelerated; false in any other case.
             */
            IsHardwareAccelerated(
                [out] Boolean* result);

            /**
             * Sets a rectangular area on this view to which the view will be clipped
             * when it is drawn. Setting the value to null will remove the clip bounds
             * and the view will draw normally, using its full bounds.
             *
             * @param clipBounds The rectangular area, in the local coordinates of
             * this view, to which future drawing operations will be clipped.
             */
            SetClipBounds(
                [in] IRect* clipBounds);

            /**
             * Returns a copy of the current {@link #setClipBounds(Rect) clipBounds}.
             *
             * @return A copy of the current clip bounds if clip bounds are set,
             * otherwise null.
             */
            GetClipBounds(
                [out] IRect** rect);

            /**
             * Manually render this view (and all of its children) to the given Canvas.
             * The view must have already done a full layout before this function is
             * called.  When implementing a view, implement
             * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
             * If you do need to override this method, call the superclass version.
             *
             * @param canvas The Canvas to which the View is rendered.
             */
            Draw(
                [in] ICanvas* canvas);

            /**
             * Returns the overlay for this view, creating it if it does not yet exist.
             * Adding drawables to the overlay will cause them to be displayed whenever
             * the view itself is redrawn. Objects in the overlay should be actively
             * managed: remove them when they should not be displayed anymore. The
             * overlay will always have the same size as its host view.
             *
             * <p>Note: Overlays do not currently work correctly with {@link
             * SurfaceView} or {@link TextureView}; contents in overlays for these
             * types of views may not display correctly.</p>
             *
             * @return The ViewOverlay object for this view.
             * @see ViewOverlay
             */
            GetOverlay(
                [out] IViewOverlay** overlay);

            /**
             * Override this if your view is known to always be drawn on top of a solid color background,
             * and needs to draw fading edges. Returning a non-zero color enables the view system to
             * optimize the drawing of the fading edges. If you do return a non-zero color, the alpha
             * should be set to 0xFF.
             *
             * @see #setVerticalFadingEdgeEnabled(boolean)
             * @see #setHorizontalFadingEdgeEnabled(boolean)
             *
             * @return The known solid color background for this view, or 0 if the color may vary
             */
            //@ViewDebug.ExportedProperty(category = "drawing")
            GetSolidColor(
                [out] Int32* color);

            /**
             * <p>Indicates whether or not this view's layout will be requested during
             * the next hierarchy layout pass.</p>
             *
             * @return true if the layout will be forced during next layout pass
             */
            IsLayoutRequested(
                [out] Boolean* result);

            /**
             * Assign a size and position to a view and all of its
             * descendants
             *
             * <p>This is the second phase of the layout mechanism.
             * (The first is measuring). In this phase, each parent calls
             * layout on all of its children to position them.
             * This is typically done using the child measurements
             * that were stored in the measure pass().</p>
             *
             * <p>Derived classes should not override this method.
             * Derived classes with children should override
             * onLayout. In that method, they should
             * call layout on each of their children.</p>
             *
             * @param l Left position, relative to parent
             * @param t Top position, relative to parent
             * @param r Right position, relative to parent
             * @param b Bottom position, relative to parent
             */
            Layout(
                [in] Int32 l,
                [in] Int32 t,
                [in] Int32 r,
                [in] Int32 b);

            /**
             * Returns the resources associated with this view.
             *
             * @return Resources object.
             */
            GetResources(
                [out] IResources** resources);

            /**
             * Unschedule any events associated with the given Drawable.  This can be
             * used when selecting a new Drawable into a view, so that the previous
             * one is completely unscheduled.
             *
             * @param who The Drawable to unschedule.
             *
             * @see #drawableStateChanged
             */
            UnscheduleDrawable(
                [in] IDrawable* who);

            /**
             * Called when layout direction has been resolved.
             *
             * The default implementation does nothing.
             *
             * @param layoutDirection The resolved layout direction.
             *
             * @see #LAYOUT_DIRECTION_LTR
             * @see #LAYOUT_DIRECTION_RTL
             *
             * @hide
             */
            OnResolveDrawables(
                [in] Int32 layoutDirection);

            /**
             * This function is called whenever the view hotspot changes and needs to
             * be propagated to drawables managed by the view.
             * <p>
             * Be sure to call through to the superclass when overriding this function.
             *
             * @param x hotspot x coordinate
             * @param y hotspot y coordinate
             */
            DrawableHotspotChanged(
                [in] Float x,
                [in] Float y);

            /**
             * Call this to force a view to update its drawable state. This will cause
             * drawableStateChanged to be called on this view. Views that are interested
             * in the new state should call getDrawableState.
             *
             * @see #drawableStateChanged
             * @see #getDrawableState
             */
            RefreshDrawableState();

            /**
             * Return an array of resource IDs of the drawable states representing the
             * current state of the view.
             *
             * @return The current drawable state
             *
             * @see Drawable#setState
             * @see #drawableStateChanged
             * @see #onCreateDrawableState
             */
            GetDrawableState(
                [out, callee] ArrayOf<Int32>* state);

            /**
             * Call {@link Drawable#jumpToCurrentState() Drawable.jumpToCurrentState()}
             * on all Drawable objects associated with this view.
             */
            JumpDrawablesToCurrentState();

            /**
             * Sets the background color for this view.
             * @param color the color of the background
             */
            SetBackgroundColor(
                [in] Int32 color);

            /**
             * Set the background to a given resource. The resource should refer to
             * a Drawable object or 0 to remove the background.
             * @param resid The identifier of the resource.
             * @attr ref android.R.styleable#Int32 background
             */
            SetBackgroundResource(
                [in] Int32 resid);

            /**
             * Set the background to a given Drawable, or remove the background. If the
             * background has padding, this View's padding is set to the background's
             * padding. However, when a background is removed, this View's padding isn't
             * touched. If setting the padding is desired, please use
             * {@link #setPadding(int, int, int, int)}.
             *
             * @param background The Drawable to use as the background, or null to remove the
             *        background
             */
            SetBackground(
                [in] IDrawable* background);

            /**
             * Set the background to a given Drawable, or remove the background. If the
             * background has padding, this View's padding is set to the background's
             * padding. However, when a background is removed, this View's padding isn't
             * touched. If setting the padding is desired, please use
             * {@link #setPadding(int, int, int, int)}.
             *
             * @param d The Drawable to use as the background, or NULL to remove the
             *        background
             */
            SetBackgroundDrawable(
                [in] IDrawable* d);

            /**
             * Gets the background drawable
             *
             * @return The drawable used as the background for this view, if any.
             *
             * @see #setBackground(Drawable)
             *
             * @attr ref android.R.styleable#View_background
             */
            GetBackground(
                [out] IDrawable** drawable);

            /**
             * Applies a tint to the background drawable. Does not modify the current tint
             * mode, which is {@link PorterDuff.Mode#SRC_IN} by default.
             * <p>
             * Subsequent calls to {@link #setBackground(Drawable)} will automatically
             * mutate the drawable and apply the specified tint and tint mode using
             * {@link Drawable#setTintList(ColorStateList)}.
             *
             * @param tint the tint to apply, may be {@code null} to clear tint
             *
             * @attr ref android.R.styleable#View_backgroundTint
             * @see #getBackgroundTintList()
             * @see Drawable#setTintList(ColorStateList)
             */
            SetBackgroundTintList(
                [in] IColorStateList* tint);

            /**
             * Return the tint applied to the background drawable, if specified.
             *
             * @return the tint applied to the background drawable
             * @attr ref android.R.styleable#View_backgroundTint
             * @see #setBackgroundTintList(ColorStateList)
             */
            GetBackgroundTintList(
                [out] IColorStateList** tint);

            /**
             * Specifies the blending mode used to apply the tint specified by
             * {@link #setBackgroundTintList(ColorStateList)}} to the background
             * drawable. The default mode is {@link PorterDuff.Mode#SRC_IN}.
             *
             * @param tintMode the blending mode used to apply the tint, may be
             *                 {@code null} to clear tint
             * @attr ref android.R.styleable#View_backgroundTintMode
             * @see #getBackgroundTintMode()
             * @see Drawable#setTintMode(PorterDuff.Mode)
             */
             SetBackgroundTintMode(
                [in] PorterDuffMode tintMode);

            /**
             * Return the blending mode used to apply the tint to the background
             * drawable, if specified.
             *
             * @return the blending mode used to apply the tint to the background
             *         drawable
             * @attr ref android.R.styleable#View_backgroundTintMode
             * @see #setBackgroundTintMode(PorterDuff.Mode)
             */
             GetBackgroundTintMode(
                [out] PorterDuffMode* tintMode);

            /**
             * Sets the padding. The view may add on the space required to display
             * the scrollbars, depending on the style and visibility of the scrollbars.
             * So the values returned from {@link #getPaddingLeft}, {@link #getPaddingTop},
             * {@link #getPaddingRight} and {@link #getPaddingBottom} may be different
             * from the values set in this call.
             *
             * @attr ref android.R.styleable#Int32 padding
             * @attr ref android.R.styleable#Int32 paddingBottom
             * @attr ref android.R.styleable#Int32 paddingLeft
             * @attr ref android.R.styleable#Int32 paddingRight
             * @attr ref android.R.styleable#Int32 paddingTop
             * @param left the left padding in pixels
             * @param top the top padding in pixels
             * @param right the right padding in pixels
             * @param bottom the bottom padding in pixels
             */
            SetPadding(
                [in] Int32 left,
                [in] Int32 top,
                [in] Int32 right,
                [in] Int32 bottom);

            GetPadding(
                [out] Int32* left,
                [out] Int32* top,
                [out] Int32* right,
                [out] Int32* bottom);

            /**
             * Sets the relative padding. The view may add on the space required to display
             * the scrollbars, depending on the style and visibility of the scrollbars.
             * So the values returned from {@link #getPaddingStart}, {@link #getPaddingTop},
             * {@link #getPaddingEnd} and {@link #getPaddingBottom} may be different
             * from the values set in this call.
             *
             * @attr ref android.R.styleable#View_padding
             * @attr ref android.R.styleable#View_paddingBottom
             * @attr ref android.R.styleable#View_paddingStart
             * @attr ref android.R.styleable#View_paddingEnd
             * @attr ref android.R.styleable#View_paddingTop
             * @param start the start padding in pixels
             * @param top the top padding in pixels
             * @param end the end padding in pixels
             * @param bottom the bottom padding in pixels
             */
            SetPaddingRelative(
                [in] Int32 start,
                [in] Int32 top,
                [in] Int32 end,
                [in] Int32 bottom);

            /**
             * Returns the top padding of this view.
             *
             * @return the top padding in pixels
             */
            GetPaddingTop(
                [out] Int32* top);

            /**
             * Returns the bottom padding of this view. If there are inset and enabled
             * scrollbars, this value may include the space required to display the
             * scrollbars as well.
             *
             * @return the bottom padding in pixels
             */
            GetPaddingBottom(
                [out] Int32* bottom);

            /**
             * Returns the left padding of this view. If there are inset and enabled
             * scrollbars, this value may include the space required to display the
             * scrollbars as well.
             *
             * @return the left padding in pixels
             */
            GetPaddingLeft(
                [out] Int32* left);

            /**
             * Returns the start padding of this view depending on its resolved layout direction.
             * If there are inset and enabled scrollbars, this value may include the space
             * required to display the scrollbars as well.
             *
             * @return the start padding in pixels
             */
            GetPaddingStart(
                [out] Int32* start);

            /**
             * Returns the right padding of this view. If there are inset and enabled
             * scrollbars, this value may include the space required to display the
             * scrollbars as well.
             *
             * @return the right padding in pixels
             */
            GetPaddingRight(
                [out] Int32* right);

            /**
             * Returns the end padding of this view depending on its resolved layout direction.
             * If there are inset and enabled scrollbars, this value may include the space
             * required to display the scrollbars as well.
             *
             * @return the end padding in pixels
             */
            GetPaddingEnd(
                [out] Int32* end);

            /**
             * Return if the padding as been set thru relative values
             * {@link #setPaddingRelative(int, int, int, int)} or thru
             * @attr ref android.R.styleable#View_paddingStart or
             * @attr ref android.R.styleable#View_paddingEnd
             *
             * @return true if the padding is relative or false if it is not.
             */
            IsPaddingRelative(
                [out] Boolean* relative);

            /**
             * @hide
             */
            ResetPaddingToInitialValues();

            /**
             * @hide
             */
            GetOpticalInsets(
                [out] IInsets** sets);

            /**
             * Changes the selection state of this view. A view can be selected or not.
             * Note that selection is not the same as focus. Views are typically
             * selected in the context of an AdapterView like ListView or GridView;
             * the selected view is the view that is highlighted.
             *
             * @param selected true if the view must be selected, false otherwise
             */
            SetSelected(
                [in] Boolean selected);

            /**
             * Indicates the selection state of this view.
             *
             * @return true if the view is selected, false otherwise
             */
            IsSelected(
                [out] Boolean* selected);

            /**
             * Changes the activated state of this view. A view can be activated or not.
             * Note that activation is not the same as selection.  Selection is
             * a transient property, representing the view (hierarchy) the user is
             * currently interacting with.  Activation is a longer-term state that the
             * user can move views in and out of.  For example, in a list view with
             * single or multiple selection enabled, the views in the current selection
             * set are activated.  (Um, yeah, we are deeply sorry about the terminology
             * here.)  The activated state is propagated down to children of the view it
             * is set on.
             *
             * @param activated true if the view must be activated, false otherwise
             */
            SetActivated(
                [in] Boolean activated);

            /**
             * Indicates the activation state of this view.
             *
             * @return true if the view is activated, false otherwise
             */
            //@ViewDebug.ExportedProperty
            IsActivated(
                [out] Boolean* activated);

            /**
             * Returns the ViewTreeObserver for this view's hierarchy. The view tree
             * observer can be used to get notifications when global events, like
             * layout, happen.
             *
             * The returned ViewTreeObserver observer is not guaranteed to remain
             * valid for the lifetime of this View. If the caller of this method keeps
             * a long-lived reference to ViewTreeObserver, it should always check for
             * the return value of {@link ViewTreeObserver#isAlive()}.
             *
             * @return The ViewTreeObserver for this view's hierarchy.
             */
            GetViewTreeObserver(
                [out] IViewTreeObserver** observer);

            /**
             * <p>Finds the topmost view in the current view hierarchy.</p>
             *
             * @return the topmost view containing this view
             */
            GetRootView(
                [out] IView** view);

            /**
             * Transforms a motion event from view-local coordinates to on-screen
             * coordinates.
             *
             * @param ev the view-local motion event
             * @return false if the transformation could not be applied
             * @hide
             */
            ToGlobalMotionEvent(
                [in] IMotionEvent* ev,
                [out] Boolean* result);

            /**
             * Transforms a motion event from on-screen coordinates to view-local
             * coordinates.
             *
             * @param ev the on-screen motion event
             * @return false if the transformation could not be applied
             * @hide
             */
            ToLocalMotionEvent(
                [in] IMotionEvent* ev,
                [out] Boolean* result);

            /**
             * Modifies the input matrix such that it maps view-local coordinates to
             * on-screen coordinates.
             *
             * @param m input matrix to modify
             * @hide
             */
            TransformMatrixToGlobal(
                [in] IMatrix* m);

            /**
             * Modifies the input matrix such that it maps on-screen coordinates to
             * view-local coordinates.
             *
             * @param m input matrix to modify
             * @hide
             */
            TransformMatrixToLocal(
                [in] IMatrix* m);

            /**
             * <p>Computes the coordinates of this view on the screen. The argument
             * must be an array of two integers. After the method returns, the array
             * contains the x and y location in that order.</p>
             *
             * @param location an array of two integers in which to hold the coordinates
             */
            GetLocationOnScreen(
                [in] ArrayOf<Int32> * res);

            /**
             * <p>Computes the coordinates of this view in its window. The argument
             * must be an array of two integers. After the method returns, the array
             * contains the x and y location in that order.</p>
             *
             * @param location an array of two integers in which to hold the coordinates
             */
            GetLocationInWindow(
                [in] ArrayOf<Int32> * res);

            /**
             * Look for a child view with the given id.  If this view has the given
             * id, return this view.
             *
             * @param id The id to search for.
             * @return The view that has the given id in the hierarchy or null
             */
            FindViewById(
                [in] Int32 id,
                [out] IView** view);

            /**
             * Performs the traversal to find a view by its unuque and stable accessibility id.
             *
             * <strong>Note:</strong>This method does not stop at the root namespace
             * boundary since the user can touch the screen at an arbitrary location
             * potentially crossing the root namespace bounday which will send an
             * accessibility event to accessibility services and they should be able
             * to obtain the event source. Also accessibility ids are guaranteed to be
             * unique in the window.
             *
             * @param accessibilityId The accessibility id.
             * @return The found view.
             *
             * @hide
             */
            FindViewByAccessibilityIdTraversal(
                [in] Int32 id,
                [out] IView** view);

            /**
             * Look for a child view with the given tag.  If this view has the given
             * tag, return this view.
             *
             * @param tag The tag to search for, using "tag.equals(getTag())".
             * @return The View that has the given tag in the hierarchy or null
             */
            FindViewWithTag(
                [in] IInterface* tag,
                [out] IView** view);

            /**
             * {@hide}
             * Look for a child view that matches the specified predicate.
             * If this view matches the predicate, return this view.
             *
             * @param predicate The predicate to evaluate.
             * @return The first view that matches the predicate or null.
             */
            FindViewByPredicate(
                [in] IPredicate* predicate,
                [out] IView** view);

            /**
             * {@hide}
             * Look for a child view that matches the specified predicate,
             * starting with the specified view and its descendents and then
             * recusively searching the ancestors and siblings of that view
             * until this view is reached.
             *
             * This method is useful in cases where the predicate does not match
             * a single unique view (perhaps multiple views use the same id)
             * and we are trying to find the view that is "closest" in scope to the
             * starting view.
             *
             * @param start The view to start from.
             * @param predicate The predicate to evaluate.
             * @return The first view that matches the predicate or null.
             */
            FindViewByPredicateInsideOut(
                [in] IView* start,
                [in] IPredicate* predicate,
                [out] IView** view);

            /**
             * Sets the identifier for this view. The identifier does not have to be
             * unique in this view's hierarchy. The identifier should be a positive
             * number.
             *
             * @see #NO_ID
             * @see #getId
             * @see #findViewById
             *
             * @param id a number used to identify the view
             *
             * @attr ref android.R.styleable#Int32 id
             */
            SetId(
                [in] Int32 id);

            /**
             * Returns this view's identifier.
             *
             * @return a positive integer used to identify the view or {@link #NO_ID}
             *         if the view has no ID
             *
             * @see #setId
             * @see #findViewById
             * @attr ref android.R.styleable#Int32 id
             */
            GetId(
                [out] Int32* id);

            /**
             * {@hide}
             *
             * @param isRoot true if the view belongs to the root namespace, false
             *        otherwise
             */
            SetIsRootNamespace(
                [in] Boolean result);

            /**
             * {@hide}
             *
             * @return true if the view belongs to the root namespace, false otherwise
             */
            IsRootNamespace(
                [out] Boolean* result);

            GetTag(
                [out] IInterface** tag);

            SetTag(
                [in] IInterface* tag);

            /**
             * Returns the tag associated with this view and the specified key.
             *
             * @param key The key identifying the tag
             *
             * @return the Object stored in this view as a tag
             *
             * @see #setTag(int, Object)
             * @see #getTag()
             */
            GetTag(
                [in] Int32 key,
                [out] IInterface** tag);

            SetTag(
                [in] Int32 key,
                [in] IInterface* tag);

            SetTagInternal(
                [in] Int32 key,
                [in] IInterface* tag);

            /**
             * <p>Return the offset of the widget's text baseline from the widget's top
             * boundary. If this widget does not support baseline alignment, this
             * method returns -1. </p>
             *
             * @return the offset of the baseline within the widget's bounds or -1
             *         if baseline alignment is not supported
             */
            GetBaseline(
                [out] Int32* result);

            /**
             * Returns whether the view hierarchy is currently undergoing a layout pass. This
             * information is useful to avoid situations such as calling {@link #requestLayout()} during
             * a layout pass.
             *
             * @return whether the view hierarchy is currently undergoing a layout pass
             */
            IsInLayout(
                [out] Boolean* result);

            /**
             * Call this when something has changed which has invalidated the
             * layout of this view. This will schedule a layout pass of the view
             * tree.
             */
            RequestLayout();

            /**
             * Forces this view to be laid out during the next layout pass.
             * This method does not call requestLayout() or forceLayout()
             * on the parent.
             */
            ForceLayout();

            /**
             * <p>
             * This is called to find out how big a view should be. The parent
             * supplies constraint information in the width and height parameters.
             * </p>
             *
             * <p>
             * The actual mesurement work of a view is performed in
             * {@link #onMeasure(int, int)}, called by this method. Therefore, only
             * {@link #onMeasure(int, int)} can and must be overriden by subclasses.
             * </p>
             *
             *
             * @param widthMeasureSpec Horizontal space requirements as imposed by the
             *        parent
             * @param heightMeasureSpec Vertical space requirements as imposed by the
             *        parent
             *
             * @see #onMeasure(int, int)
             */
            Measure(
                [in] Int32 widthMeasureSpec,
                [in] Int32 heightMeasureSpec);

            /**
             * Returns the minimum height of the view.
             *
             * @return the minimum height the view will try to be.
             *
             * @see #setMinimumHeight(int)
             *
             * @attr ref android.R.styleable#View_minHeight
             */
            GetMinimumHeight(
                [out] Int32* height);

            /**
             * Sets the minimum height of the view. It is not guaranteed the view will
             * be able to achieve this minimum height (for example, if its parent layout
             * constrains it with less available height).
             *
             * @param minHeight The minimum height the view will try to be.
             *
             * @see #getMinimumHeight()
             *
             * @attr ref android.R.styleable#View_minHeight
             */
            SetMinimumHeight(
                [in] Int32 minHeight);

            /**
             * Returns the minimum width of the view.
             *
             * @return the minimum width the view will try to be.
             *
             * @see #setMinimumWidth(int)
             *
             * @attr ref android.R.styleable#View_minWidth
             */
            GetMinimumWidth(
                [out] Int32* width);

            /**
             * Sets the minimum width of the view. It is not guaranteed the view will
             * be able to achieve this minimum width (for example, if its parent layout
             * constrains it with less available width).
             *
             * @param minWidth The minimum width the view will try to be.
             */
            SetMinimumWidth(
                [in] Int32 minWidth);

            /**
             * Get the animation currently associated with this view.
             *
             * @return The animation that is currently playing or
             *         scheduled to play for this view.
             */
            GetAnimation(
                [out] IAnimation** animation);

            /**
             * Start the specified animation now.
             *
             * @param animation the animation to start now
             */
            StartAnimation(
                [in] IAnimation* animation);

            /**
             * Cancels any animations for this view.
             */
            ClearAnimation();

            /**
             * Sets the next animation to play for this view.
             * If you want the animation to play immediately, use
             * {@link #startAnimation(android.view.animation.Animation)} instead.
             * This method provides allows fine-grained
             * control over the start time and invalidation, but you
             * must make sure that 1) the animation has a start time set, and
             * 2) the view's parent (which controls animations on its children)
             * will be invalidated when the animation is supposed to
             * start.
             *
             * @param animation The next animation, or null.
             */
            SetAnimation(
                [in] IAnimation* animation);

            /**
             * This is used by the RootView to perform an optimization when
             * the view hierarchy contains one or several SurfaceView.
             * SurfaceView is always considered transparent, but its children are not,
             * therefore all View objects remove themselves from the global transparent
             * region (passed as a parameter to this function).
             *
             * @param region The transparent region for this ViewAncestor (window).
             *
             * @return Returns true if the effective visibility of the view at this
             * point is opaque, regardless of the transparent region; returns false
             * if it is possible for underlying windows to be seen behind the view.
             *
             * {@hide}
             */
            GatherTransparentRegion(
                [in] IRegion* region,
                [out] Boolean* result);

            /**
             * Play a sound effect for this view.
             *
             * <p>The framework will play sound effects for some built in actions, such as
             * clicking, but you may wish to play these effects in your widget,
             * for instance, for internal navigation.
             *
             * <p>The sound effect will only be played if sound effects are enabled by the user, and
             * {@link #isSoundEffectsEnabled()} is true.
             *
             * @param soundConstant One of the constants defined in {@link SoundEffectConstants}
             */
            PlaySoundEffect(
                [in] Int32 soundConstant);

            /**
             * BZZZTT!!1!
             *
             * <p>Provide haptic feedback to the user for this view.
             *
             * <p>The framework will provide haptic feedback for some built in actions,
             * such as long presses, but you may wish to provide feedback for your
             * own widget.
             *
             * <p>The feedback will only be performed if
             * {@link #isHapticFeedbackEnabled()} is true.
             *
             * @param feedbackConstant One of the constants defined in
             * {@link HapticFeedbackConstants}
             */
            PerformHapticFeedback(
                [in] Int32 feedbackConstant,
                [out] Boolean* result);

            /**
             * BZZZTT!!1!
             *
             * <p>Like {@link #performHapticFeedback(int)}, with additional options.
             *
             * @param feedbackConstant One of the constants defined in
             * {@link HapticFeedbackConstants}
             * @param flags Additional flags as per {@link HapticFeedbackConstants}.
             */
            PerformHapticFeedback(
                [in] Int32 feedbackConstant,
                [in] Int32 flags,
                [out] Boolean* result);

            /**
             * Request that the visibility of the status bar or other screen/window
             * decorations be changed.
             *
             * <p>This method is used to put the over device UI into temporary modes
             * where the user's attention is focused more on the application content,
             * by dimming or hiding surrounding system affordances.  This is typically
             * used in conjunction with {@link Window#FEATURE_ACTION_BAR_OVERLAY
             * Window.FEATURE_ACTION_BAR_OVERLAY}, allowing the applications content
             * to be placed behind the action bar (and with these flags other system
             * affordances) so that smooth transitions between hiding and showing them
             * can be done.
             *
             * <p>Two representative examples of the use of system UI visibility is
             * implementing a content browsing application (like a magazine reader)
             * and a video playing application.
             *
             * <p>The first code shows a typical implementation of a View in a content
             * browsing application.  In this implementation, the application goes
             * into a content-oriented mode by hiding the status bar and action bar,
             * and putting the navigation elements into lights out mode.  The user can
             * then interact with content while in this mode.  Such an application should
             * provide an easy way for the user to toggle out of the mode (such as to
             * check information in the status bar or access notifications).  In the
             * implementation here, this is done simply by tapping on the content.
             *
             * {@sample development/samples/ApiDemos/src/com/example/android/apis/view/ContentBrowserActivity.java
             *      content}
             *
             * <p>This second code sample shows a typical implementation of a View
             * in a video playing application.  In this situation, while the video is
             * playing the application would like to go into a complete full-screen mode,
             * to use as much of the display as possible for the video.  When in this state
             * the user can not interact with the application; the system intercepts
             * touching on the screen to pop the UI out of full screen mode.  See
             * {@link #fitSystemWindows(Rect)} for a sample layout that goes with this code.
             *
             * {@sample development/samples/ApiDemos/src/com/example/android/apis/view/VideoPlayerActivity.java
             *      content}
             *
             * @param visibility  Bitwise-or of flags {@link #SYSTEM_UI_FLAG_LOW_PROFILE},
             * {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION}, {@link #SYSTEM_UI_FLAG_FULLSCREEN},
             * {@link #SYSTEM_UI_FLAG_LAYOUT_STABLE}, {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION},
             * and {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}.
             */
            SetSystemUiVisibility(
                [in] Int32 visibility);

            /**
             * Returns the last {@link #setSystemUiVisibility(int) that this view has requested.
             * @return  Bitwise-or of flags {@link #SYSTEM_UI_FLAG_LOW_PROFILE},
             * {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION}, {@link #SYSTEM_UI_FLAG_FULLSCREEN},
             * {@link #SYSTEM_UI_FLAG_LAYOUT_STABLE}, {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION},
             * and {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}.
             */
            GetSystemUiVisibility(
                [out] Int32* visibility);

            /**
             * Returns the current system UI visibility that is currently set for
             * the entire window.  This is the combination of the
             * {@link #setSystemUiVisibility(int)} values supplied by all of the
             * views in the window.
             */
            GetWindowSystemUiVisibility(
                [out] Int32* visibility);

            /**
             * Override to find out when the window's requested system UI visibility
             * has changed, that is the value returned by {@link #getWindowSystemUiVisibility()}.
             * This is different from the callbacks recieved through
             * {@link #setOnSystemUiVisibilityChangeListener(OnSystemUiVisibilityChangeListener)}
             * in that this is only telling you about the local request of the window,
             * not the actual values applied by the system.
             */
            OnWindowSystemUiVisibilityChanged(
                [in] Int32 visible);

            /**
             * Dispatch callbacks to {@link #onWindowSystemUiVisibilityChanged(int)} down
             * the view hierarchy.
             */
            DispatchWindowSystemUiVisiblityChanged(
                [in] Int32 visible);

            /**
             * Set a listener to receive callbacks when the visibility of the system bar changes.
             * @param l  The {@link OnSystemUiVisibilityChangeListener} to receive callbacks.
             */
            SetOnSystemUiVisibilityChangeListener(
                [in] IViewOnSystemUiVisibilityChangeListener* l);

            /**
             * Dispatch callbacks to {@link #setOnSystemUiVisibilityChangeListener} down
             * the view hierarchy.
             */
            DispatchSystemUiVisibilityChanged(
                [in] Int32 visibility);

            /** @hide */
            SetDisabledSystemUiVisibility(
                [in] Int32 flags);

            /**
             * Starts a drag and drop operation. When your application calls this method, it passes a
             * {@link android.view.View.DragShadowBuilder} object to the system. The
             * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
             * to get metrics for the drag shadow, and then calls the object's
             * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
             * <p>
             *  Once the system has the drag shadow, it begins the drag and drop operation by sending
             *  drag events to all the View objects in your application that are currently visible. It does
             *  this either by calling the View object's drag listener (an implementation of
             *  {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
             *  View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
             *  Both are passed a {@link android.view.DragEvent} object that has a
             *  {@link android.view.DragEvent#getAction()} value of
             *  {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
             * </p>
             * <p>
             * Your application can invoke startDrag() on any attached View object. The View object does not
             * need to be the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to
             * be related to the View the user selected for dragging.
             * </p>
             * @param data A {@link android.content.ClipData} object pointing to the data to be
             * transferred by the drag and drop operation.
             * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
             * drag shadow.
             * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
             * drop operation. This Object is put into every DragEvent object sent by the system during the
             * current drag.
             * <p>
             * myLocalState is a lightweight mechanism for the sending information from the dragged View
             * to the target Views. For example, it can contain flags that differentiate between a
             * a copy operation and a move operation.
             * </p>
             * @param flags Flags that control the drag and drop operation. No flags are currently defined,
             * so the parameter should be set to 0.
             * @return {@code true} if the method completes successfully, or
             * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
             * do a drag, and so no drag operation is in progress.
             */
            StartDrag(
                [in] IClipData* data,
                [in] IDragShadowBuilder* shadowBuilder,
                [in] IInterface* myLocalState,
                [in] Int32 flags,
                [out] Boolean* success);

            /**
             * Handles drag events sent by the system following a call to
             * {@link android.view.View#startDrag(ClipData,DragShadowBuilder,Object,int) startDrag()}.
             *<p>
             * When the system calls this method, it passes a
             * {@link android.view.DragEvent} object. A call to
             * {@link android.view.DragEvent#getAction()} returns one of the action type constants defined
             * in DragEvent. The method uses these to determine what is happening in the drag and drop
             * operation.
             * @param event The {@link android.view.DragEvent} sent by the system.
             * The {@link android.view.DragEvent#getAction()} method returns an action type constant defined
             * in DragEvent, indicating the type of drag event represented by this object.
             * @return {@code true} if the method was successful, otherwise {@code false}.
             * <p>
             *  The method should return {@code true} in response to an action type of
             *  {@link android.view.DragEvent#ACTION_DRAG_STARTED} to receive drag events for the current
             *  operation.
             * </p>
             * <p>
             *  The method should also return {@code true} in response to an action type of
             *  {@link android.view.DragEvent#ACTION_DROP} if it consumed the drop, or
             *  {@code false} if it didn't.
             * </p>
             */
            OnDragEvent(
                [in] IDragEvent* event,
                [out] Boolean* consumed);

            /**
             * Detects if this View is enabled and has a drag event listener.
             * If both are true, then it calls the drag event listener with the
             * {@link android.view.DragEvent} it received. If the drag event listener returns
             * {@code true}, then dispatchDragEvent() returns {@code true}.
             * <p>
             * For all other cases, the method calls the
             * {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} drag event handler
             * method and returns its result.
             * </p>
             * <p>
             * This ensures that a drag event is always consumed, even if the View does not have a drag
             * event listener. However, if the View has a listener and the listener returns true, then
             * onDragEvent() is not called.
             * </p>
             */
            DispatchDragEvent(
                [in] IDragEvent* event,
                [out] Boolean* consumed);

            /**
             * This needs to be a better API (NOT ON VIEW) before it is exposed.  If
             * it is ever exposed at all.
             * @hide
             */
            OnCloseSystemDialogs(
                [in] String reason);

            /**
             * Given a Drawable whose bounds have been set to draw into this view,
             * update a Region being computed for {@link #gatherTransparentRegion} so
             * that any non-transparent parts of the Drawable are removed from the
             * given transparent region.
             *
             * @param dr The Drawable whose transparency is to be applied to the region.
             * @param region A Region holding the current transparency information,
             * where any parts of the region that are set are considered to be
             * transparent.  On return, this region will be modified to have the
             * transparency information reduced by the corresponding parts of the
             * Drawable that are not transparent.
             * {@hide}
             */
            ApplyDrawableToTransparentRegion(
                [in] IDrawable* dr,
                [in] IRegion* region);

            /**
             * Returns the over-scroll mode for this view. The result will be
             * one of {@link #OVER_SCROLL_ALWAYS} (default), {@link #OVER_SCROLL_IF_CONTENT_SCROLLS}
             * (allow over-scrolling only if the view content is larger than the container),
             * or {@link #OVER_SCROLL_NEVER}.
             *
             * @return This view's over-scroll mode.
             */
            GetOverScrollMode(
                [out] Int32* mode);

            /**
             * Set the over-scroll mode for this view. Valid over-scroll modes are
             * {@link #OVER_SCROLL_ALWAYS} (default), {@link #OVER_SCROLL_IF_CONTENT_SCROLLS}
             * (allow over-scrolling only if the view content is larger than the container),
             * or {@link #OVER_SCROLL_NEVER}.
             *
             * Setting the over-scroll mode of a view will have an effect only if the
             * view is capable of scrolling.
             *
             * @param overScrollMode The new over-scroll mode for this view.
             */
            SetOverScrollMode(
                [in] Int32 overScrollMode);

            /**
             * Enable or disable nested scrolling for this view.
             *
             * <p>If this property is set to true the view will be permitted to initiate nested
             * scrolling operations with a compatible parent view in the current hierarchy. If this
             * view does not implement nested scrolling this will have no effect. Disabling nested scrolling
             * while a nested scroll is in progress has the effect of {@link #stopNestedScroll() stopping}
             * the nested scroll.</p>
             *
             * @param enabled true to enable nested scrolling, false to disable
             *
             * @see #isNestedScrollingEnabled()
             */
            SetNestedScrollingEnabled(
                [in] Boolean enabled);

            /**
             * Returns true if nested scrolling is enabled for this view.
             *
             * <p>If nested scrolling is enabled and this View class implementation supports it,
             * this view will act as a nested scrolling child view when applicable, forwarding data
             * about the scroll operation in progress to a compatible and cooperating nested scrolling
             * parent.</p>
             *
             * @return true if nested scrolling is enabled
             *
             * @see #setNestedScrollingEnabled(boolean)
             */
            IsNestedScrollingEnabled(
                [out] Boolean* enabled);

            /**
             * Begin a nestable scroll operation along the given axes.
             *
             * <p>A view starting a nested scroll promises to abide by the following contract:</p>
             *
             * <p>The view will call startNestedScroll upon initiating a scroll operation. In the case
             * of a touch scroll this corresponds to the initial {@link MotionEvent#ACTION_DOWN}.
             * In the case of touch scrolling the nested scroll will be terminated automatically in
             * the same manner as {@link ViewParent#requestDisallowInterceptTouchEvent(boolean)}.
             * In the event of programmatic scrolling the caller must explicitly call
             * {@link #stopNestedScroll()} to indicate the end of the nested scroll.</p>
             *
             * <p>If <code>startNestedScroll</code> returns true, a cooperative parent was found.
             * If it returns false the caller may ignore the rest of this contract until the next scroll.
             * Calling startNestedScroll while a nested scroll is already in progress will return true.</p>
             *
             * <p>At each incremental step of the scroll the caller should invoke
             * {@link #dispatchNestedPreScroll(int, int, int[], int[]) dispatchNestedPreScroll}
             * once it has calculated the requested scrolling delta. If it returns true the nested scrolling
             * parent at least partially consumed the scroll and the caller should adjust the amount it
             * scrolls by.</p>
             *
             * <p>After applying the remainder of the scroll delta the caller should invoke
             * {@link #dispatchNestedScroll(int, int, int, int, int[]) dispatchNestedScroll}, passing
             * both the delta consumed and the delta unconsumed. A nested scrolling parent may treat
             * these values differently. See {@link ViewParent#onNestedScroll(View, int, int, int, int)}.
             * </p>
             *
             * @param axes Flags consisting of a combination of {@link #SCROLL_AXIS_HORIZONTAL} and/or
             *             {@link #SCROLL_AXIS_VERTICAL}.
             * @return true if a cooperative parent was found and nested scrolling has been enabled for
             *         the current gesture.
             *
             * @see #stopNestedScroll()
             * @see #dispatchNestedPreScroll(int, int, int[], int[])
             * @see #dispatchNestedScroll(int, int, int, int, int[])
             */
            StartNestedScroll(
                [in] Int32 axes,
                [out] Boolean* result);

            /**
             * Stop a nested scroll in progress.
             *
             * <p>Calling this method when a nested scroll is not currently in progress is harmless.</p>
             *
             * @see #startNestedScroll(int)
             */
            StopNestedScroll();

            /**
             * Returns true if this view has a nested scrolling parent.
             *
             * <p>The presence of a nested scrolling parent indicates that this view has initiated
             * a nested scroll and it was accepted by an ancestor view further up the view hierarchy.</p>
             *
             * @return whether this view has a nested scrolling parent
             */
            HasNestedScrollingParent(
                [out] Boolean* result);

            /**
             * Dispatch one step of a nested scroll in progress.
             *
             * <p>Implementations of views that support nested scrolling should call this to report
             * info about a scroll in progress to the current nested scrolling parent. If a nested scroll
             * is not currently in progress or nested scrolling is not
             * {@link #isNestedScrollingEnabled() enabled} for this view this method does nothing.</p>
             *
             * <p>Compatible View implementations should also call
             * {@link #dispatchNestedPreScroll(int, int, int[], int[]) dispatchNestedPreScroll} before
             * consuming a component of the scroll event themselves.</p>
             *
             * @param dxConsumed Horizontal distance in pixels consumed by this view during this scroll step
             * @param dyConsumed Vertical distance in pixels consumed by this view during this scroll step
             * @param dxUnconsumed Horizontal scroll distance in pixels not consumed by this view
             * @param dyUnconsumed Horizontal scroll distance in pixels not consumed by this view
             * @param offsetInWindow Optional. If not null, on return this will contain the offset
             *                       in local view coordinates of this view from before this operation
             *                       to after it completes. View implementations may use this to adjust
             *                       expected input coordinate tracking.
             * @return true if the event was dispatched, false if it could not be dispatched.
             * @see #dispatchNestedPreScroll(int, int, int[], int[])
             */
            DispatchNestedScroll(
                [in] Int32 dxConsumed,
                [in] Int32 dyConsumed,
                [in] Int32 dxUnconsumed,
                [in] Int32 dyUnconsumed,
                [in] ArrayOf<Int32>* offsetInWindow,
                [out] Boolean* result);

            /**
             * Dispatch one step of a nested scroll in progress before this view consumes any portion of it.
             *
             * <p>Nested pre-scroll events are to nested scroll events what touch intercept is to touch.
             * <code>dispatchNestedPreScroll</code> offers an opportunity for the parent view in a nested
             * scrolling operation to consume some or all of the scroll operation before the child view
             * consumes it.</p>
             *
             * @param dx Horizontal scroll distance in pixels
             * @param dy Vertical scroll distance in pixels
             * @param consumed Output. If not null, consumed[0] will contain the consumed component of dx
             *                 and consumed[1] the consumed dy.
             * @param offsetInWindow Optional. If not null, on return this will contain the offset
             *                       in local view coordinates of this view from before this operation
             *                       to after it completes. View implementations may use this to adjust
             *                       expected input coordinate tracking.
             * @return true if the parent consumed some or all of the scroll delta
             * @see #dispatchNestedScroll(int, int, int, int, int[])
             */
            DispatchNestedPreScroll(
                [in] Int32 dx,
                [in] Int32 dy,
                [in] ArrayOf<Int32>* consumed,
                [in] ArrayOf<Int32>* offsetInWindow,
                [out] Boolean* result);

            /**
             * Dispatch a fling to a nested scrolling parent.
             *
             * <p>This method should be used to indicate that a nested scrolling child has detected
             * suitable conditions for a fling. Generally this means that a touch scroll has ended with a
             * {@link VelocityTracker velocity} in the direction of scrolling that meets or exceeds
             * the {@link ViewConfiguration#getScaledMinimumFlingVelocity() minimum fling velocity}
             * along a scrollable axis.</p>
             *
             * <p>If a nested scrolling child view would normally fling but it is at the edge of
             * its own content, it can use this method to delegate the fling to its nested scrolling
             * parent instead. The parent may optionally consume the fling or observe a child fling.</p>
             *
             * @param velocityX Horizontal fling velocity in pixels per second
             * @param velocityY Vertical fling velocity in pixels per second
             * @param consumed true if the child consumed the fling, false otherwise
             * @return true if the nested scrolling parent consumed or otherwise reacted to the fling
             */
            DispatchNestedFling(
                [in] Float velocityX,
                [in] Float velocityY,
                [in] Boolean consumed,
                [out] Boolean* result);

            /**
             * Dispatch a fling to a nested scrolling parent before it is processed by this view.
             *
             * <p>Nested pre-fling events are to nested fling events what touch intercept is to touch
             * and what nested pre-scroll is to nested scroll. <code>dispatchNestedPreFling</code>
             * offsets an opportunity for the parent view in a nested fling to fully consume the fling
             * before the child view consumes it. If this method returns <code>true</code>, a nested
             * parent view consumed the fling and this view should not scroll as a result.</p>
             *
             * <p>For a better user experience, only one view in a nested scrolling chain should consume
             * the fling at a time. If a parent view consumed the fling this method will return false.
             * Custom view implementations should account for this in two ways:</p>
             *
             * <ul>
             *     <li>If a custom view is paged and needs to settle to a fixed page-point, do not
             *     call <code>dispatchNestedPreFling</code>; consume the fling and settle to a valid
             *     position regardless.</li>
             *     <li>If a nested parent does consume the fling, this view should not scroll at all,
             *     even to settle back to a valid idle position.</li>
             * </ul>
             *
             * <p>Views should also not offer fling velocities to nested parent views along an axis
             * where scrolling is not currently supported; a {@link android.widget.ScrollView ScrollView}
             * should not offer a horizontal fling velocity to its parents since scrolling along that
             * axis is not permitted and carrying velocity along that motion does not make sense.</p>
             *
             * @param velocityX Horizontal fling velocity in pixels per second
             * @param velocityY Vertical fling velocity in pixels per second
             * @return true if a nested scrolling parent consumed the fling
             */
            DispatchNestedPreFling(
                [in] Float velocityX,
                [in] Float velocityY,
                [out] Boolean* result);

            /**
             * Return the value specifying the text direction or policy that was set with
             * {@link #setTextDirection(int)}.
             *
             * @return the defined text direction. It can be one of:
             *
             * {@link #TEXT_DIRECTION_INHERIT},
             * {@link #TEXT_DIRECTION_FIRST_STRONG}
             * {@link #TEXT_DIRECTION_ANY_RTL},
             * {@link #TEXT_DIRECTION_LTR},
             * {@link #TEXT_DIRECTION_RTL},
             * {@link #TEXT_DIRECTION_LOCALE}
             *
             * @hide
             */
            // @ViewDebug.ExportedProperty(category = "text", mapping = {
            //         @ViewDebug.IntToString(from = TEXT_DIRECTION_INHERIT, to = "INHERIT"),
            //         @ViewDebug.IntToString(from = TEXT_DIRECTION_FIRST_STRONG, to = "FIRST_STRONG"),
            //         @ViewDebug.IntToString(from = TEXT_DIRECTION_ANY_RTL, to = "ANY_RTL"),
            //         @ViewDebug.IntToString(from = TEXT_DIRECTION_LTR, to = "LTR"),
            //         @ViewDebug.IntToString(from = TEXT_DIRECTION_RTL, to = "RTL"),
            //         @ViewDebug.IntToString(from = TEXT_DIRECTION_LOCALE, to = "LOCALE")
            // })
            GetRawTextDirection(
                [out] Int32* direction);

            /**
             * Set the text direction.
             *
             * @param textDirection the direction to set. Should be one of:
             *
             * {@link #TEXT_DIRECTION_INHERIT},
             * {@link #TEXT_DIRECTION_FIRST_STRONG}
             * {@link #TEXT_DIRECTION_ANY_RTL},
             * {@link #TEXT_DIRECTION_LTR},
             * {@link #TEXT_DIRECTION_RTL},
             * {@link #TEXT_DIRECTION_LOCALE}
             *
             * Resolution will be done if the value is set to TEXT_DIRECTION_INHERIT. The resolution
             * proceeds up the parent chain of the view to get the value. If there is no parent, then it will
             * return the default {@link #TEXT_DIRECTION_FIRST_STRONG}.
             */
            SetTextDirection(
                [in] Int32 textDirection);

            /**
             * Return the resolved text direction.
             *
             * @return the resolved text direction. Returns one of:
             *
             * {@link #TEXT_DIRECTION_FIRST_STRONG}
             * {@link #TEXT_DIRECTION_ANY_RTL},
             * {@link #TEXT_DIRECTION_LTR},
             * {@link #TEXT_DIRECTION_RTL},
             * {@link #TEXT_DIRECTION_LOCALE}
             */
            GetTextDirection(
                [out] Int32* direction);

            /**
             * Resolve the text direction.
             *
             * @return true if resolution has been done, false otherwise.
             *
             * @hide
             */
            ResolveTextDirection(
                [out] Boolean* done);

            /**
             * Check if text direction resolution can be done.
             *
             * @return true if text direction resolution can be done otherwise return false.
             */
            CanResolveTextDirection(
                [out] Boolean* result);

            /**
             * Reset resolved text direction. Text direction will be resolved during a call to
             * {@link #onMeasure(int, int)}.
             *
             * @hide
             */
            ResetResolvedTextDirection();

            /**
             * @return true if text direction is inherited.
             *
             * @hide
             */
            IsTextDirectionInherited(
                [out] Boolean* inherited);

            /**
             * @return true if text direction is resolved.
             */
            IsTextDirectionResolved(
                [out] Boolean* inherited);

            /**
             * Return the value specifying the text alignment or policy that was set with
             * {@link #setTextAlignment(int)}.
             *
             * @return the defined text alignment. It can be one of:
             *
             * {@link #TEXT_ALIGNMENT_INHERIT},
             * {@link #TEXT_ALIGNMENT_GRAVITY},
             * {@link #TEXT_ALIGNMENT_CENTER},
             * {@link #TEXT_ALIGNMENT_TEXT_START},
             * {@link #TEXT_ALIGNMENT_TEXT_END},
             * {@link #TEXT_ALIGNMENT_VIEW_START},
             * {@link #TEXT_ALIGNMENT_VIEW_END}
             *
             * @hide
             */
            // @ViewDebug.ExportedProperty(category = "text", mapping = {
            //         @ViewDebug.IntToString(from = TEXT_ALIGNMENT_INHERIT, to = "INHERIT"),
            //         @ViewDebug.IntToString(from = TEXT_ALIGNMENT_GRAVITY, to = "GRAVITY"),
            //         @ViewDebug.IntToString(from = TEXT_ALIGNMENT_TEXT_START, to = "TEXT_START"),
            //         @ViewDebug.IntToString(from = TEXT_ALIGNMENT_TEXT_END, to = "TEXT_END"),
            //         @ViewDebug.IntToString(from = TEXT_ALIGNMENT_CENTER, to = "CENTER"),
            //         @ViewDebug.IntToString(from = TEXT_ALIGNMENT_VIEW_START, to = "VIEW_START"),
            //         @ViewDebug.IntToString(from = TEXT_ALIGNMENT_VIEW_END, to = "VIEW_END")
            // })
            GetRawTextAlignment(
                [out] Int32* alignment);

            /**
             * Set the text alignment.
             *
             * @param textAlignment The text alignment to set. Should be one of
             *
             * {@link #TEXT_ALIGNMENT_INHERIT},
             * {@link #TEXT_ALIGNMENT_GRAVITY},
             * {@link #TEXT_ALIGNMENT_CENTER},
             * {@link #TEXT_ALIGNMENT_TEXT_START},
             * {@link #TEXT_ALIGNMENT_TEXT_END},
             * {@link #TEXT_ALIGNMENT_VIEW_START},
             * {@link #TEXT_ALIGNMENT_VIEW_END}
             *
             * Resolution will be done if the value is set to TEXT_ALIGNMENT_INHERIT. The resolution
             * proceeds up the parent chain of the view to get the value. If there is no parent, then it
             * will return the default {@link #TEXT_ALIGNMENT_GRAVITY}.
             *
             * @attr ref android.R.styleable#View_textAlignment
             */
            SetTextAlignment(
                [in] Int32 textAlignment);

            /**
             * Return the resolved text alignment.
             *
             * @return the resolved text alignment. Returns one of:
             *
             * {@link #TEXT_ALIGNMENT_GRAVITY},
             * {@link #TEXT_ALIGNMENT_CENTER},
             * {@link #TEXT_ALIGNMENT_TEXT_START},
             * {@link #TEXT_ALIGNMENT_TEXT_END},
             * {@link #TEXT_ALIGNMENT_VIEW_START},
             * {@link #TEXT_ALIGNMENT_VIEW_END}
             */
            // @ViewDebug.ExportedProperty(category = "text", mapping = {
            //         @ViewDebug.IntToString(from = TEXT_ALIGNMENT_INHERIT, to = "INHERIT"),
            //         @ViewDebug.IntToString(from = TEXT_ALIGNMENT_GRAVITY, to = "GRAVITY"),
            //         @ViewDebug.IntToString(from = TEXT_ALIGNMENT_TEXT_START, to = "TEXT_START"),
            //         @ViewDebug.IntToString(from = TEXT_ALIGNMENT_TEXT_END, to = "TEXT_END"),
            //         @ViewDebug.IntToString(from = TEXT_ALIGNMENT_CENTER, to = "CENTER"),
            //         @ViewDebug.IntToString(from = TEXT_ALIGNMENT_VIEW_START, to = "VIEW_START"),
            //         @ViewDebug.IntToString(from = TEXT_ALIGNMENT_VIEW_END, to = "VIEW_END")
            // })
            GetTextAlignment(
                [out] Int32* alignment);

            /**
             * Resolve the text alignment.
             *
             * @return true if resolution has been done, false otherwise.
             *
             * @hide
             */
            ResolveTextAlignment(
                [out] Boolean* done);

            /**
             * Check if text alignment resolution can be done.
             *
             * @return true if text alignment resolution can be done otherwise return false.
             */
            CanResolveTextAlignment(
                [out] Boolean* inherited);

            /**
             * Reset resolved text alignment. Text alignment will be resolved during a call to
             * {@link #onMeasure(int, int)}.
             *
             * @hide
             */
            ResetResolvedTextAlignment();

            /**
             * @return true if text alignment is inherited.
             *
             * @hide
             */
            IsTextAlignmentInherited(
                [out] Boolean* inherited);

            /**
             * @return true if text alignment is resolved.
             */
            IsTextAlignmentResolved(
                [out] Boolean* inherited);

            /**
             * Gets the Views in the hierarchy affected by entering and exiting Activity Scene transitions.
             * @param transitioningViews This View will be added to transitioningViews if it is VISIBLE and
             *                           a normal View or a ViewGroup with
             *                           {@link android.view.ViewGroup#isTransitionGroup()} true.
             * @hide
             */
            CaptureTransitioningViews(
                [in] IList* transitioningViews);

            /**
             * Adds all Views that have {@link #getTransitionName()} non-null to namedElements.
             * @param namedElements Will contain all Views in the hierarchy having a transitionName.
             * @hide
             */
            FindNamedViews(
                [in] IMap* namedElements);


            /** @hide */
            HackTurnOffWindowResizeAnim(
                [in] Boolean off);

            /**
             * This method returns a ViewPropertyAnimator object, which can be used to animate
             * specific properties on this View.
             *
             * @return ViewPropertyAnimator The ViewPropertyAnimator associated with this View.
             */
            Animate(
                [out] IViewPropertyAnimator** animator);

            /**
             * Sets the name of the View to be used to identify Views in Transitions.
             * Names should be unique in the View hierarchy.
             *
             * @param transitionName The name of the View to uniquely identify it for Transitions.
             */
            SetTransitionName(
                [in] String transitionName);

            /**
             * Returns the name of the View to be used to identify Views in Transitions.
             * Names should be unique in the View hierarchy.
             *
             * <p>This returns null if the View has not been given a name.</p>
             *
             * @return The name used of the View to be used to identify Views in Transitions or null
             * if no name has been given.
             */
            GetTransitionName(
                [out] String* transitionName);

            DamageInParent();
        }

        [local]
        interface IViewHelper {

            IsLayoutModeOptical(
                [in] IInterface* it,
                [out] Boolean* res);

            CombineMeasuredStates(
                [in] Int32 curState,
                [in] Int32 newState,
                [out] Int32* res);

            ResolveSize(
                [in] Int32 size,
                [in] Int32 measureSpec,
                [out] Int32* res);

            ResolveSizeAndState(
                [in] Int32 size,
                [in] Int32 measureSpec,
                [in] Int32 childMeasuredState,
                [out] Int32* res);

            GetDefaultSize(
                [in] Int32 size,
                [in] Int32 measureSpec,
                [out] Int32* res);

            Inflate(
                [in] IContext* ctx,
                [in] Int32 resource,
                [in] IViewGroup* root,
                [out] IView** res);

            GenerateViewId(
                [out] Int32* res);
        }

    } // namespace View
    } // namepsace Droid
    } // namespace Elastos
}
