module
{
    using interface Elastos.Net.IProxy;
    using interface Elastos.Utility.IList;
    using interface Elastos.Security.IPrivateKey;
    using interface Elastos.Security.ICertificate;

    interface Elastos.Droid.Os.IRemoteCallback;
    interface Elastos.Droid.Os.IHandler;
    interface Elastos.Droid.Os.IBundle;
    interface Elastos.Droid.Os.IUserHandle;
    interface Elastos.Droid.Net.IProxyInfo;
    interface Elastos.Droid.Content.IComponentName;
    interface Elastos.Droid.Content.IIntent;
    interface Elastos.Droid.Content.IContext;
    interface Elastos.Droid.Content.IIntentFilter;

    namespace Elastos {
    namespace Droid {
    namespace App {
    namespace Admin {

    /**
     * Public interface for managing policies enforced on a device.  Most clients
     * of this class must have published a {@sa DeviceAdminReceiver} that the user
     * has currently enabled.
     *
     * <div class="special reference">
     * <h3>Developer Guides</h3>
     * <p>For more information about managing policies for device adminstration, read the
     * <a href="{@docRoot}guide/topics/admin/device-admin.html">Device Administration</a>
     * developer guide.</p>
     * </div>
     */
    [deprecated]
    interface IDevicePolicyManager {

        /**
         * Activity action: Starts the provisioning flow which sets up a managed profile.
         *
         * <p>A managed profile allows data separation for example for the usage of a
         * device as a personal and corporate device. The user which provisioning is started from and
         * the managed profile share a launcher.
         *
         * <p>This intent will typically be sent by a mobile device management application (mdm).
         * Provisioning adds a managed profile and sets the mdm as the profile owner who has full
         * control over the profile
         *
         * <p>This intent must contain the extra {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME}.
         *
         * <p> When managed provisioning has completed, an intent of the type
         * {@link DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE} is broadcasted to the
         * managed profile.
         *
         * <p> If provisioning fails, the managedProfile is removed so the device returns to its
         * previous state.
         *
         * <p>Input: Nothing.</p>
         * <p>Output: Nothing</p>
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_PROVISION_MANAGED_PROFILE
            = "android.app.action.PROVISION_MANAGED_PROFILE";

        /**
         * A {@link android.os.Parcelable} extra of type {@link android.os.PersistableBundle} that allows
         * a mobile device management application that starts managed profile provisioning to pass data
         * to itself on the managed profile when provisioning completes. The mobile device management
         * application sends this extra in an intent with the action
         * {@link #ACTION_PROVISION_MANAGED_PROFILE} and receives it in
         * {@link DeviceAdminReceiver#onProfileProvisioningComplete} via an intent with the action
         * {@link DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE}. The bundle is not changed
         * during the managed profile provisioning.
         */
        const String EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE =
                "android.app.extra.PROVISIONING_ADMIN_EXTRAS_BUNDLE";

        /**
         * A String extra holding the package name of the mobile device management application that
         * will be set as the profile owner or device owner.
         *
         * <p>If an application starts provisioning directly via an intent with action
         * {@link #ACTION_PROVISION_MANAGED_PROFILE} this package has to match the package name of the
         * application that started provisioning. The package will be set as profile owner in that case.
         *
         * <p>This package is set as device owner when device owner provisioning is started by an Nfc
         * message containing an Nfc record with MIME type {@link #MIME_TYPE_PROVISIONING_NFC}.
         */
        const String EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME
            = "android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME";

        /**
         * A String extra that, holds the email address of the account which a managed profile is
         * created for. Used with {@link #ACTION_PROVISION_MANAGED_PROFILE} and
         * {@link DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE}.
         *
         * <p> This extra is part of the {@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}.
         *
         * <p> If the {@link #ACTION_PROVISION_MANAGED_PROFILE} intent that starts managed provisioning
         * contains this extra, it is forwarded in the
         * {@link DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE} intent to the mobile
         * device management application that was set as the profile owner during provisioning.
         * It is usually used to avoid that the user has to enter their email address twice.
         */
        const String EXTRA_PROVISIONING_EMAIL_ADDRESS
            = "android.app.extra.PROVISIONING_EMAIL_ADDRESS";

        /**
         * A String extra holding the time zone {@link android.app.AlarmManager} that the device
         * will be set to.
         *
         * <p>Use in an Nfc record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
         * provisioning via an Nfc bump.
         */
        const String EXTRA_PROVISIONING_TIME_ZONE
            = "android.app.extra.PROVISIONING_TIME_ZONE";

        /**
         * A Long extra holding the wall clock time (in milliseconds) to be set on the device's
         * {@link android.app.AlarmManager}.
         *
         * <p>Use in an Nfc record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
         * provisioning via an Nfc bump.
         */
        const String EXTRA_PROVISIONING_LOCAL_TIME
            = "android.app.extra.PROVISIONING_LOCAL_TIME";

        /**
         * A String extra holding the {@link java.util.Locale} that the device will be set to.
         * Format: xx_yy, where xx is the language code, and yy the country code.
         *
         * <p>Use in an Nfc record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
         * provisioning via an Nfc bump.
         */
        const String EXTRA_PROVISIONING_LOCALE
            = "android.app.extra.PROVISIONING_LOCALE";

        /**
         * A String extra holding the ssid of the wifi network that should be used during nfc device
         * owner provisioning for downloading the mobile device management application.
         *
         * <p>Use in an Nfc record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
         * provisioning via an Nfc bump.
         */
        const String EXTRA_PROVISIONING_WIFI_SSID
            = "android.app.extra.PROVISIONING_WIFI_SSID";

        /**
         * A boolean extra indicating whether the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}
         * is hidden or not.
         *
         * <p>Use in an Nfc record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
         * provisioning via an Nfc bump.
         */
        const String EXTRA_PROVISIONING_WIFI_HIDDEN
            = "android.app.extra.PROVISIONING_WIFI_HIDDEN";

        /**
         * A String extra indicating the security type of the wifi network in
         * {@link #EXTRA_PROVISIONING_WIFI_SSID}.
         *
         * <p>Use in an Nfc record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
         * provisioning via an Nfc bump.
         */
        const String EXTRA_PROVISIONING_WIFI_SECURITY_TYPE
            = "android.app.extra.PROVISIONING_WIFI_SECURITY_TYPE";

        /**
         * A String extra holding the password of the wifi network in
         * {@link #EXTRA_PROVISIONING_WIFI_SSID}.
         *
         * <p>Use in an Nfc record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
         * provisioning via an Nfc bump.
         */
        const String EXTRA_PROVISIONING_WIFI_PASSWORD
            = "android.app.extra.PROVISIONING_WIFI_PASSWORD";

        /**
         * A String extra holding the proxy host for the wifi network in
         * {@link #EXTRA_PROVISIONING_WIFI_SSID}.
         *
         * <p>Use in an Nfc record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
         * provisioning via an Nfc bump.
         */
        const String EXTRA_PROVISIONING_WIFI_PROXY_HOST
            = "android.app.extra.PROVISIONING_WIFI_PROXY_HOST";

        /**
         * An int extra holding the proxy port for the wifi network in
         * {@link #EXTRA_PROVISIONING_WIFI_SSID}.
         *
         * <p>Use in an Nfc record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
         * provisioning via an Nfc bump.
         */
        const String EXTRA_PROVISIONING_WIFI_PROXY_PORT
            = "android.app.extra.PROVISIONING_WIFI_PROXY_PORT";

        /**
         * A String extra holding the proxy bypass for the wifi network in
         * {@link #EXTRA_PROVISIONING_WIFI_SSID}.
         *
         * <p>Use in an Nfc record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
         * provisioning via an Nfc bump.
         */
        const String EXTRA_PROVISIONING_WIFI_PROXY_BYPASS
            = "android.app.extra.PROVISIONING_WIFI_PROXY_BYPASS";

        /**
         * A String extra holding the proxy auto-config (PAC) URL for the wifi network in
         * {@link #EXTRA_PROVISIONING_WIFI_SSID}.
         *
         * <p>Use in an Nfc record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
         * provisioning via an Nfc bump.
         */
        const String EXTRA_PROVISIONING_WIFI_PAC_URL
            = "android.app.extra.PROVISIONING_WIFI_PAC_URL";

        /**
         * A String extra holding a url that specifies the download location of the device admin
         * package. When not provided it is assumed that the device admin package is already installed.
         *
         * <p>Use in an Nfc record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
         * provisioning via an Nfc bump.
         */
        const String EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION
            = "android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION";

        /**
         * A String extra holding a http cookie header which should be used in the http request to the
         * url specified in {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}.
         *
         * <p>Use in an Nfc record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
         * provisioning via an Nfc bump.
         */
        const String EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER
            = "android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER";

        /**
         * A String extra holding the SHA-1 checksum of the file at download location specified in
         * {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}. If this doesn't match
         * the file at the download location an error will be shown to the user and the user will be
         * asked to factory reset the device.
         *
         * <p>Use in an Nfc record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
         * provisioning via an Nfc bump.
         */
        const String EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM
            = "android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM";

        /**
         * This MIME type is used for starting the Device Owner provisioning.
         *
         * <p>During device owner provisioning a device admin app is set as the owner of the device.
         * A device owner has full control over the device. The device owner can not be modified by the
         * user and the only way of resetting the device is if the device owner app calls a factory
         * reset.
         *
         * <p> A typical use case would be a device that is owned by a company, but used by either an
         * employee or client.
         *
         * <p> The Nfc message should be send to an unprovisioned device.
         *
         * <p>The Nfc record must contain a serialized {@link java.util.Properties} object which
         * contains the following properties:
         * <ul>
         * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME}</li>
         * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}</li>
         * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER}, optional</li>
         * <li>{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM}</li>
         * <li>{@link #EXTRA_PROVISIONING_LOCAL_TIME} (convert to String), optional</li>
         * <li>{@link #EXTRA_PROVISIONING_TIME_ZONE}, optional</li>
         * <li>{@link #EXTRA_PROVISIONING_LOCALE}, optional</li>
         * <li>{@link #EXTRA_PROVISIONING_WIFI_SSID}, optional</li>
         * <li>{@link #EXTRA_PROVISIONING_WIFI_HIDDEN} (convert to String), optional</li>
         * <li>{@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE}, optional</li>
         * <li>{@link #EXTRA_PROVISIONING_WIFI_PASSWORD}, optional</li>
         * <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_HOST}, optional</li>
         * <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_PORT} (convert to String), optional</li>
         * <li>{@link #EXTRA_PROVISIONING_WIFI_PROXY_BYPASS}, optional</li>
         * <li>{@link #EXTRA_PROVISIONING_WIFI_PAC_URL}, optional</li></ul>
         *
         * <p> When device owner provisioning has completed, an intent of the type
         * {@link DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE} is broadcasted to the
         * device owner.
         *
         * <p>
         * If provisioning fails, the device is factory reset.
         *
         * <p>Input: Nothing.</p>
         * <p>Output: Nothing</p>
         */
        const String MIME_TYPE_PROVISIONING_NFC
            = "application/com.android.managedprovisioning";

        /**
         * Activity action: ask the user to add a new device administrator to the system.
         * The desired policy is the ComponentName of the policy in the
         * {@link #EXTRA_DEVICE_ADMIN} extra field.  This will invoke a UI to
         * bring the user through adding the device administrator to the system (or
         * allowing them to reject it).
         *
         * <p>You can optionally include the {@link #EXTRA_ADD_EXPLANATION}
         * field to provide the user with additional explanation (in addition
         * to your component's description) about what is being added.
         *
         * <p>If your administrator is already active, this will ordinarily return immediately (without
         * user intervention).  However, if your administrator has been updated and is requesting
         * additional uses-policy flags, the user will be presented with the new list.  New policies
         * will not be available to the updated administrator until the user has accepted the new list.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_ADD_DEVICE_ADMIN
                = "android.app.action.ADD_DEVICE_ADMIN";

        /**
         * @hide
         * Activity action: ask the user to add a new device administrator as the profile owner
         * for this user. Only system privileged apps that have MANAGE_USERS and MANAGE_DEVICE_ADMINS
         * permission can call this API.
         *
         * <p>The ComponentName of the profile owner admin is pass in {@link #EXTRA_DEVICE_ADMIN} extra
         * field. This will invoke a UI to bring the user through adding the profile owner admin
         * to remotely control restrictions on the user.
         *
         * <p>The intent must be invoked via {@link Activity#startActivityForResult()} to receive the
         * result of whether or not the user approved the action. If approved, the result will
         * be {@link Activity#RESULT_OK} and the component will be set as an active admin as well
         * as a profile owner.
         *
         * <p>You can optionally include the {@link #EXTRA_ADD_EXPLANATION}
         * field to provide the user with additional explanation (in addition
         * to your component's description) about what is being added.
         *
         * <p>If there is already a profile owner active or the caller doesn't have the required
         * permissions, the operation will return a failure result.
         */
        //@SystemApi
        const String ACTION_SET_PROFILE_OWNER
                = "android.app.action.SET_PROFILE_OWNER";

        /**
         * @hide
         * Name of the profile owner admin that controls the user.
         */
        //@SystemApi
        const String EXTRA_PROFILE_OWNER_NAME
                = "android.app.extra.PROFILE_OWNER_NAME";

        /**
         * Activity action: send when any policy admin changes a policy.
         * This is generally used to find out when a new policy is in effect.
         *
         * @hide
         */
        const String ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED
                = "android.app.action.DEVICE_POLICY_MANAGER_STATE_CHANGED";

        /**
         * The ComponentName of the administrator component.
         *
         * @see #ACTION_ADD_DEVICE_ADMIN
         */
        const String EXTRA_DEVICE_ADMIN = "android.app.extra.DEVICE_ADMIN";

        /**
         * An optional CharSequence providing additional explanation for why the
         * admin is being added.
         *
         * @see #ACTION_ADD_DEVICE_ADMIN
         */
        const String EXTRA_ADD_EXPLANATION = "android.app.extra.ADD_EXPLANATION";

        /**
         * Activity action: have the user enter a new password. This activity should
         * be launched after using {@link #setPasswordQuality(ComponentName, int)},
         * or {@link #setPasswordMinimumLength(ComponentName, int)} to have the user
         * enter a new password that meets the current requirements. You can use
         * {@link #isActivePasswordSufficient()} to determine whether you need to
         * have the user select a new password in order to meet the current
         * constraints. Upon being resumed from this activity, you can check the new
         * password characteristics to see if they are sufficient.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_SET_NEW_PASSWORD
                = "android.app.action.SET_NEW_PASSWORD";

        /**
         * Flag used by {@link #addCrossProfileIntentFilter} to allow access
         * <em>from</em> a managed profile <em>to</em> its parent. That is, any
         * matching activities in the parent profile are included in the
         * disambiguation list shown when an app in the managed profile calls
         * {@link Activity#startActivity(Intent)}.
         */
        const Int32 FLAG_PARENT_CAN_ACCESS_MANAGED = 0x0001;

        /**
         * Flag used by {@link #addCrossProfileIntentFilter} to allow access
         * <em>from</em> a parent <em>to</em> its managed profile. That is, any
         * matching activities in the managed profile are included in the
         * disambiguation list shown when an app in the parent profile calls
         * {@link Activity#startActivity(Intent)}.
         */
        const Int32 FLAG_MANAGED_CAN_ACCESS_PARENT = 0x0002;

        /**
         * Constant for {@link #setPasswordQuality}: the policy has no requirements
         * for the password.  Note that quality constants are ordered so that higher
         * values are more restrictive.
         */
        const Int32 PASSWORD_QUALITY_UNSPECIFIED = 0;

        /**
         * Constant for {@link #setPasswordQuality}: the policy allows for low-security biometric
         * recognition technology.  This implies technologies that can recognize the identity of
         * an individual to about a 3 digit PIN (false detection is less than 1 in 1,000).
         * Note that quality constants are ordered so that higher values are more restrictive.
         */
        const Int32 PASSWORD_QUALITY_BIOMETRIC_WEAK = 0x8000;

        /**
         * Constant for {@link #setPasswordQuality}: the policy requires some kind
         * of password, but doesn't care what it is.  Note that quality constants
         * are ordered so that higher values are more restrictive.
         */
        const Int32 PASSWORD_QUALITY_SOMETHING = 0x10000;

        /**
         * Constant for {@link #setPasswordQuality}: the user must have entered a
         * password containing at least numeric characters.  Note that quality
         * constants are ordered so that higher values are more restrictive.
         */
        const Int32 PASSWORD_QUALITY_NUMERIC = 0x20000;

        /**
         * Constant for {@link #setPasswordQuality}: the user must have entered a
         * password containing at least numeric characters with no repeating (4444)
         * or ordered (1234, 4321, 2468) sequences.  Note that quality
         * constants are ordered so that higher values are more restrictive.
         */
        const Int32 PASSWORD_QUALITY_NUMERIC_COMPLEX = 0x30000;

        /**
         * Constant for {@link #setPasswordQuality}: the user must have entered a
         * password containing at least alphabetic (or other symbol) characters.
         * Note that quality constants are ordered so that higher values are more
         * restrictive.
         */
        const Int32 PASSWORD_QUALITY_ALPHABETIC = 0x40000;

        /**
         * Constant for {@link #setPasswordQuality}: the user must have entered a
         * password containing at least <em>both></em> numeric <em>and</em>
         * alphabetic (or other symbol) characters.  Note that quality constants are
         * ordered so that higher values are more restrictive.
         */
        const Int32 PASSWORD_QUALITY_ALPHANUMERIC = 0x50000;

        /**
         * Constant for {@link #setPasswordQuality}: the user must have entered a
         * password containing at least a letter, a numerical digit and a special
         * symbol, by default. With this password quality, passwords can be
         * restricted to contain various sets of characters, like at least an
         * uppercase letter, etc. These are specified using various methods,
         * like {@link #setPasswordMinimumLowerCase(ComponentName, int)}. Note
         * that quality constants are ordered so that higher values are more
         * restrictive.
         */
        const Int32 PASSWORD_QUALITY_COMPLEX = 0x60000;

        /**
         * Flag for {@link #resetPassword}: don't allow other admins to change
         * the password again until the user has entered it.
         */
        const Int32 RESET_PASSWORD_REQUIRE_ENTRY = 0x0001;

        /**
         * Flag for {@link #wipeData(int)}: also erase the device's external
         * storage.
         */
        const Int32 WIPE_EXTERNAL_STORAGE = 0x0001;

        /**
         * Result code for {@link #setStorageEncryption} and {@link #getStorageEncryptionStatus}:
         * indicating that encryption is not supported.
         */
        const Int32 ENCRYPTION_STATUS_UNSUPPORTED = 0;

        /**
         * Result code for {@link #setStorageEncryption} and {@link #getStorageEncryptionStatus}:
         * indicating that encryption is supported, but is not currently active.
         */
        const Int32 ENCRYPTION_STATUS_INACTIVE = 1;

        /**
         * Result code for {@link #setStorageEncryption} and {@link #getStorageEncryptionStatus}:
         * indicating that encryption is not currently active, but is currently
         * being activated.  This is only reported by devices that support
         * encryption of data and only when the storage is currently
         * undergoing a process of becoming encrypted.  A device that must reboot and/or wipe data
         * to become encrypted will never return this value.
         */
        const Int32 ENCRYPTION_STATUS_ACTIVATING = 2;

        /**
         * Result code for {@link #setStorageEncryption} and {@link #getStorageEncryptionStatus}:
         * indicating that encryption is active.
         */
        const Int32 ENCRYPTION_STATUS_ACTIVE = 3;

        /**
         * Activity action: begin the process of encrypting data on the device.  This activity should
         * be launched after using {@link #setStorageEncryption} to request encryption be activated.
         * After resuming from this activity, use {@link #getStorageEncryption}
         * to check encryption status.  However, on some devices this activity may never return, as
         * it may trigger a reboot and in some cases a complete data wipe of the device.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_START_ENCRYPTION
                = "android.app.action.START_ENCRYPTION";

        /**
         * Widgets are enabled in keyguard
         */
        const Int32 KEYGUARD_DISABLE_FEATURES_NONE = 0;

        /**
         * Disable all keyguard widgets. Has no effect.
         */
        const Int32 KEYGUARD_DISABLE_WIDGETS_ALL = 1 << 0;

        /**
         * Disable the camera on secure keyguard screens (e.g. PIN/Pattern/Password)
         */
        const Int32 KEYGUARD_DISABLE_SECURE_CAMERA = 1 << 1;

        /**
         * Disable showing all notifications on secure keyguard screens (e.g. PIN/Pattern/Password)
         */
        const Int32 KEYGUARD_DISABLE_SECURE_NOTIFICATIONS = 1 << 2;

        /**
         * Only allow redacted notifications on secure keyguard screens (e.g. PIN/Pattern/Password)
         */
        const Int32 KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS = 1 << 3;

        /**
         * Ignore trust agent state on secure keyguard screens
         * (e.g. PIN/Pattern/Password).
         */
        const Int32 KEYGUARD_DISABLE_TRUST_AGENTS = 1 << 4;

        /**
         * Disable fingerprint sensor on keyguard secure screens (e.g. PIN/Pattern/Password).
         */
        const Int32 KEYGUARD_DISABLE_FINGERPRINT = 1 << 5;

        /**
         * Disable all current and future keyguard customizations.
         */
        const Int32 KEYGUARD_DISABLE_FEATURES_ALL = 0x7fffffff;


        /**
         * Return true if the given administrator component is currently
         * active (enabled) in the system.
         */
        IsAdminActive(
            [in] IComponentName* who,
            [out] Boolean* isAdminActive);

        /**
         * Return a list of all currently active device administrator's component
         * names.  Note that if there are no administrators than null may be
         * returned.
         */
        GetActiveAdmins(
            [out] IList** admins);

        /**
         * Used by package administration code to determine if a package can be stopped
         * or uninstalled.
         * @hide
         */
        PackageHasActiveAdmins(
            [in] String packageName,
            [out] Boolean* hasAdmins);

        /**
         * Remove a current administration component.  This can only be called
         * by the application that owns the administration component; if you
         * try to remove someone else's component, a security exception will be
         * thrown.
         */
        RemoveActiveAdmin(
            [in] IComponentName* who);

        /**
         * Returns true if an administrator has been granted a particular device policy.  This can
         * be used to check if the administrator was activated under an earlier set of policies,
         * but requires additional policies after an upgrade.
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated with.  Must be
         * an active administrator, or an exception will be thrown.
         * @param usesPolicy Which uses-policy to check, as defined in {@sa DeviceAdminInfo}.
         */
        HasGrantedPolicy(
            [in] IComponentName* admin,
            [in] Int32 usesPolicy,
            [out] Boolean* hasGrant);

        /**
         * Called by an application that is administering the device to set the
         * password restrictions it is imposing.  After setting this, the user
         * will not be able to enter a new password that is not at least as
         * restrictive as what has been set.  Note that the current password
         * will remain until the user has set a new one, so the change does not
         * take place immediately.  To prompt the user for a new password, use
         * #ACTION_SET_NEW_PASSWORD after setting this value.
         *
         * @sa #ACTION_SET_NEW_PASSWORD
         *
         * <p>Quality constants are ordered so that higher values are more restrictive;
         * thus the highest requested quality constant (between the policy set here,
         * the user's preference, and any other considerations) is the one that
         * is in effect.
         *
         * <p>The calling device admin must have requested
         * DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD to be able to call
         * this method; if it has not, a security exception will be thrown.
         *
         * @sa DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated with.
         * @param quality The new desired quality.  One of
         * {@sa #PASSWORD_QUALITY_UNSPECIFIED}, {@sa #PASSWORD_QUALITY_SOMETHING},
         * {@sa #PASSWORD_QUALITY_NUMERIC}, {@sa #PASSWORD_QUALITY_ALPHABETIC},
         * {@sa #PASSWORD_QUALITY_ALPHANUMERIC} or {@sa #PASSWORD_QUALITY_COMPLEX}.
         */
        SetPasswordQuality(
            [in] IComponentName* admin,
            [in] Int32 quality);

        /**
         * Retrieve the current minimum password quality for all admins
         * or a particular one.
         * @param admin The name of the admin component to check, or null to aggregate
         * all admins.
         */
        GetPasswordQuality(
            [in] IComponentName* admin,
            [out] Int32* password);

        /** @hide per-user version */
        GetPasswordQuality(
            [in] IComponentName* admin,
            [in] Int32 userHandle,
            [out] Int32* password);

        /**
         * Called by an application that is administering the device to set the
         * minimum allowed password length.  After setting this, the user
         * will not be able to enter a new password that is not at least as
         * restrictive as what has been set.  Note that the current password
         * will remain until the user has set a new one, so the change does not
         * take place immediately.  To prompt the user for a new password, use
         * {@sa #ACTION_SET_NEW_PASSWORD} after setting this value.  This
         * constraint is only imposed if the administrator has also requested either
         * {@sa #PASSWORD_QUALITY_NUMERIC}, {@sa #PASSWORD_QUALITY_ALPHABETIC}
         * {@sa #PASSWORD_QUALITY_ALPHANUMERIC}, or {@sa #PASSWORD_QUALITY_COMPLEX}
         * with {@sa #setPasswordQuality}.
         *
         * <p>The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
         * this method; if it has not, a security exception will be thrown.
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated with.
         * @param length The new desired minimum password length.  A value of 0
         * means there is no restriction.
         */
        SetPasswordMinimumLength(
            [in] IComponentName* admin,
            [in] Int32 length);

        /**
         * Retrieve the current minimum password length for all admins
         * or a particular one.
         * @param admin The name of the admin component to check, or null to aggregate
         * all admins.
         */
        GetPasswordMinimumLength(
            [in] IComponentName* admin,
            [out] Int32* password);

        /** @hide per-user version */
        GetPasswordMinimumLength(
            [in] IComponentName* admin,
            [in] Int32 userHandle,
            [out] Int32* password);

        /**
         * Called by an application that is administering the device to set the
         * minimum number of upper case letters required in the password. After
         * setting this, the user will not be able to enter a new password that is
         * not at least as restrictive as what has been set. Note that the current
         * password will remain until the user has set a new one, so the change does
         * not take place immediately. To prompt the user for a new password, use
         * {@sa #ACTION_SET_NEW_PASSWORD} after setting this value. This
         * constraint is only imposed if the administrator has also requested
         * {@sa #PASSWORD_QUALITY_COMPLEX} with {@sa #setPasswordQuality}. The
         * default value is 0.
         * <p>
         * The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
         * this method; if it has not, a security exception will be thrown.
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated
         *            with.
         * @param length The new desired minimum number of upper case letters
         *            required in the password. A value of 0 means there is no
         *            restriction.
         */
        SetPasswordMinimumUpperCase(
            [in] IComponentName* admin,
            [in] Int32 length);

        /**
         * Retrieve the current number of upper case letters required in the
         * password for all admins or a particular one. This is the same value as
         * set by {#link {@sa #setPasswordMinimumUpperCase(ComponentName, int)}
         * and only applies when the password quality is
         * {@sa #PASSWORD_QUALITY_COMPLEX}.
         *
         * @param admin The name of the admin component to check, or null to
         *            aggregate all admins.
         * @return The minimum number of upper case letters required in the
         *         password.
         */
        GetPasswordMinimumUpperCase(
            [in] IComponentName* admin,
            [out] Int32* password);

        /** @hide per-user version */
        GetPasswordMinimumUpperCase(
            [in] IComponentName* admin,
            [in] Int32 userHandle,
            [out] Int32* password);

        /**
         * Called by an application that is administering the device to set the
         * minimum number of lower case letters required in the password. After
         * setting this, the user will not be able to enter a new password that is
         * not at least as restrictive as what has been set. Note that the current
         * password will remain until the user has set a new one, so the change does
         * not take place immediately. To prompt the user for a new password, use
         * {@sa #ACTION_SET_NEW_PASSWORD} after setting this value. This
         * constraint is only imposed if the administrator has also requested
         * {@sa #PASSWORD_QUALITY_COMPLEX} with {@sa #setPasswordQuality}. The
         * default value is 0.
         * <p>
         * The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
         * this method; if it has not, a security exception will be thrown.
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated
         *            with.
         * @param length The new desired minimum number of lower case letters
         *            required in the password. A value of 0 means there is no
         *            restriction.
         */
        SetPasswordMinimumLowerCase(
            [in] IComponentName* admin,
            [in] Int32 length);

        /**
         * Retrieve the current number of lower case letters required in the
         * password for all admins or a particular one. This is the same value as
         * set by {#link {@sa #setPasswordMinimumLowerCase(ComponentName, int)}
         * and only applies when the password quality is
         * {@sa #PASSWORD_QUALITY_COMPLEX}.
         *
         * @param admin The name of the admin component to check, or null to
         *            aggregate all admins.
         * @return The minimum number of lower case letters required in the
         *         password.
         */
        GetPasswordMinimumLowerCase(
            [in] IComponentName* admin,
            [out] Int32* password);

        /** @hide per-user version */
        GetPasswordMinimumLowerCase(
            [in] IComponentName* admin,
            [in] Int32 userHandle,
            [out] Int32* password);

        /**
         * Called by an application that is administering the device to set the
         * minimum number of letters required in the password. After setting this,
         * the user will not be able to enter a new password that is not at least as
         * restrictive as what has been set. Note that the current password will
         * remain until the user has set a new one, so the change does not take
         * place immediately. To prompt the user for a new password, use
         * {@sa #ACTION_SET_NEW_PASSWORD} after setting this value. This
         * constraint is only imposed if the administrator has also requested
         * {@sa #PASSWORD_QUALITY_COMPLEX} with {@sa #setPasswordQuality}. The
         * default value is 1.
         * <p>
         * The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
         * this method; if it has not, a security exception will be thrown.
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated
         *            with.
         * @param length The new desired minimum number of letters required in the
         *            password. A value of 0 means there is no restriction.
         */
        SetPasswordMinimumLetters(
            [in] IComponentName* admin,
            [in] Int32 length);

        /**
         * Retrieve the current number of letters required in the password for all
         * admins or a particular one. This is the same value as
         * set by {#link {@sa #setPasswordMinimumLetters(ComponentName, int)}
         * and only applies when the password quality is
         * {@sa #PASSWORD_QUALITY_COMPLEX}.
         *
         * @param admin The name of the admin component to check, or null to
         *            aggregate all admins.
         * @return The minimum number of letters required in the password.
         */
        GetPasswordMinimumLetters(
            [in] IComponentName* admin,
            [out] Int32* password);

        /** @hide per-user version */
        GetPasswordMinimumLetters(
            [in] IComponentName* admin,
            [in] Int32 userHandle,
            [out] Int32* password);

        /**
         * Called by an application that is administering the device to set the
         * minimum number of numerical digits required in the password. After
         * setting this, the user will not be able to enter a new password that is
         * not at least as restrictive as what has been set. Note that the current
         * password will remain until the user has set a new one, so the change does
         * not take place immediately. To prompt the user for a new password, use
         * {@sa #ACTION_SET_NEW_PASSWORD} after setting this value. This
         * constraint is only imposed if the administrator has also requested
         * {@sa #PASSWORD_QUALITY_COMPLEX} with {@sa #setPasswordQuality}. The
         * default value is 1.
         * <p>
         * The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
         * this method; if it has not, a security exception will be thrown.
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated
         *            with.
         * @param length The new desired minimum number of numerical digits required
         *            in the password. A value of 0 means there is no restriction.
         */
        SetPasswordMinimumNumeric(
            [in] IComponentName* admin,
            [in] Int32 length);

        /**
         * Retrieve the current number of numerical digits required in the password
         * for all admins or a particular one. This is the same value as
         * set by {#link {@sa #setPasswordMinimumNumeric(ComponentName, int)}
         * and only applies when the password quality is
         * {@sa #PASSWORD_QUALITY_COMPLEX}.
         *
         * @param admin The name of the admin component to check, or null to
         *            aggregate all admins.
         * @return The minimum number of numerical digits required in the password.
         */
        GetPasswordMinimumNumeric(
            [in] IComponentName* admin,
            [out] Int32* password);

        /** @hide per-user version */
        GetPasswordMinimumNumeric(
            [in] IComponentName* admin,
            [in] Int32 userHandle,
            [out] Int32* password);

        /**
         * Called by an application that is administering the device to set the
         * minimum number of symbols required in the password. After setting this,
         * the user will not be able to enter a new password that is not at least as
         * restrictive as what has been set. Note that the current password will
         * remain until the user has set a new one, so the change does not take
         * place immediately. To prompt the user for a new password, use
         * {@sa #ACTION_SET_NEW_PASSWORD} after setting this value. This
         * constraint is only imposed if the administrator has also requested
         * {@sa #PASSWORD_QUALITY_COMPLEX} with {@sa #setPasswordQuality}. The
         * default value is 1.
         * <p>
         * The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
         * this method; if it has not, a security exception will be thrown.
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated
         *            with.
         * @param length The new desired minimum number of symbols required in the
         *            password. A value of 0 means there is no restriction.
         */
        SetPasswordMinimumSymbols(
            [in] IComponentName* admin,
            [in] Int32 length);

        /**
         * Retrieve the current number of symbols required in the password for all
         * admins or a particular one. This is the same value as
         * set by {#link {@sa #setPasswordMinimumSymbols(ComponentName, int)}
         * and only applies when the password quality is
         * {@sa #PASSWORD_QUALITY_COMPLEX}.
         *
         * @param admin The name of the admin component to check, or null to
         *            aggregate all admins.
         * @return The minimum number of symbols required in the password.
         */
        GetPasswordMinimumSymbols(
            [in] IComponentName* admin,
            [out] Int32* password);


        /** @hide per-user version*/
        GetPasswordMinimumSymbols(
            [in] IComponentName* admin,
            [in] Int32 userHandle,
            [out] Int32* password);

        /**
         * Called by an application that is administering the device to set the
         * minimum number of non-letter characters (numerical digits or symbols)
         * required in the password. After setting this, the user will not be able
         * to enter a new password that is not at least as restrictive as what has
         * been set. Note that the current password will remain until the user has
         * set a new one, so the change does not take place immediately. To prompt
         * the user for a new password, use {@sa #ACTION_SET_NEW_PASSWORD} after
         * setting this value. This constraint is only imposed if the administrator
         * has also requested {@sa #PASSWORD_QUALITY_COMPLEX} with
         * {@sa #setPasswordQuality}. The default value is 0.
         * <p>
         * The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
         * this method; if it has not, a security exception will be thrown.
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated
         *            with.
         * @param length The new desired minimum number of letters required in the
         *            password. A value of 0 means there is no restriction.
         */
        SetPasswordMinimumNonLetter(
            [in] IComponentName* admin,
            [in] Int32 length);

        /**
         * Retrieve the current number of non-letter characters required in the
         * password for all admins or a particular one. This is the same value as
         * set by {#link {@sa #setPasswordMinimumNonLetter(ComponentName, int)}
         * and only applies when the password quality is
         * {@sa #PASSWORD_QUALITY_COMPLEX}.
         *
         * @param admin The name of the admin component to check, or null to
         *            aggregate all admins.
         * @return The minimum number of letters required in the password.
         */
        GetPasswordMinimumNonLetter(
            [in] IComponentName* admin,
            [out] Int32* password);

        /** @hide per-user version */
        GetPasswordMinimumNonLetter(
            [in] IComponentName* admin,
            [in] Int32 userHandle,
            [out] Int32* password);

        /**
         * Called by an application that is administering the device to set the length
         * of the password history. After setting this, the user will not be able to
         * enter a new password that is the same as any password in the history. Note
         * that the current password will remain until the user has set a new one, so
         * the change does not take place immediately. To prompt the user for a new
         * password, use {@sa #ACTION_SET_NEW_PASSWORD} after setting this value.
         * This constraint is only imposed if the administrator has also requested
         * either {@sa #PASSWORD_QUALITY_NUMERIC},
         * {@sa #PASSWORD_QUALITY_ALPHABETIC}, or
         * {@sa #PASSWORD_QUALITY_ALPHANUMERIC} with {@sa #setPasswordQuality}.
         *
         * <p>
         * The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this
         * method; if it has not, a security exception will be thrown.
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated
         *        with.
         * @param length The new desired length of password history. A value of 0
         *        means there is no restriction.
         */
        SetPasswordHistoryLength(
            [in] IComponentName* admin,
            [in] Int32 length);

        /**
         * Called by a device admin to set the password expiration timeout. Calling this method
         * will restart the countdown for password expiration for the given admin, as will changing
         * the device password (for all admins).
         *
         * <p>The provided timeout is the time delta in ms and will be added to the current time.
         * For example, to have the password expire 5 days from now, timeout would be
         * 5 * 86400 * 1000 = 432000000 ms for timeout.
         *
         * <p>To disable password expiration, a value of 0 may be used for timeout.
         *
         * <p>The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD} to be able to call this
         * method; if it has not, a security exception will be thrown.
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated with.
         * @param timeout The limit (in ms) that a password can remain in effect. A value of 0
         *        means there is no restriction (unlimited).
         */
        SetPasswordExpirationTimeout(
            [in] IComponentName* admin,
            [in] Int64 timeout);

        /**
         * Get the password expiration timeout for the given admin. The expiration timeout is the
         * recurring expiration timeout provided in the call to
         * {@sa #setPasswordExpirationTimeout(ComponentName, long)} for the given admin or the
         * aggregate of all policy administrators if admin is null.
         *
         * @param admin The name of the admin component to check, or null to aggregate all admins.
         * @return The timeout for the given admin or the minimum of all timeouts
         */
        GetPasswordExpirationTimeout(
            [in] IComponentName* admin,
            [out] Int64* password);

        /**
         * Get the current password expiration time for the given admin or an aggregate of
         * all admins if admin is null. If the password is expired, this will return the time since
         * the password expired as a negative number.  If admin is null, then a composite of all
         * expiration timeouts is returned - which will be the minimum of all timeouts.
         *
         * @param admin The name of the admin component to check, or null to aggregate all admins.
         * @return The password expiration time, in ms.
         */
        GetPasswordExpiration(
            [in] IComponentName* admin,
            [out] Int64* password);

        /**
         * Retrieve the current password history length for all admins
         * or a particular one.
         * @param admin The name of the admin component to check, or null to aggregate
         * all admins.
         * @return The length of the password history
         */
        GetPasswordHistoryLength(
            [in] IComponentName* admin,
            [out] Int32* password);

        /** @hide per-user version */
        GetPasswordHistoryLength(
            [in] IComponentName* admin,
            [in] Int32 userHandle,
            [out] Int32* password);

        /**
         * Return the maximum password length that the device supports for a
         * particular password quality.
         * @param quality The quality being interrogated.
         * @return Returns the maximum length that the user can enter.
         */
        GetPasswordMaximumLength(
            [in] Int32 quality,
            [out] Int32* password);

        /**
         * Determine whether the current password the user has set is sufficient
         * to meet the policy requirements (quality, minimum length) that have been
         * requested.
         *
         * <p>The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
         * this method; if it has not, a security exception will be thrown.
         *
         * @return Returns true if the password meets the current requirements,
         * else false.
         */
        IsActivePasswordSufficient(
            [out] Boolean* isSufficient);

        /**
         * Retrieve the number of times the user has failed at entering a
         * password since that last successful password entry.
         *
         * <p>The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} to be able to call
         * this method; if it has not, a security exception will be thrown.
         */
        GetCurrentFailedPasswordAttempts(
            [out] Int32* password);

        /**
         * Setting this to a value greater than zero enables a built-in policy
         * that will perform a device wipe after too many incorrect
         * device-unlock passwords have been entered.  This built-in policy combines
         * watching for failed passwords and wiping the device, and requires
         * that you request both {@sa DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} and
         * {@sa DeviceAdminInfo#USES_POLICY_WIPE_DATA}}.
         *
         * <p>To implement any other policy (e.g. wiping data for a particular
         * application only, erasing or revoking credentials, or reporting the
         * failure to a server), you should implement
         * {@sa DeviceAdminReceiver#onPasswordFailed(Context, android.content.Intent)}
         * instead.  Do not use this API, because if the maximum count is reached,
         * the device will be wiped immediately, and your callback will not be invoked.
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated with.
         * @param num The number of failed password attempts at which point the
         * device will wipe its data.
         */
        SetMaximumFailedPasswordsForWipe(
            [in] IComponentName* admin,
            [in] Int32 num);

        /**
         * Retrieve the current maximum number of login attempts that are allowed
         * before the device wipes itself, for all admins
         * or a particular one.
         * @param admin The name of the admin component to check, or null to aggregate
         * all admins.
         */
        GetMaximumFailedPasswordsForWipe(
            [in] IComponentName* admin,
            [out] Int32* password);

        /** @hide per-user version */
        GetMaximumFailedPasswordsForWipe(
            [in] IComponentName* admin,
            [in] Int32 userHandle,
            [out] Int32* password);

        /**
         * Force a new device unlock password (the password needed to access the
         * entire device, not for individual accounts) on the user.  This takes
         * effect immediately.
         * The given password must be sufficient for the
         * current password quality and length constraints as returned by
         * {@sa #getPasswordQuality(ComponentName)} and
         * {@sa #getPasswordMinimumLength(ComponentName)}; if it does not meet
         * these constraints, then it will be rejected and false returned.  Note
         * that the password may be a stronger quality (containing alphanumeric
         * characters when the requested quality is only numeric), in which case
         * the currently active quality will be increased to match.
         *
         * <p>The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_RESET_PASSWORD} to be able to call
         * this method; if it has not, a security exception will be thrown.
         *
         * @param password The new password for the user.
         * @param flags May be 0 or {@sa #RESET_PASSWORD_REQUIRE_ENTRY}.
         * @return Returns true if the password was applied, or false if it is
         * not acceptable for the current constraints.
         */
        ResetPassword(
            [in] String password,
            [in] Int32 flags,
            [out] Boolean* reset);

        /**
         * Called by an application that is administering the device to set the
         * maximum time for user activity until the device will lock.  This limits
         * the length that the user can set.  It takes effect immediately.
         *
         * <p>The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_FORCE_LOCK} to be able to call
         * this method; if it has not, a security exception will be thrown.
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated with.
         * @param timeMs The new desired maximum time to lock in milliseconds.
         * A value of 0 means there is no restriction.
         */
        SetMaximumTimeToLock(
            [in] IComponentName* admin,
            [in] Int64 timeMs);

        /**
         * Retrieve the current maximum time to unlock for all admins
         * or a particular one.
         * @param admin The name of the admin component to check, or null to aggregate
         * all admins.
         */
        GetMaximumTimeToLock(
            [in] IComponentName* admin,
            [out] Int64* time);

        /** @hide per-user version */
        GetMaximumTimeToLock(
            [in] IComponentName* admin,
            [in] Int32 userHandle,
            [out] Int64* time);

        /**
         * Make the device lock immediately, as if the lock screen timeout has
         * expired at the point of this call.
         *
         * <p>The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_FORCE_LOCK} to be able to call
         * this method; if it has not, a security exception will be thrown.
         */
        LockNow();

        /**
         * Ask the user date be wiped.  This will cause the device to reboot,
         * erasing all user data while next booting up.  External storage such
         * as SD cards will be also erased if the flag {@sa #WIPE_EXTERNAL_STORAGE}
         * is set.
         *
         * <p>The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_WIPE_DATA} to be able to call
         * this method; if it has not, a security exception will be thrown.
         *
         * @param flags Bit mask of additional options: currently 0 and
         *              {@sa #WIPE_EXTERNAL_STORAGE} are supported.
         */
        WipeData(
            [in] Int32 flags);

        /**
         * Called by an application that is administering the device to set the
         * global proxy and exclusion list.
         * <p>
         * The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_SETS_GLOBAL_PROXY} to be able to call
         * this method; if it has not, a security exception will be thrown.
         * Only the first device admin can set the proxy. If a second admin attempts
         * to set the proxy, the {@sa ComponentName} of the admin originally setting the
         * proxy will be returned. If successful in setting the proxy, null will
         * be returned.
         * The method can be called repeatedly by the device admin alrady setting the
         * proxy to update the proxy and exclusion list.
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated
         *            with.
         * @param proxySpec the global proxy desired. Must be an HTTP Proxy.
         *            Pass Proxy.NO_PROXY to reset the proxy.
         * @param exclusionList a list of domains to be excluded from the global proxy.
         * @return returns null if the proxy was successfully set, or a {@sa ComponentName}
         *            of the device admin that sets thew proxy otherwise.
         * @hide
         */
        SetGlobalProxy(
            [in] IComponentName* admin,
            [in] IProxy* proxySpec,
            [in] ArrayOf<String>* exclusionList,
            [out] IComponentName** component);

        /**
         * Set a network-independent global HTTP proxy.  This is not normally what you want
         * for typical HTTP proxies - they are generally network dependent.  However if you're
         * doing something unusual like general internal filtering this may be useful.  On
         * a private network where the proxy is not accessible, you may break HTTP using this.
         *
         * <p>This method requires the caller to be the device owner.
         *
         * <p>This proxy is only a recommendation and it is possible that some apps will ignore it.
         * @see ProxyInfo
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated
         *            with.
         * @param proxyInfo The a {@link ProxyInfo} object defining the new global
         *        HTTP proxy.  A {@code null} value will clear the global HTTP proxy.
         */
        SetRecommendedGlobalProxy(
            [in] IComponentName* admin,
            [in] IProxyInfo* proxySpec);

        /**
         * Returns the component name setting the global proxy.
         * @return ComponentName object of the device admin that set the global proxy, or
         *            null if no admin has set the proxy.
         * @hide
         */
        GetGlobalProxyAdmin(
            [out] IComponentName** global);

        /**
         * Called by an application that is administering the device to
         * request that the storage system be encrypted.
         *
         * <p>When multiple device administrators attempt to control device
         * encryption, the most secure, supported setting will always be
         * used.  If any device administrator requests device encryption,
         * it will be enabled;  Conversely, if a device administrator
         * attempts to disable device encryption while another
         * device administrator has enabled it, the call to disable will
         * fail (most commonly returning {@sa #ENCRYPTION_STATUS_ACTIVE}).
         *
         * <p>This policy controls encryption of the secure (application data) storage area.  Data
         * written to other storage areas may or may not be encrypted, and this policy does not require
         * or control the encryption of any other storage areas.
         * There is one exception:  If {@sa android.os.Environment#isExternalStorageEmulated()} is
         * true, then the directory returned by
         * {@sa android.os.Environment#getExternalStorageDirectory()} must be written to disk
         * within the encrypted storage area.
         *
         * <p>Important Note:  On some devices, it is possible to encrypt storage without requiring
         * the user to create a device PIN or Password.  In this case, the storage is encrypted, but
         * the encryption key may not be fully secured.  For maximum security, the administrator should
         * also require (and check for) a pattern, PIN, or password.
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated with.
         * @param encrypt true to request encryption, false to release any previous request
         * @return the new request status (for all active admins) - will be one of
         * {@sa #ENCRYPTION_STATUS_UNSUPPORTED}, {@sa #ENCRYPTION_STATUS_INACTIVE}, or
         * {@sa #ENCRYPTION_STATUS_ACTIVE}.  This is the value of the requests;  Use
         * {@sa #getStorageEncryptionStatus()} to query the actual device state.
         */
        SetStorageEncryption(
            [in] IComponentName* admin,
            [in] Boolean encrypt,
            [out] Int32* result);

        /**
         * Called by an application that is administering the device to
         * determine the requested setting for secure storage.
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated with.  If null,
         * this will return the requested encryption setting as an aggregate of all active
         * administrators.
         * @return true if the admin(s) are requesting encryption, false if not.
         */
        GetStorageEncryption(
            [in] IComponentName* admin,
            [out] Boolean* result);

         /**
          * Called by an application that is administering the device to
          * determine the current encryption status of the device.
          *
          * Depending on the returned status code, the caller may proceed in different
          * ways.  If the result is {@sa #ENCRYPTION_STATUS_UNSUPPORTED}, the
          * storage system does not support encryption.  If the
          * result is {@sa #ENCRYPTION_STATUS_INACTIVE}, use {@sa
          * #ACTION_START_ENCRYPTION} to begin the process of encrypting or decrypting the
          * storage.  If the result is {@sa #ENCRYPTION_STATUS_ACTIVATING} or
          * {@sa #ENCRYPTION_STATUS_ACTIVE}, no further action is required.
          *
          * @return current status of encryption.  The value will be one of
          * {@sa #ENCRYPTION_STATUS_UNSUPPORTED}, {@sa #ENCRYPTION_STATUS_INACTIVE},
          * {@sa #ENCRYPTION_STATUS_ACTIVATING}, or{@sa #ENCRYPTION_STATUS_ACTIVE}.
          */
        GetStorageEncryptionStatus(
            [out] Int32* st);

        /** @hide per-user version */
        GetStorageEncryptionStatus(
            [in] Int32 userHandle,
            [out] Int32* st);

        /**
         * Installs the given certificate as a user CA.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param certBuffer encoded form of the certificate to install.
         *
         * @return false if the certBuffer cannot be parsed or installation is
         *         interrupted, true otherwise.
         */
        InstallCaCert(
            [in] IComponentName* admin,
            [in] ArrayOf<Byte>* certBuffer,
            [out] Boolean* result);

        /**
         * Uninstalls the given certificate from trusted user CAs, if present.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param certBuffer encoded form of the certificate to remove.
         */
        UninstallCaCert(
            [in] IComponentName* admin,
            [in] ArrayOf<Byte>* certBuffer);

        /**
         * Returns all CA certificates that are currently trusted, excluding system CA certificates.
         * If a user has installed any certificates by other means than device policy these will be
         * included too.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @return a List of byte[] arrays, each encoding one user CA certificate.
         */
        GetInstalledCaCerts(
            [in] IComponentName* admin,
            [out] IList** list);

        /**
         * Uninstalls all custom trusted CA certificates from the profile. Certificates installed by
         * means other than device policy will also be removed, except for system CA certificates.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         */
        UninstallAllUserCaCerts(
            [in] IComponentName* admin);

        /**
         * Returns whether this certificate is installed as a trusted CA.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param certBuffer encoded form of the certificate to look up.
         */
        HasCaCertInstalled(
            [in] IComponentName* admin,
            [in] ArrayOf<Byte>* certBuffer,
            [out] Boolean* result);

        /**
         * Called by a device or profile owner to install a certificate and private key pair. The
         * keypair will be visible to all apps within the profile.
         *
         * @param who Which {@link DeviceAdminReceiver} this request is associated with.
         * @param privKey The private key to install.
         * @param cert The certificate to install.
         * @param alias The private key alias under which to install the certificate. If a certificate
         * with that alias already exists, it will be overwritten.
         * @return {@code true} if the keys were installed, {@code false} otherwise.
         */
        InstallKeyPair(
            [in] IComponentName* who,
            [in] IPrivateKey* privKey,
            [in] ICertificate* cert,
            [in] String alias,
            [out] Boolean* result);

        /**
         * Called by an application that is administering the device to disable all cameras
         * on the device.  After setting this, no applications will be able to access any cameras
         * on the device.
         *
         * <p>The calling device admin must have requested
         * {@sa DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call
         * this method; if it has not, a security exception will be thrown.
         *
         * @param admin Which {@sa DeviceAdminReceiver} this request is associated with.
         * @param disabled Whether or not the camera should be disabled.
         */
        SetCameraDisabled(
            [in] IComponentName* admin,
            [in] Boolean disabled);

        /**
         * Determine whether or not the device's cameras have been disabled either by the current
         * admin, if specified, or all admins.
         * @param admin The name of the admin component to check, or null to check if any admins
         * have disabled the camera
         */
        GetCameraDisabled(
            [in] IComponentName* admin,
            [out] Boolean* disabled);

        /** @hide per-user version */
        GetCameraDisabled(
            [in] IComponentName* admin,
            [in] Int32 userHandle,
            [out] Boolean* disabled);

        /**
         * Called by a device/profile owner to set whether the screen capture is disabled. Disabling
         * screen capture also prevents the content from being shown on display devices that do not have
         * a secure video output. See {@link android.view.Display#FLAG_SECURE} for more details about
         * secure surfaces and secure displays.
         *
         * <p>The calling device admin must be a device or profile owner. If it is not, a
         * security exception will be thrown.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param disabled Whether screen capture is disabled or not.
         */
        SetScreenCaptureDisabled(
            [in] IComponentName* admin,
            [in] Boolean disabled);

        /**
         * Determine whether or not screen capture has been disabled by the current
         * admin, if specified, or all admins.
         * @param admin The name of the admin component to check, or null to check if any admins
         * have disabled screen capture.
         */
        SetScreenCaptureDisabled(
            [in] IComponentName* admin,
            [out] Boolean* disabled);

        /**
         * Called by a device owner to set whether auto time is required. If auto time is
         * required the user cannot set the date and time, but has to use network date and time.
         *
         * <p>Note: if auto time is required the user can still manually set the time zone.
         *
         * <p>The calling device admin must be a device owner. If it is not, a security exception will
         * be thrown.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param required Whether auto time is set required or not.
         */
        SetAutoTimeRequired(
            [in] IComponentName* admin,
            [in] Boolean required);

        /**
         * @return true if auto time is required.
         */
        GetAutoTimeRequired(
            [out] Boolean* result);

        /**
         * Called by an application that is administering the device to disable keyguard customizations,
         * such as widgets. After setting this, keyguard features will be disabled according to the
         * provided feature list.
         *
         * <p>The calling device admin must have requested
         * {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES} to be able to call
         * this method; if it has not, a security exception will be thrown.
         *
         * <p>Calling this from a managed profile will throw a security exception.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param which {@link #KEYGUARD_DISABLE_FEATURES_NONE} (default),
         * {@link #KEYGUARD_DISABLE_WIDGETS_ALL}, {@link #KEYGUARD_DISABLE_SECURE_CAMERA},
         * {@link #KEYGUARD_DISABLE_SECURE_NOTIFICATIONS}, {@link #KEYGUARD_DISABLE_TRUST_AGENTS},
         * {@link #KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS}, {@link #KEYGUARD_DISABLE_FEATURES_ALL}
         */
        SetKeyguardDisabledFeatures(
            [in] IComponentName* admin,
            [in] Int32 which);

        /**
         * Determine whether or not features have been disabled in keyguard either by the current
         * admin, if specified, or all admins.
         * @param admin The name of the admin component to check, or null to check if any admins
         * have disabled features in keyguard.
         * @return bitfield of flags. See {@sa #setKeyguardDisabledFeatures(ComponentName, int)}
         * for a list.
         */
        GetKeyguardDisabledFeatures(
            [in] IComponentName* admin,
            [out] Int32* which);

        /** @hide per-user version */
        GetKeyguardDisabledFeatures(
            [in] IComponentName* admin,
            [in] Int32 userHandle,
            [out] Int32* which);

        /**
         * @hide
         */
        SetActiveAdmin(
            [in] IComponentName* policyReceiver,
            [in] Boolean refreshing);

        /**
         * Returns the DeviceAdminInfo as defined by the administrator's package info & meta-data
         * @hide
         */
        //GetAdminInfo(
        //    [in] IComponentName* cn,
        //    [out] IDeviceAdminInfo** info);

        /**
         * @hide
         */
        GetRemoveWarning(
            [in] IComponentName* admin,
            [in] IRemoteCallback* result);

        /**
         * @hide
         */
        SetActivePasswordState(
            [in] Int32 quality,
            [in] Int32 length,
            [in] Int32 letters,
            [in] Int32 uppercase,
            [in] Int32 lowercase,
            [in] Int32 numbers,
            [in] Int32 symbols,
            [in] Int32 nonletter,
            [in] Int32 userHandle);

        /**
         * @hide
         */
        ReportFailedPasswordAttempt(
            [in] Int32 userHandle);

        ReportSuccessfulPasswordAttempt(
            [in] Int32 userHandle);

        /**
         * @hide
         * Sets the given package as the device owner. The package must already be installed and there
         * shouldn't be an existing device owner registered, for this call to succeed. Also, this
         * method must be called before the device is provisioned.
         * @param packageName the package name of the application to be registered as the device owner.
         * @return whether the package was successfully registered as the device owner.
         * @throws IllegalArgumentException if the package name is null or invalid
         * @throws IllegalStateException if a device owner is already registered or the device has
         *         already been provisioned.
         */
        SetDeviceOwner(
            [in] String packageName,
            [out] Boolean* result);

        /**
         * @hide
         * Sets the given package as the device owner. The package must already be installed and there
         * shouldn't be an existing device owner registered, for this call to succeed. Also, this
         * method must be called before the device is provisioned.
         * @param packageName the package name of the application to be registered as the device owner.
         * @param ownerName the human readable name of the institution that owns this device.
         * @return whether the package was successfully registered as the device owner.
         * @throws IllegalArgumentException if the package name is null or invalid
         * @throws IllegalStateException if a device owner is already registered or the device has
         *         already been provisioned.
         */
        SetDeviceOwner(
            [in] String packageName,
            [in] String ownerName,
            [out] Boolean* result);

        /**
         * Used to determine if a particular package has been registered as a Device Owner app.
         * A device owner app is a special device admin that cannot be deactivated by the user, once
         * activated as a device admin. It also cannot be uninstalled. To check if a particular
         * package is currently registered as the device owner app, pass in the package name from
         * {@link Context#getPackageName()} to this method.<p/>This is useful for device
         * admin apps that want to check if they are also registered as the device owner app. The
         * exact mechanism by which a device admin app is registered as a device owner app is defined by
         * the setup process.
         * @param packageName the package name of the app, to compare with the registered device owner
         * app, if any.
         * @return whether or not the package is registered as the device owner app.
         */
        IsDeviceOwnerApp(
            [in] String packageName,
            [out] Boolean* result);

        /**
         * @hide
         * Redirect to isDeviceOwnerApp.
         */
        IsDeviceOwner(
            [in] String packageName,
            [out] Boolean* result);

        /**
         * Clears the current device owner.  The caller must be the device owner.
         *
         * This function should be used cautiously as once it is called it cannot
         * be undone.  The device owner can only be set as a part of device setup
         * before setup completes.
         *
         * @param packageName The package name of the device owner.
         */
        ClearDeviceOwnerApp(
            [in] String packageName);

        /**
         * @deprecated Use setProfileOwner(ComponentName ...)
         * @hide
         * Sets the given package as the profile owner of the given user profile. The package must
         * already be installed and there shouldn't be an existing profile owner registered for this
         * user. Also, this method must be called before the user has been used for the first time.
         * @param packageName the package name of the application to be registered as profile owner.
         * @param ownerName the human readable name of the organisation associated with this DPM.
         * @param userHandle the userId to set the profile owner for.
         * @return whether the package was successfully registered as the profile owner.
         * @throws IllegalArgumentException if packageName is null, the package isn't installed, or
         *         the user has already been set up.
         */
        SetProfileOwner(
            [in] String packageName,
            [in] String ownerName,
            [in] Int32 userHandle,
            [out] Boolean* result);

        /**
         * @hide
         * Sets the given component as the profile owner of the given user profile. The package must
         * already be installed and there shouldn't be an existing profile owner registered for this
         * user. Only the system can call this API if the user has already completed setup.
         * @param admin the component name to be registered as profile owner.
         * @param ownerName the human readable name of the organisation associated with this DPM.
         * @param userHandle the userId to set the profile owner for.
         * @return whether the component was successfully registered as the profile owner.
         * @throws IllegalArgumentException if admin is null, the package isn't installed, or
         *         the user has already been set up.
         */
        SetProfileOwner(
            [in] IComponentName* admin,
            [in] String ownerName,
            [in] Int32 userHandle,
            [out] Boolean* result);

        /**
         * Sets the enabled state of the profile. A profile should be enabled only once it is ready to
         * be used. Only the profile owner can call this.
         *
         * @see #isProfileOwnerApp
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         */
        SetProfileEnabled(
            [in] IComponentName* admin);

        /**
         * Sets the name of the profile. In the device owner case it sets the name of the user
         * which it is called from. Only a profile owner or device owner can call this. If this is
         * never called by the profile or device owner, the name will be set to default values.
         *
         * @see #isProfileOwnerApp
         * @see #isDeviceOwnerApp
         *
         * @param profileName The name of the profile.
         */
        SetProfileName(
            [in] IComponentName* who,
            [in] String profileName);

        /**
         * Used to determine if a particular package is registered as the profile owner for the
         * current user. A profile owner is a special device admin that has additional privileges
         * within the profile.
         *
         * @param packageName The package name of the app to compare with the registered profile owner.
         * @return Whether or not the package is registered as the profile owner.
         */
        IsProfileOwnerApp(
            [in] String packageName,
            [out] Boolean* result);

        /**
         * @hide
         * @return the packageName of the owner of the given user profile or null if no profile
         * owner has been set for that user.
         * @throws IllegalArgumentException if the userId is invalid.
         */
        //@SystemApi
        GetProfileOwner(
            [out] IComponentName** name);

        /**
         * Called by a profile owner or device owner to add a default intent handler activity for
         * intents that match a certain intent filter. This activity will remain the default intent
         * handler even if the set of potential event handlers for the intent filter changes and if
         * the intent preferences are reset.
         *
         * <p>The default disambiguation mechanism takes over if the activity is not installed
         * (anymore). When the activity is (re)installed, it is automatically reset as default
         * intent handler for the filter.
         *
         * <p>The calling device admin must be a profile owner or device owner. If it is not, a
         * security exception will be thrown.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param filter The IntentFilter for which a default handler is added.
         * @param activity The Activity that is added as default intent handler.
         */
        AddPersistentPreferredActivity(
            [in] IComponentName* admin,
            [in] IIntentFilter* filter,
            [in] IComponentName* activity);

        /**
         * Called by a profile owner or device owner to remove all persistent intent handler preferences
         * associated with the given package that were set by {@link #addPersistentPreferredActivity}.
         *
         * <p>The calling device admin must be a profile owner. If it is not, a security
         * exception will be thrown.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param packageName The name of the package for which preferences are removed.
         */
        ClearPackagePersistentPreferredActivities(
            [in] IComponentName* admin,
            [in] String packageName);

        /**
         * Called by a profile or device owner to set the application restrictions for a given target
         * application running in the profile.
         *
         * <p>The provided {@link Bundle} consists of key-value pairs, where the types of values may be
         * boolean, int, String, or String[].
         *
         * <p>The application restrictions are only made visible to the target application and the
         * profile or device owner.
         *
         * <p>The calling device admin must be a profile or device owner; if it is not, a security
         * exception will be thrown.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param packageName The name of the package to update restricted settings for.
         * @param settings A {@link Bundle} to be parsed by the receiving application, conveying a new
         * set of active restrictions.
         */
        SetApplicationRestrictions(
            [in] IComponentName* admin,
            [in] String packageName,
            [in] IBundle* settings);

        /**
         * Sets a list of features to enable for a TrustAgent component. This is meant to be
         * used in conjunction with {@link #KEYGUARD_DISABLE_TRUST_AGENTS}, which will disable all
         * trust agents but those with features enabled by this function call.
         *
         * <p>The calling device admin must have requested
         * {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES} to be able to call
         * this method; if it has not, a security exception will be thrown.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param agent Which component to enable features for.
         * @param features List of features to enable. Consult specific TrustAgent documentation for
         * the feature list.
         * @hide
         */
        SetTrustAgentFeaturesEnabled(
            [in] IComponentName* admin,
            [in] IComponentName* agent,
            [in] IList* features);

        /**
         * Gets list of enabled features for the given TrustAgent component. If admin is
         * null, this will return the intersection of all features enabled for the given agent by all
         * admins.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param agent Which component to get enabled features for.
         * @return List of enabled features.
         * @hide
         */
        GetTrustAgentFeaturesEnabled(
            [in] IComponentName* admin,
            [in] IComponentName* agent,
            [out] IList** result);

        /**
         * Called by a profile owner of a managed profile to set whether caller-Id information from
         * the managed profile will be shown in the parent profile, for incoming calls.
         *
         * <p>The calling device admin must be a profile owner. If it is not, a
         * security exception will be thrown.
         *
         * @param who Which {@link DeviceAdminReceiver} this request is associated with.
         * @param disabled If true caller-Id information in the managed profile is not displayed.
         */
        SetCrossProfileCallerIdDisabled(
            [in] IComponentName* who,
            [in] Boolean disabled);

        /**
         * Called by a profile owner of a managed profile to determine whether or not caller-Id
         * information has been disabled.
         *
         * <p>The calling device admin must be a profile owner. If it is not, a
         * security exception will be thrown.
         *
         * @param who Which {@link DeviceAdminReceiver} this request is associated with.
         */
        GetCrossProfileCallerIdDisabled(
            [in] IComponentName* who,
            [out] Boolean* result);

        /**
         * Called by the profile owner of a managed profile so that some intents sent in the managed
         * profile can also be resolved in the parent, or vice versa.
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param filter The {@link IntentFilter} the intent has to match to be also resolved in the
         * other profile
         * @param flags {@link DevicePolicyManager#FLAG_MANAGED_CAN_ACCESS_PARENT} and
         * {@link DevicePolicyManager#FLAG_PARENT_CAN_ACCESS_MANAGED} are supported.
         */
        AddCrossProfileIntentFilter(
            [in] IComponentName* admin,
            [in] IIntentFilter* filter,
            [in] Int32 flags);

        /**
         * Called by a profile owner of a managed profile to remove the cross-profile intent filters
         * that go from the managed profile to the parent, or from the parent to the managed profile.
         * Only removes those that have been set by the profile owner.
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         */
        ClearCrossProfileIntentFilters(
            [in] IComponentName* admin);

        /**
         * Called by a profile or device owner to set the permitted accessibility services. When
         * set by a device owner or profile owner the restriction applies to all profiles of the
         * user the device owner or profile owner is an admin for.
         *
         * By default the user can use any accessiblity service. When zero or more packages have
         * been added, accessiblity services that are not in the list and not part of the system
         * can not be enabled by the user.
         *
         * <p> Calling with a null value for the list disables the restriction so that all services
         * can be used, calling with an empty list only allows the builtin system's services.
         *
         * <p> System accesibility services are always available to the user the list can't modify
         * this.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param packageNames List of accessibility service package names.
         *
         * @return true if setting the restriction succeeded. It fail if there is
         * one or more non-system accessibility services enabled, that are not in the list.
         */
        SetPermittedAccessibilityServices(
            [in] IComponentName* admin,
            [in] IList* packageNames,
            [out] Boolean* result);

        /**
         * Returns the list of permitted accessibility services set by this device or profile owner.
         *
         * <p>An empty list means no accessibility services except system services are allowed.
         * Null means all accessibility services are allowed.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @return List of accessiblity service package names.
         */
        GetPermittedAccessibilityServices(
            [out] IComponentName** admin);

        /**
         * Called by a profile or device owner to set the permitted input methods services. When
         * set by a device owner or profile owner the restriction applies to all profiles of the
         * user the device owner or profile owner is an admin for.
         *
         * By default the user can use any input method. When zero or more packages have
         * been added, input method that are not in the list and not part of the system
         * can not be enabled by the user.
         *
         * This method will fail if it is called for a admin that is not for the foreground user
         * or a profile of the foreground user.
         *
         * <p> Calling with a null value for the list disables the restriction so that all input methods
         * can be used, calling with an empty list disables all but the system's own input methods.
         *
         * <p> System input methods are always available to the user this method can't modify this.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param packageNames List of input method package names.
         * @return true if setting the restriction succeeded. It will fail if there is
         *     one or more input method enabled, that are not in the list or user if the foreground
         *     user.
         */
        SetPermittedInputMethods(
            [in] IComponentName* admin,
            [in] IList* packageNames,
            [out] Boolean* result);

        /**
         * Returns the list of permitted input methods set by this device or profile owner.
         *
         * <p>An empty list means no input methods except system input methods are allowed.
         * Null means all input methods are allowed.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @return List of input method package names.
         */
        GetPermittedInputMethods(
            [in] IComponentName* admin,
            [out] IList** list);

        /**
         * Called by a device owner to create a user with the specified name. The UserHandle returned
         * by this method should not be persisted as user handles are recycled as users are removed and
         * created. If you need to persist an identifier for this user, use
         * {@link UserManager#getSerialNumberForUser}.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param name the user's name
         * @see UserHandle
         * @return the UserHandle object for the created user, or null if the user could not be created.
         */
        CreateUser(
            [in] IComponentName* admin,
            [in] String name,
            [out] IUserHandle** handle);

        /**
         * Called by a device owner to create a user with the specified name. The UserHandle returned
         * by this method should not be persisted as user handles are recycled as users are removed and
         * created. If you need to persist an identifier for this user, use
         * {@link UserManager#getSerialNumberForUser}.  The new user will be started in the background
         * immediately.
         *
         * <p> profileOwnerComponent is the {@link DeviceAdminReceiver} to be the profile owner as well
         * as registered as an active admin on the new user.  The profile owner package will be
         * installed on the new user if it already is installed on the device.
         *
         * <p>If the optionalInitializeData is not null, then the extras will be passed to the
         * profileOwnerComponent when onEnable is called.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param name the user's name
         * @param ownerName the human readable name of the organisation associated with this DPM.
         * @param profileOwnerComponent The {@link DeviceAdminReceiver} that will be an active admin on
         *      the user.
         * @param adminExtras Extras that will be passed to onEnable of the admin receiver
         *      on the new user.
         * @see UserHandle
         * @return the UserHandle object for the created user, or null if the user could not be created.
         */
        CreateAndInitializeUser(
            [in] IComponentName* admin,
            [in] String name,
            [in] String ownerName,
            [in] IComponentName* profileOwnerComponent,
            [in] IBundle* adminExtras);

        /**
         * Called by a device owner to remove a user and all associated data. The primary user can
         * not be removed.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param userHandle the user to remove.
         * @return {@code true} if the user was removed, {@code false} otherwise.
         */
        RemoveUser(
            [in] IComponentName* admin,
            [in] IUserHandle* userHandle);

        /**
         * Called by a device owner to switch the specified user to the foreground.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param userHandle the user to switch to; null will switch to primary.
         * @return {@code true} if the switch was successful, {@code false} otherwise.
         *
         * @see Intent#ACTION_USER_FOREGROUND
         */
        SwitchUser(
            [in] IComponentName* admin,
            [in] IUserHandle* userHandle,
            [out] Boolean* result);

        /**
         * Called by a profile or device owner to get the application restrictions for a given target
         * application running in the profile.
         *
         * <p>The calling device admin must be a profile or device owner; if it is not, a security
         * exception will be thrown.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param packageName The name of the package to fetch restricted settings of.
         * @return {@link Bundle} of settings corresponding to what was set last time
         * {@link DevicePolicyManager#setApplicationRestrictions} was called, or an empty {@link Bundle}
         * if no restrictions have been set.
         */
        GetApplicationRestrictions(
            [in] IComponentName* admin,
            [in] String packageName,
            [out] IBundle** bundle);

        /**
         * Called by a profile or device owner to set a user restriction specified
         * by the key.
         * <p>
         * The calling device admin must be a profile or device owner; if it is not,
         * a security exception will be thrown.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated
         *            with.
         * @param key The key of the restriction. See the constants in
         *            {@link android.os.UserManager} for the list of keys.
         */
        AddUserRestriction(
            [in] IComponentName* admin,
            [in] String key);

        /**
         * Called by a profile or device owner to clear a user restriction specified
         * by the key.
         * <p>
         * The calling device admin must be a profile or device owner; if it is not,
         * a security exception will be thrown.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated
         *            with.
         * @param key The key of the restriction. See the constants in
         *            {@link android.os.UserManager} for the list of keys.
         */
        ClearUserRestriction(
            [in] IComponentName* admin,
            [in] String key);

        /**
         * Called by device or profile owner to hide or unhide packages. When a package is hidden it
         * is unavailable for use, but the data and actual package file remain.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param packageName The name of the package to hide or unhide.
         * @param hidden {@code true} if the package should be hidden, {@code false} if it should be
         *                 unhidden.
         * @return boolean Whether the hidden setting of the package was successfully updated.
         */
        SetApplicationHidden(
            [in] IComponentName* admin,
            [in] String packageName,
            [in] Boolean hide,
            [out] Boolean* result);

        /**
         * Called by device or profile owner to determine if a package is hidden.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param packageName The name of the package to retrieve the hidden status of.
         * @return boolean {@code true} if the package is hidden, {@code false} otherwise.
         */
        IsApplicationHidden(
            [in] IComponentName* admin,
            [in] String packageName,
            [out] Boolean* result);

        /**
         * Called by profile or device owner to re-enable a system app that was disabled by default
         * when the user was initialized.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param packageName The package to be re-enabled in the current profile.
         */
        EnableSystemApp(
            [in] IComponentName* admin,
            [in] String packageName);

        /**
         * Called by profile or device owner to re-enable system apps by intent that were disabled
         * by default when the user was initialized.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param intent An intent matching the app(s) to be installed. All apps that resolve for this
         *               intent will be re-enabled in the current profile.
         * @return int The number of activities that matched the intent and were installed.
         */
        EnableSystemApp(
            [in] IComponentName* admin,
            [in] IIntent* intent,
            [out] Int32* result);

        /**
         * Called by a profile owner to disable account management for a specific type of account.
         *
         * <p>The calling device admin must be a profile owner. If it is not, a
         * security exception will be thrown.
         *
         * <p>When account management is disabled for an account type, adding or removing an account
         * of that type will not be possible.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param accountType For which account management is disabled or enabled.
         * @param disabled The boolean indicating that account management will be disabled (true) or
         * enabled (false).
         */
        SetAccountManagementDisabled(
            [in] IComponentName* admin,
            [in] String accountType,
            [in] Boolean disabled);

        /**
         * Gets the array of accounts for which account management is disabled by the profile owner.
         *
         * <p> Account management can be disabled/enabled by calling
         * {@link #setAccountManagementDisabled}.
         *
         * @return a list of account types for which account management has been disabled.
         *
         * @see #setAccountManagementDisabled
         */
        GetAccountTypesWithManagementDisabled(
            [out, callee] ArrayOf<String>* result);

        /**
         * @see #getAccountTypesWithManagementDisabled()
         * @hide
         */
        GetAccountTypesWithManagementDisabledAsUser(
            [in] Int32 userId,
            [out, callee] ArrayOf<String>* result);


        /**
         * Sets which packages may enter lock task mode.
         *
         * <p>Any packages that shares uid with an allowed package will also be allowed
         * to activate lock task.
         *
         * This function can only be called by the device owner.
         * @param packages The list of packages allowed to enter lock task mode
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         *
         * @see Activity#startLockTask()
         * @see DeviceAdminReceiver#onLockTaskModeChanged(Context, Intent, boolean, String)
         * @see UserManager#DISALLOW_CREATE_WINDOWS
         */
        SetLockTaskPackages(
            [in] IComponentName* admin,
            [out, callee] ArrayOf<String>* packages);

        /**
         * This function lets the caller know whether the given component is allowed to start the
         * lock task mode.
         * @param pkg The package to check
         */
        IsLockTaskPermitted(
            [in] String pkg,
            [out] Boolean* result);

        /**
         * Called by device owners to update {@link Settings.Global} settings. Validation that the value
         * of the setting is in the correct form for the setting type should be performed by the caller.
         * <p>The settings that can be updated with this method are:
         * <ul>
         * <li>{@link Settings.Global#ADB_ENABLED}</li>
         * <li>{@link Settings.Global#AUTO_TIME}</li>
         * <li>{@link Settings.Global#AUTO_TIME_ZONE}</li>
         * <li>{@link Settings.Global#BLUETOOTH_ON}</li>
         * <li>{@link Settings.Global#DATA_ROAMING}</li>
         * <li>{@link Settings.Global#DEVELOPMENT_SETTINGS_ENABLED}</li>
         * <li>{@link Settings.Global#MODE_RINGER}</li>
         * <li>{@link Settings.Global#NETWORK_PREFERENCE}</li>
         * <li>{@link Settings.Global#USB_MASS_STORAGE_ENABLED}</li>
         * <li>{@link Settings.Global#WIFI_ON}</li>
         * <li>{@link Settings.Global#WIFI_SLEEP_POLICY}</li>
         * </ul>
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param setting The name of the setting to update.
         * @param value The value to update the setting to.
         */
        SetGlobalSetting(
            [in] IComponentName* admin,
            [in] String setting,
            [in] String value);

        /**
         * Called by profile or device owners to update {@link Settings.Secure} settings. Validation
         * that the value of the setting is in the correct form for the setting type should be performed
         * by the caller.
         * <p>The settings that can be updated by a profile or device owner with this method are:
         * <ul>
         * <li>{@link Settings.Secure#DEFAULT_INPUT_METHOD}</li>
         * <li>{@link Settings.Secure#SKIP_FIRST_USE_HINTS}</li>
         * </ul>
         * <p>A device owner can additionally update the following settings:
         * <ul>
         * <li>{@link Settings.Secure#LOCATION_MODE}</li>
         * </ul>
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param setting The name of the setting to update.
         * @param value The value to update the setting to.
         */
        SetSecureSetting(
            [in] IComponentName* admin,
            [in] String setting,
            [in] String value);

        /**
         * Designates a specific service component as the provider for
         * making permission requests of a local or remote administrator of the user.
         * <p/>
         * Only a profile owner can designate the restrictions provider.
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param provider The component name of the service that implements
         * {@link RestrictionsReceiver}. If this param is null,
         * it removes the restrictions provider previously assigned.
         */
        SetRestrictionsProvider(
            [in] IComponentName* admin,
            [in] IComponentName* provider);

        /**
         * Called by profile or device owners to set the master volume mute on or off.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param on {@code true} to mute master volume, {@code false} to turn mute off.
         */
        SetMasterVolumeMuted(
            [in] IComponentName* admin,
            [in] Boolean on);

        /**
         * Called by profile or device owners to check whether the master volume mute is on or off.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @return {@code true} if master volume is muted, {@code false} if it's not.
         */
        IsMasterVolumeMuted(
            [in] IComponentName* admin,
            [out] Boolean* result);

        /**
         * Called by profile or device owners to change whether a user can uninstall
         * a package.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param packageName package to change.
         * @param uninstallBlocked true if the user shouldn't be able to uninstall the package.
         */
        SetUninstallBlocked(
            [in] IComponentName* admin,
            [in] String packageName,
            [in] Boolean uninstallBlocked);

        /**
         * Called by profile or device owners to check whether a user has been blocked from
         * uninstalling a package.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param packageName package to check.
         * @return true if the user shouldn't be able to uninstall the package.
         */
        IsUninstallBlocked(
            [in] IComponentName* admin,
            [in] String packageName,
            [out] Boolean* result);

        /**
         * Called by the profile owner of a managed profile to enable widget providers from a
         * given package to be available in the parent profile. As a result the user will be able to
         * add widgets from the white-listed package running under the profile to a widget
         * host which runs under the parent profile, for example the home screen. Note that
         * a package may have zero or more provider components, where each component
         * provides a different widget type.
         * <p>
         * <strong>Note:</strong> By default no widget provider package is white-listed.
         * </p>
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param packageName The package from which widget providers are white-listed.
         * @return Whether the package was added.
         *
         * @see #removeCrossProfileWidgetProvider(android.content.ComponentName, String)
         * @see #getCrossProfileWidgetProviders(android.content.ComponentName)
         */
        AddCrossProfileWidgetProvider(
            [in] IComponentName* admin,
            [in] String packageName,
            [out] Boolean* result);

        /**
         * Called by the profile owner of a managed profile to disable widget providers from a given
         * package to be available in the parent profile. For this method to take effect the
         * package should have been added via {@link #addCrossProfileWidgetProvider(
         * android.content.ComponentName, String)}.
         * <p>
         * <strong>Note:</strong> By default no widget provider package is white-listed.
         * </p>
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @param packageName The package from which widget providers are no longer
         *     white-listed.
         * @return Whether the package was removed.
         *
         * @see #addCrossProfileWidgetProvider(android.content.ComponentName, String)
         * @see #getCrossProfileWidgetProviders(android.content.ComponentName)
         */
        RemoveCrossProfileWidgetProvider(
            [in] IComponentName* admin,
            [in] String packageName,
            [out] Boolean* result);

        /**
         * Called by the profile owner of a managed profile to query providers from which packages are
         * available in the parent profile.
         *
         * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
         * @return The white-listed package list.
         *
         * @see #addCrossProfileWidgetProvider(android.content.ComponentName, String)
         * @see #removeCrossProfileWidgetProvider(android.content.ComponentName, String)
         */
        GetCrossProfileWidgetProviders(
            [in] IComponentName* admin,
            [out] IList** result);

        /**
         * CM: check if secure keyguard is required
         * @hide
         */
        RequireSecureKeyguard(
            [out] Boolean* isRequired);

        /** @hide */
        RequireSecureKeyguard(
            [in] Int32 userHandle,
            [out] Boolean* isRequired);
    }

    [local]
    interface IDevicePolicyManagerHelper {
        Create(
            [in] IContext* ctx,
            [in] IHandler* handler,
            [out] IDevicePolicyManager** policymanager);
    }

    } // namespace Admin
    } // namespace App
    } // namespace Droid
    } // namespace Elastos
}
