//=========================================================================
// Copyright (C) 2012 The Elastos Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//=========================================================================

module
{
    namespace Elastos {
    namespace Core {

    interface IArrayOf {
        GetLength(
            [out] Int32* size);

        Get(
            [in] Int32 index,
            [out] IInterface** element);

        Set(
            [in] Int32 index,
            [in] IInterface* element);

        GetTypeId(
            [out] InterfaceID* id);

        /**
         * Creates a <i>"deep"</i> {@code String} representation of the
         * {@code Object[]} passed, such that if the array contains other arrays,
         * the {@code String} representation of those arrays is generated as well.
         * <p>
         * If any of the elements are primitive arrays, the generation is delegated
         * to the other {@code toString} methods in this class. If any element
         * contains a reference to the original array, then it will be represented
         * as {@code "[...]"}. If an element is an {@code Object[]}, then its
         * representation is generated by a recursive call to this method. All other
         * elements are converted via the {@link String#valueOf(Object)} method.
         *
         * @param array
         *            the {@code Object} array to convert.
         * @return the {@code String} representation of {@code array}.
         * @since 1.5
         */
        DeepToString(
            [out] String* str);

        /**
         * Returns a hash code based on the "deep contents" of the given array. If
         * the array contains other arrays as its elements, the hash code is based
         * on their contents not their identities. So it is not acceptable to invoke
         * this method on an array that contains itself as an element, either
         * directly or indirectly.
         * <p>
         * For any two arrays {@code a} and {@code b}, if
         * {@code Arrays.deepEquals(a, b)} returns {@code true}, it
         * means that the return value of {@code Arrays.deepHashCode(a)} equals
         * {@code Arrays.deepHashCode(b)}.
         * <p>
         * The computation of the value returned by this method is similar to that
         * of the value returned by {@link List#hashCode()} invoked on a
         * {@link List} containing a sequence of instances representing the
         * elements of array in the same order. The difference is: If an element e
         * of array is itself an array, its hash code is computed by calling the
         * appropriate overloading of {@code Arrays.hashCode(e)} if e is an array of a
         * primitive type, or by calling {@code Arrays.deepHashCode(e)} recursively if e is
         * an array of a reference type. The value returned by this method is the
         * same value as the method {@code Arrays.asList(array).hashCode()}. If the array is
         * {@code null}, the return value is 0.
         *
         * @param array
         *            the array whose hash code to compute.
         * @return the hash code for {@code array}.
         */
        DeepGetHashCode(
            [out] Int32* hash);

        /**
         * Returns {@code true} if the two given arrays are deeply equal to one another.
         * Unlike the method {@code equals(Object[] array1, Object[] array2)}, this method
         * is appropriate for use for nested arrays of arbitrary depth.
         * <p>
         * Two array references are considered deeply equal if they are both {@code null},
         * or if they refer to arrays that have the same length and the elements at
         * each index in the two arrays are equal.
         * <p>
         * Two {@code null} elements {@code element1} and {@code element2} are possibly deeply equal if any
         * of the following conditions satisfied:
         * <p>
         * {@code element1} and {@code element2} are both arrays of object reference types, and
         * {@code Arrays.deepEquals(element1, element2)} would return {@code true}.
         * <p>
         * {@code element1} and {@code element2} are arrays of the same primitive type, and the
         * appropriate overloading of {@code Arrays.equals(element1, element2)} would return
         * {@code true}.
         * <p>
         * {@code element1 == element2}
         * <p>
         * {@code element1.equals(element2)} would return {@code true}.
         * <p>
         * Note that this definition permits {@code null} elements at any depth.
         * <p>
         * If either of the given arrays contain themselves as elements, the
         * behavior of this method is uncertain.
         *
         * @param array1
         *            the first {@code Object} array.
         * @param array2
         *            the second {@code Object} array.
         * @return {@code true} if both arrays are {@code null} or if the arrays have the
         *         same length and the elements at each index in the two arrays are
         *         equal according to {@code equals()}, {@code false} otherwise.
         */
        DeepEquals(
            [in] IArrayOf* other,
            [out] Boolean* equals);
    }

    } // namespace Core
    } // namespace Elastos
}
